<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker 容器数据卷挂载小结</title>
    <url>/2019/10/26/Docker-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8C%82%E8%BD%BD%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>为了更直观了解数据卷挂载的操作，做个实验一一验证数据卷挂载的各种情况。</p>
<p><strong>情况一、本地不存在文件挂载到容器存在文件</strong></p>
<p>首先是当本地不存在该文件，而容器内存在该文件的情况，尝试把不存在的文件挂载到存在该文件的容器中。以一个 Alpine 镜像为例，这里把一个修改后的 Alpine 镜像打了新标签，叫做 volume_test：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 本地目录不存在 test 文件。</span><br><span class="line">$ docker run --name=test -v ~/test.txt:/etc/hosts -d volume_test</span><br><span class="line">0cba2e50229df7508c616bd456c4ab131f2fe1a88385c34f8a5876fbc577b176</span><br><span class="line">docker: Error response from daemon: oci runtime error: rootfs_linux.go:53: mounting</span><br><span class="line">&quot;/var/lib/docker/devicemapper/mnt/6b83c07ebedcb828f34cac69eac5a85ce3a5f59e1e8688c8dae40198671d0ecb/rootfs/etc/hosts&quot; to rootfs</span><br><span class="line">&quot;/var/lib/docker/devicemapper/mnt/6b83c07ebedcb828f34cac69eac5a85ce3a5f59e1e8688c8dae40198671d0ecb/rootfs&quot; caused &quot;not a directory&quot;.</span><br><span class="line"># 启动容器失败。</span><br></pre></td></tr></table></figure>

<p><strong>情况二、本地不存在文件夹挂载到容器存在文件夹</strong></p>
<p>然后是把本地不存在的文件夹挂载到容器内存在的文件夹，在 volume_test 镜像中存在一个 /srv 的文件夹，文件夹里面有一个 index.php 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 本地目录不存在 srv文件夹。</span><br><span class="line">$ docker run --name=test -v ~/srv:/srv -d volume_test </span><br><span class="line">c71cf1cfa4932e3e398a7d6c4e2ae94f915b832f5506e374aedb19af4cb1ac62</span><br><span class="line"># 启动正常，但是进入容器发现目录被清空。</span><br><span class="line">$ docker exec -it test sh</span><br><span class="line">/srv # ls</span><br><span class="line">/srv #</span><br></pre></td></tr></table></figure>

<p><strong>情况三、宿主机存在文件挂载到容器不存在文件</strong></p>
<p>我们继续，假设宿主机存在文件，容器内不存在该文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 本地目录存在 test.txt文件</span><br><span class="line">$ docker run --name=test -v ~/test.txt:/srv/test.txt-d volume_test </span><br><span class="line">2d6853c10643a735ae3d7f3aaac8c6344f9c75170e531f613d08db7cdf484e54</span><br><span class="line"># 容器内存在 /srv 文件夹，里面原本有一个 index.php 。</span><br><span class="line">$ docker exec -it test sh</span><br><span class="line">/srv # ls</span><br><span class="line">index.php  test.txt</span><br><span class="line">/srv # </span><br><span class="line"># 可以看到文件挂载成功。</span><br></pre></td></tr></table></figure>

<p><strong>情况四、宿主机存在文件夹挂载到容器不存在文件夹</strong></p>
<p>接下来是宿主机存在文件夹，容器不存在该文件夹，宿主机的 test 文件夹里面存在一个 hello 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name=test -v ~/test:/srv/test -d volume_test </span><br><span class="line">c935ffa0d9fc5e5ac8f213a51a878e71056472b0597d2e385a29e5c748012958</span><br><span class="line"># 进入容器，查看是否存在 test 文件夹，以及文件夹里面是否有 hello 文件。</span><br><span class="line">$ docker exec -it test sh</span><br><span class="line">/srv # ls</span><br><span class="line">index.php  test</span><br><span class="line">/srv # cd test/</span><br><span class="line">/srv/test # ls</span><br><span class="line">hello</span><br><span class="line">/srv/test #</span><br></pre></td></tr></table></figure>

<p>上面两个例子说明了，容器内部如果不存在文件，宿主机直接挂载。</p>
<p><strong>情况五、宿主机文件夹挂载到容器文件</strong></p>
<p>接下来假设宿主机存在 test 文件夹，而容器内部存在的是名为 test 文件，这样挂载会怎样呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name=test -v ~/test:/srv/test-d volume_test </span><br><span class="line">385bc78e5333460da11f04535da27a3fd226df218f95c970ff2dd5609b17f816</span><br><span class="line">docker: Error response from daemon: oci runtime error: rootfs_linux.go:53: mounting </span><br><span class="line">&quot;/var/lib/docker/devicemapper/mnt/fd5c42e844c3550d1a372ed939ed57f90dcacbd375dfed1bedfbb71ef6f3f185/rootfs/etc/hosts&quot; to rootfs </span><br><span class="line">&quot;/var/lib/docker/devicemapper/mnt/fd5c42e844c3550d1a372ed939ed57f90dcacbd375dfed1bedfbb71ef6f3f185/rootfs&quot; caused &quot;not a directory&quot;.</span><br></pre></td></tr></table></figure>

<p>上面的情况不出意外是启动错误。</p>
<p><strong>情况六、同名文件夹挂载</strong></p>
<p>那么假设宿主机是文件夹，容器也是文件夹，两个文件夹里面内容不一样，宿主机内部有一个 hello 文件，容器的文件夹里面有一个 index.php ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name=test -v ~/srv:/srv -d volume_test </span><br><span class="line">3aec30122bd7010c694e0ff8b77f7b7b6bb6f850c258786db125313060fad43b</span><br><span class="line">$ docker exec-it test sh</span><br><span class="line">/srv # ls</span><br><span class="line">hello</span><br><span class="line">/srv # </span><br><span class="line"># 可以看到，宿主机文件夹会覆盖容器内部的文件夹。</span><br></pre></td></tr></table></figure>

<p><strong>情况七、同名文件挂载</strong></p>
<p>假设宿主机有一个 test.txt 文件，里面写着 Hello World，而容器里面也存在一个 test.txt 文件，里面写着 Hi World，现在挂载文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name=test -v ~/test.txt:/srv/test.txt -d volume_test </span><br><span class="line">047cbfe45b5bc868c864fe94f7a22643d52b644947f40260097dbb579de56c5c</span><br><span class="line">$ docker exec -it test sh</span><br><span class="line">/srv # cat /test</span><br><span class="line">Hello World</span><br><span class="line">/srv # </span><br><span class="line"># 宿主机会覆盖容器的文件。</span><br></pre></td></tr></table></figure>

<p><strong>情况八、宿主机文件挂载到容器文件夹</strong></p>
<p>最后一种情况，宿主机存在文件 test.txt，而容器内部存在一个 test 的文件夹，现在把 文件挂载到文件夹中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name=test -v ~/test.txt:/test -d volume_test </span><br><span class="line">59b5fd74a1e9e17aa2a6a9be7900b16c7dd4b3c424a4fa72a7671fa1c51bdf69</span><br><span class="line">docker: Error response from daemon: oci runtime error: rootfs_linux.go:53: mounting </span><br><span class="line">&quot;/var/lib/docker/devicemapper/mnt/b201054ed36a189b5abb599082d0b5bcbe31d07611a0985deefd79d1221447fd/rootfs/home&quot; to rootfs </span><br><span class="line">&quot;/var/lib/docker/devicemapper/mnt/b201054ed36a189b5abb599082d0b5bcbe31d07611a0985deefd79d1221447fd/rootfs&quot; caused &quot;not a directory&quot;.</span><br><span class="line"># 启动失败。</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<table>
<thead>
<tr>
<th><strong>宿主机文件</strong></th>
<th><strong>容器内文件</strong></th>
<th><strong>启动参数(加粗为不存在)</strong></th>
<th><strong>容器启动情况</strong></th>
</tr>
</thead>
<tbody><tr>
<td>不存在</td>
<td>文件</td>
<td>-v <strong>~/test.txt</strong>:/etc/hosts</td>
<td>启动错误</td>
</tr>
<tr>
<td>不存在</td>
<td>文件夹</td>
<td>-v <strong>~/srv</strong>:/srv</td>
<td>启动正常</td>
</tr>
<tr>
<td>文件</td>
<td>不存在</td>
<td>-v ~/test.txt:<strong>/srv/test.txt</strong></td>
<td>启动正常</td>
</tr>
<tr>
<td>文件夹</td>
<td>不存在</td>
<td>~/test:<strong>/srv/test</strong></td>
<td>启动正常</td>
</tr>
<tr>
<td>文件夹</td>
<td>文件</td>
<td>~/test:/srv/test</td>
<td>启动错误</td>
</tr>
<tr>
<td>文件夹</td>
<td>文件夹</td>
<td>-v ~/srv:/srv</td>
<td>启动正常</td>
</tr>
<tr>
<td>文件</td>
<td>文件</td>
<td>-v ~/test.txt:/srv/test.txt</td>
<td>启动正常</td>
</tr>
<tr>
<td>文件</td>
<td>文件夹</td>
<td>-v ~/test.txt:/test</td>
<td>启动错误</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>pip/pip3切换国内源</title>
    <url>/2019/10/26/pip-pip3%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<blockquote>
<p>有时候pip的速度太慢，切换到国内的源很有必要</p>
</blockquote>
<p><strong>创建并编辑pip配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~/.pip &amp;&amp; vim ~/.pip/pip.conf</span><br></pre></td></tr></table></figure>
<p><strong>然后将下面这两行复制进去就好了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>国内其他pip源</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">清华:</span><br><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple </span><br><span class="line"></span><br><span class="line">中国科技大学:</span><br><span class="line">https://pypi.mirrors.ustc.edu.cn/simple/ </span><br><span class="line"></span><br><span class="line">华中理工大学:</span><br><span class="line">http://pypi.hustunique.com/ </span><br><span class="line"></span><br><span class="line">山东理工大学:</span><br><span class="line">http://pypi.sdutlinux.org/ </span><br><span class="line"></span><br><span class="line">豆瓣:</span><br><span class="line">http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装Python3.8.0</title>
    <url>/2019/10/26/CentOS7%E5%AE%89%E8%A3%85Python3-8/</url>
    <content><![CDATA[<h4 id="安装支持库"><a href="#安装支持库" class="headerlink" title="安装支持库"></a>安装支持库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel -y</span><br><span class="line">yum install sqlite-devel readline-devel tk-devel libffi-devel -y</span><br><span class="line">yum install gcc make -y</span><br></pre></td></tr></table></figure>

<h4 id="安装Python3"><a href="#安装Python3" class="headerlink" title="安装Python3"></a>安装Python3</h4><p><strong>下载安装包</strong><br>以3.8.0为例，需要下载其它版本请访问：<a href="https://www.python.org/ftp/python" target="_blank" rel="noopener">https://www.python.org/ftp/python</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tgz</span><br></pre></td></tr></table></figure>
<p><strong>解压安装包</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xzvf Python-3.8.0.tgz</span><br><span class="line">cd Python-3.8.0</span><br></pre></td></tr></table></figure>
<p><strong>编译安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./conigure --prefix=/usr/local/python3</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><em>优化选项（可选）执行完上一步后会提示执行以下的代码对Python解释器进行优化，执行该代码后，会编译安装到 /usr/local/bin/ 下，且不用添加软连接或环境变量</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --enable-optimizations</span><br></pre></td></tr></table></figure>

<p><strong>创建软链接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python3</span><br></pre></td></tr></table></figure>

<h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>centos</tag>
      </tags>
  </entry>
</search>
