<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>25条有用的iptables常用示例</title>
    <url>/2021/06/30/25%E6%9D%A1%E6%9C%89%E7%94%A8%E7%9A%84iptables%E5%B8%B8%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="25-条有用的-iptables-常用示例"><a href="#25-条有用的-iptables-常用示例" class="headerlink" title="25 条有用的 iptables 常用示例"></a>25 条有用的 iptables 常用示例</h2><p>本文将给出25个iptables常用规则示例，这些例子为您提供了些基本的模板，您可以根据特定需求对其进行修改调整以达到期望。</p>
<p><strong>格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables [-t 表名] 选项 [链名] [条件] [-j 控制类型]</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><blockquote>
<p>-P 设置默认策略:iptables -P INPUT (DROP|ACCEPT)<br>-F 清空规则链<br>-L 查看规则链<br>-A 在规则链的末尾加入新规则<br>-I num 在规则链的头部加入新规则<br>-D num 删除某一条规则<br>-s 匹配来源地址IP/MASK，加叹号”!”表示除这个IP外。<br>-d 匹配目标地址<br>-i 网卡名称 匹配从这块网卡流入的数据<br>-o 网卡名称 匹配从这块网卡流出的数据<br>-p 匹配协议,如tcp,udp,icmp<br>–dport num 匹配目标端口号<br>–sport num 匹配来源端口号</p>
</blockquote>
<a id="more"></a>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="1-删除已有规则"><a href="#1-删除已有规则" class="headerlink" title="1. 删除已有规则"></a>1. 删除已有规则</h5><p>在开始创建iptables规则之前，你也许需要删除已有规则。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -F</span><br><span class="line">(or)</span><br><span class="line">iptables –flush</span><br></pre></td></tr></table></figure>

<h5 id="2-设置链的默认策略"><a href="#2-设置链的默认策略" class="headerlink" title="2.设置链的默认策略"></a>2.设置链的默认策略</h5><p>链的默认政策设置为”ACCEPT”（接受），若要将INPUT,FORWARD,OUTPUT链设置成”DROP”（拒绝），命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br></pre></td></tr></table></figure>

<p>当INPUT链和OUTPUT链都设置成DROP时，对于每一个防火墙规则，我们都应该定义两个规则。例如：一个传入另一个传出。在下面所有的例子中，由于我们已将DROP设置成INPUT链和OUTPUT链的默认策略，每种情况我们都将制定两条规则。当然，如果你相信你的内部用户,则可以省略上面的最后一行。例如：默认不丢弃所有出站的数据包。在这种情况下,对于每一个防火墙规则要求,你只需要制定一个规则——只对进站的数据包制定规则。</p>
<h5 id="3-阻止指定IP地址"><a href="#3-阻止指定IP地址" class="headerlink" title="3. 阻止指定IP地址"></a>3. 阻止指定IP地址</h5><p>例：丢弃来自IP地址x.x.x.x的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BLOCK_THIS_IP&#x3D;&quot;x.x.x.x&quot;</span><br><span class="line">iptables -A INPUT -s &quot;$BLOCK_THIS_IP&quot; -j DROP</span><br></pre></td></tr></table></figure>

<p>注：当你在log里发现来自某ip地址的异常记录，可以通过此命令暂时阻止该地址的访问以做更深入分析</p>
<p>例：阻止来自IP地址x.x.x.x eth0 tcp的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -s &quot;$BLOCK_THIS_IP&quot; -j DROP</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp -s &quot;$BLOCK_THIS_IP&quot; -j DROP</span><br></pre></td></tr></table></figure>

<h5 id="4-允许所有SSH的连接请求"><a href="#4-允许所有SSH的连接请求" class="headerlink" title="4. 允许所有SSH的连接请求"></a>4. 允许所有SSH的连接请求</h5><p>例：允许所有来自外部的SSH连接请求，即只允许进入eth0接口，并且目标端口为22的数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="5-仅允许来自指定网络的SSH连接请求"><a href="#5-仅允许来自指定网络的SSH连接请求" class="headerlink" title="5. 仅允许来自指定网络的SSH连接请求"></a>5. 仅允许来自指定网络的SSH连接请求</h5><p>例：仅允许来自于192.168.100.0/24域的用户的ssh连接请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp -s 192.168.100.0&#x2F;24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="6-允许http和https的连接请求"><a href="#6-允许http和https的连接请求" class="headerlink" title="6.允许http和https的连接请求"></a>6.允许http和https的连接请求</h5><p>例：允许所有来自web - http的连接请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>例：允许所有来自web - https的连接请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="7-使用multiport-将多个规则结合在一起"><a href="#7-使用multiport-将多个规则结合在一起" class="headerlink" title="7. 使用multiport 将多个规则结合在一起"></a>7. 使用multiport 将多个规则结合在一起</h5><p>允许多个端口从外界连入，除了为每个端口都写一条独立的规则外，我们可以用multiport将其组合成一条规则。如下所示：</p>
<p>例：允许所有ssh,http,https的流量访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp -m multiport --sports 22,80,443 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="8-允许从本地发起的SSH请求"><a href="#8-允许从本地发起的SSH请求" class="headerlink" title="8. 允许从本地发起的SSH请求"></a>8. 允许从本地发起的SSH请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>请注意,这与允许ssh连入的规则略有不同。本例在OUTPUT链上，我们允许NEW和ESTABLISHED状态。在INPUT链上，我们只允许ESTABLISHED状态。ssh连入的规则与之相反。</p>
<h5 id="9-仅允许从本地发起到一个指定的网络域的SSH请求"><a href="#9-仅允许从本地发起到一个指定的网络域的SSH请求" class="headerlink" title="9. 仅允许从本地发起到一个指定的网络域的SSH请求"></a>9. 仅允许从本地发起到一个指定的网络域的SSH请求</h5><p>例：仅允许从内部连接到网域192.168.100.0/24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -o eth0 -p tcp -d 192.168.100.0&#x2F;24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="10-允许从本地发起的HTTPS连接请求"><a href="#10-允许从本地发起的HTTPS连接请求" class="headerlink" title="10. 允许从本地发起的HTTPS连接请求"></a>10. 允许从本地发起的HTTPS连接请求</h5><p>下面的规则允许输出安全的网络流量。如果你想允许用户访问互联网，这是非常有必要的。在服务器上，这些规则能让你使用wget从外部下载一些文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -o eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A INPUT -i eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>注：对于HTTP web流量的外联请求，只需要将上述命令中的端口从443改成80即可。</p>
<h5 id="11-负载平衡传入的网络流量"><a href="#11-负载平衡传入的网络流量" class="headerlink" title="11. 负载平衡传入的网络流量"></a>11. 负载平衡传入的网络流量</h5><p>使用iptables可以实现传入web流量的负载均衡，我们可以传入web流量负载平衡使用iptables防火墙规则。<br>例：使用iptables nth将HTTPS流量负载平衡至三个不同的ip地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.101:443iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 1 -j DNAT --to-destination 192.168.1.102:443iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 2 -j DNAT --to-destination 192.168.1.103:443</span><br></pre></td></tr></table></figure>

<h5 id="12-允许外部主机ping内部主机"><a href="#12-允许外部主机ping内部主机" class="headerlink" title="12. 允许外部主机ping内部主机"></a>12. 允许外部主机ping内部主机</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPTiptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="13-允许内部主机ping外部主机"><a href="#13-允许内部主机ping外部主机" class="headerlink" title="13. 允许内部主机ping外部主机"></a>13. 允许内部主机ping外部主机</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPTiptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="14-允许回环访问"><a href="#14-允许回环访问" class="headerlink" title="14. 允许回环访问"></a>14. 允许回环访问</h5><p>例：在服务器上允许127.0.0.1回环访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i lo -j ACCEPTiptables -A OUTPUT -o lo -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="15-允许内部网络域外部网络的通信"><a href="#15-允许内部网络域外部网络的通信" class="headerlink" title="15. 允许内部网络域外部网络的通信"></a>15. 允许内部网络域外部网络的通信</h5><p>防火墙服务器上的其中一个网卡连接到外部，另一个网卡连接到内部服务器，使用以下规则允许内部网络与外部网络的通信。此例中，eth1连接到外部网络(互联网)，eth0连接到内部网络(例如:192.168.1.x)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="16-允许出站的DNS连接"><a href="#16-允许出站的DNS连接" class="headerlink" title="16. 允许出站的DNS连接"></a>16. 允许出站的DNS连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPTiptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="17-允许NIS连接"><a href="#17-允许NIS连接" class="headerlink" title="17. 允许NIS连接"></a>17. 允许NIS连接</h5><p>如果你使用NIS管理用户帐户，你需要允许NIS连接。如果你不允许NIS相关的ypbind连接请求，即使SSH连接请求已被允许，用户仍然无法登录。NIS的端口是动态的，先使用命令rpcinfo –p来知道端口号，此例中为853和850端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcinfo -p | grep ypbind</span><br></pre></td></tr></table></figure>

<p>例：允许来自111端口以及ypbind使用端口的连接请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 111 -j ACCEPTiptables -A INPUT -p udp --dport 111 -j ACCEPTiptables -A INPUT -p tcp --dport 853 -j ACCEPTiptables -A INPUT -p udp --dport 853 -j ACCEPTiptables -A INPUT -p tcp --dport 850 -j ACCEPTiptables -A INPUT -p udp --dport 850 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>注：当你重启ypbind之后端口将不同，上述命令将无效。有两种解决方案：1）使用你NIS的静态IP 2）编写shell脚本通过“rpcinfo - p”命令自动获取动态端口号,并在上述iptables规则中使用。</p>
<h5 id="18-允许来自指定网络的rsync连接请求"><a href="#18-允许来自指定网络的rsync连接请求" class="headerlink" title="18. 允许来自指定网络的rsync连接请求"></a>18. 允许来自指定网络的rsync连接请求</h5><p>例：允许来自网络192.168.101.0/24的rsync连接请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp -s 192.168.101.0&#x2F;24 --dport 873 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 873 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="19-允许来自指定网络的MySQL连接请求"><a href="#19-允许来自指定网络的MySQL连接请求" class="headerlink" title="19. 允许来自指定网络的MySQL连接请求"></a>19. 允许来自指定网络的MySQL连接请求</h5><p>很多情况下，MySQL数据库与web服务跑在同一台服务器上。有时候我们仅希望DBA和开发人员从内部网络（192.168.100.0/24）直接登录数据库，可尝试以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp -s 192.168.100.0&#x2F;24 --dport 3306 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 3306 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="20-允许Sendmail-Postfix邮件服务"><a href="#20-允许Sendmail-Postfix邮件服务" class="headerlink" title="20. 允许Sendmail, Postfix邮件服务"></a>20. 允许Sendmail, Postfix邮件服务</h5><p>Sendmail和postfix都使用了25端口，因此我们只需要允许来自25端口的连接请求即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 25 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 25 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="21-允许IMAP和IMAPS"><a href="#21-允许IMAP和IMAPS" class="headerlink" title="21. 允许IMAP和IMAPS"></a>21. 允许IMAP和IMAPS</h5><p>例：允许IMAP/IMAP2流量，端口为143</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 143 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 143 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>例：允许IMAPS流量，端口为993</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 993 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 993 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="22-允许POP3和POP3S"><a href="#22-允许POP3和POP3S" class="headerlink" title="22. 允许POP3和POP3S"></a>22. 允许POP3和POP3S</h5><p>例：允许POP3访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 110 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 110 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>例：允许POP3S访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 995 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 995 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="23-防止DoS攻击"><a href="#23-防止DoS攻击" class="headerlink" title="23. 防止DoS攻击"></a>23. 防止DoS攻击</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -m limit --limit 25&#x2F;minute --limit-burst 100 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>上述例子中：</p>
<blockquote>
<p>-m limit: 启用limit扩展<br>–limit 25/minute: 允许最多每分钟25个连接（根据需求更改）。<br>–limit-burst 100: 只有当连接达到limit-burst水平(此例为100)时才启用上述limit/minute限制。</p>
</blockquote>
<h5 id="24-端口转发"><a href="#24-端口转发" class="headerlink" title="24. 端口转发"></a>24. 端口转发</h5><p>例：将来自422端口的流量全部转到22端口。</p>
<p>这意味着我们既能通过422端口又能通过22端口进行ssh连接。启用DNAT转发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to 192.168.102.37:22</span><br></pre></td></tr></table></figure>

<p>除此之外，还需要允许连接到422端口的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 422 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h5 id="25-记录丢弃的数据表"><a href="#25-记录丢弃的数据表" class="headerlink" title="25. 记录丢弃的数据表"></a>25. 记录丢弃的数据表</h5><p>第一步：新建名为LOGGING的链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -N LOGGING</span><br></pre></td></tr></table></figure>

<p>第二步：将所有来自INPUT链中的数据包跳转到LOGGING链中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -j LOGGING</span><br></pre></td></tr></table></figure>

<p>第三步：为这些包自定义个前缀，命名为”IPTables Packet Dropped”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A LOGGING -m limit --limit 2&#x2F;min -j LOG --log-prefix &quot;IPTables Packet Dropped: &quot; --log-level 7</span><br></pre></td></tr></table></figure>

<p>第四步：丢弃这些数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A LOGGING -j DROP</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>firewall</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 6/7 firewall-cmd与iptables使用</title>
    <url>/2020/01/07/CentOS-6-7-firewall-cmd%E4%B8%8Eiptables%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一、CentOS7版本对防火墙进行加强-不再使用原来的iptables-启用firewalld"><a href="#一、CentOS7版本对防火墙进行加强-不再使用原来的iptables-启用firewalld" class="headerlink" title="一、CentOS7版本对防火墙进行加强,不再使用原来的iptables,启用firewalld"></a>一、CentOS7版本对防火墙进行加强,不再使用原来的iptables,启用firewalld</h3><h5 id="1-firewalld的基本使用"><a href="#1-firewalld的基本使用" class="headerlink" title="1.firewalld的基本使用"></a>1.firewalld的基本使用</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">启动：  `systemctl start firewalld`</span><br><span class="line">查状态：`systemctl status firewalld `</span><br><span class="line">停止：  `systemctl <span class="built_in">disable</span> firewalld`</span><br><span class="line">禁用：  `systemctl stop firewalld`</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在开机时启用一个服务：`systemctl <span class="built_in">enable</span> firewalld.service`</span><br><span class="line">在开机时禁用一个服务：`systemctl <span class="built_in">disable</span> firewalld.service`</span><br><span class="line">查看服务是否开机启动：`systemctl is-enabled firewalld.service`</span><br><span class="line">查看已启动的服务列表：`systemctl list-unit-files|grep enabled`</span><br><span class="line">查看启动失败的服务列表：`systemctl *--failed`*</span><br></pre></td></tr></table></figure>
<h5 id="2-配置firewalld-cmd"><a href="#2-配置firewalld-cmd" class="headerlink" title="2.配置firewalld-cmd"></a>2.配置firewalld-cmd</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看版本： `firewall-cmd *--version`*</span><br><span class="line">查看帮助： `firewall-cmd *--<span class="built_in">help</span>`*</span><br><span class="line">显示状态： `firewall-cmd *--state`*</span><br><span class="line">查看所有打开的端口： `firewall-cmd *--zone=public --list-ports`*</span><br><span class="line">更新防火墙规则： `firewall-cmd *--reload`*</span><br><span class="line">查看区域信息:  `firewall-cmd *--get-active-zones`*</span><br><span class="line">查看指定接口所属区域： `firewall-cmd *--get-zone-of-interface=eth0`*</span><br><span class="line">拒绝所有包：`firewall-cmd *--panic-on`*</span><br><span class="line">取消拒绝状态： `firewall-cmd *--panic-off`*</span><br><span class="line">查看是否拒绝： `firewall-cmd *--query-panic`*</span><br></pre></td></tr></table></figure>
<h5 id="3-那怎么开启一个端口呢"><a href="#3-那怎么开启一个端口呢" class="headerlink" title="3.那怎么开启一个端口呢"></a>3.那怎么开启一个端口呢</h5><p>添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public(作用域) --add-port=80/tcp(端口和访问类型) --permanent(永久生效)</span><br><span class="line">firewall-cmd --zone=public --add-service=http --permanent</span><br><span class="line">firewall-cmd --reload    <span class="comment"># 重新载入，更新防火墙规则</span></span><br><span class="line">firewall-cmd --zone= public --query-port=80/tcp  <span class="comment">#查看</span></span><br><span class="line">firewall-cmd --zone= public --remove-port=80/tcp --permanent  <span class="comment"># 删除</span></span><br><span class="line">firewall-cmd --list-services</span><br><span class="line">firewall-cmd --get-services</span><br><span class="line">firewall-cmd --add-service=</span><br><span class="line">firewall-cmd --delete-service=</span><br></pre></td></tr></table></figure>

<p>在每次修改端口和服务后/etc/firewalld/zones/public.xml文件就会被修改,所以也可以在文件中之间修改,然后重新加载</p>
<p>使用命令实际也是在修改文件，需要重新加载才能生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --query-port=80/tcp</span><br><span class="line">firewall-cmd --zone=public --query-port=8080/tcp</span><br><span class="line">firewall-cmd --zone=public --query-port=3306/tcp</span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --query-port=3306/tcp</span><br><span class="line">firewall-cmd --zone=public --query-port=8080/tcp</span><br><span class="line">firewall-cmd --reload <span class="comment"># 重新加载后才能生效</span></span><br><span class="line">firewall-cmd --zone=public --query-port=3306/tcp</span><br><span class="line">firewall-cmd --zone=public --query-port=8080/tcp</span><br></pre></td></tr></table></figure>

<h5 id="4-参数解释"><a href="#4-参数解释" class="headerlink" title="4.参数解释"></a>4.参数解释</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">–add-service <span class="comment">#添加的服务</span></span><br><span class="line">–zone <span class="comment">#作用域</span></span><br><span class="line">–add-port=80/tcp <span class="comment">#添加端口，格式为：端口/通讯协议</span></span><br><span class="line">–permanent <span class="comment">#永久生效，没有此参数重启后失效</span></span><br></pre></td></tr></table></figure>

<h5 id="5-详细使用"><a href="#5-详细使用" class="headerlink" title="5.详细使用"></a>5.详细使用</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看使用中的规则</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line">firewall-cmd --zone=public --list-all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口允许所有 IP 访问</span></span><br><span class="line">firewall-cmd --zone=public --add-port=端口/tcp --permanent</span><br><span class="line"><span class="comment"># 删除上一条规则 (add 改成 remove)</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=端口/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 举例</span></span><br><span class="line"><span class="comment"># 允许访问 2222 端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=2222/tcp --permanent</span><br><span class="line"><span class="comment"># 允许访问 8080 端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"><span class="comment"># 删除规则( add 改成 remove )</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=2222/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --remove-port=8080/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载规则, 才能生效</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 查看使用中的规则</span></span><br><span class="line">firewall-cmd --list-all  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口针对某个IP开放</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">"rule family="</span>ipv4<span class="string">" source address="</span>192.168.1.46<span class="string">" port protocol="</span>tcp<span class="string">" port="</span>6379<span class="string">" accept"</span></span><br><span class="line"><span class="comment"># 删除规则</span></span><br><span class="line">firewall-cmd --permanent --remove-rich-rule=<span class="string">"rule family="</span>ipv4<span class="string">" source address="</span>192.168.1.46<span class="string">" port protocol="</span>tcp<span class="string">" port="</span>6379<span class="string">" accept"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口针对某个IP段访问</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">"rule family="</span>ipv4<span class="string">" source address="</span>192.168.0.0/16<span class="string">" accept"</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">"rule family="</span>ipv4<span class="string">" source address="</span>192.168.1.0/24<span class="string">" port protocol="</span>tcp<span class="string">" port="</span>9200<span class="string">" accept"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个端口</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=8080-8083/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否允许伪装IP</span></span><br><span class="line">firewall-cmd --query-masquerade  </span><br><span class="line"><span class="comment"># 允许防火墙伪装IP</span></span><br><span class="line">firewall-cmd --add-masquerade</span><br><span class="line"><span class="comment"># 禁止防火墙伪装IP</span></span><br><span class="line">firewall-cmd --remove-masquerade</span><br><span class="line"><span class="comment"># 将80端口的流量转发至8080</span></span><br><span class="line">firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080</span><br><span class="line"><span class="comment"># 将80端口的流量转发至192.168.0.1</span></span><br><span class="line">firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.1.0.1</span><br><span class="line"><span class="comment"># 将80端口的流量转发至192.168.0.1的8080端口</span></span><br><span class="line">firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.0.1:toport=8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除配置</span></span><br><span class="line">firewall-cmd --permanent --zone=public --remove-rich-rule=<span class="string">'rule family="ipv4" source address="192.168.0.4/24" service name="http" accept'</span></span><br><span class="line"><span class="comment"># 设置某个IP访问某个服务</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-rich-rule=<span class="string">'rule family="ipv4" source address="192.168.0.4/24" service name="http" accept'</span></span><br></pre></td></tr></table></figure>

<h5 id="6-使用示例"><a href="#6-使用示例" class="headerlink" title="6.使用示例"></a>6.使用示例</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state               <span class="comment">#查看防火墙状态  </span></span><br><span class="line">firewall-cmd --reload              <span class="comment">#更新防火墙规则  </span></span><br><span class="line">firewall-cmd --state               <span class="comment">#查看防火墙状态  </span></span><br><span class="line">firewall-cmd --reload              <span class="comment">#重载防火墙规则  </span></span><br><span class="line">firewall-cmd --list-ports          <span class="comment">#查看所有打开的端口  </span></span><br><span class="line">firewall-cmd --list-services       <span class="comment">#查看所有允许的服务  </span></span><br><span class="line">firewall-cmd --get-services        <span class="comment">#获取所有支持的服务</span></span><br></pre></td></tr></table></figure>

<p>#区域相关</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all-zones                    <span class="comment">#查看所有区域信息  </span></span><br><span class="line">firewall-cmd --get-active-zones                  <span class="comment">#查看活动区域信息  </span></span><br><span class="line">firewall-cmd --<span class="built_in">set</span>-default-zone=public           <span class="comment">#设置public为默认区域  </span></span><br><span class="line">firewall-cmd --get-default-zone                  <span class="comment">#查看默认区域信息  </span></span><br><span class="line">firewall-cmd --zone=public --add-interface=eth0  <span class="comment">#将接口eth0加入区域public</span></span><br></pre></td></tr></table></figure>

<p>#接口相关</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --remove-interface=eth0     <span class="comment">#从区域public中删除接口eth0  </span></span><br><span class="line">firewall-cmd --zone=default --change-interface=eth0    <span class="comment">#修改接口eth0所属区域为default  </span></span><br><span class="line">firewall-cmd --get-zone-of-interface=eth0              <span class="comment">#查看接口eth0所属区域</span></span><br></pre></td></tr></table></figure>

<p>#端口控制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#永久添加80端口例外(全局)</span></span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent </span><br><span class="line"></span><br><span class="line"><span class="comment">#永久删除80端口例外(全局)</span></span><br><span class="line">firewall-cmd --remove-port=80/tcp --permanent </span><br><span class="line"></span><br><span class="line"><span class="comment">#永久增加65001-65010例外(全局)  </span></span><br><span class="line">firewall-cmd --add-port=65001-65010/tcp --permanent </span><br><span class="line"></span><br><span class="line"><span class="comment">#永久添加80端口例外(区域public)</span></span><br><span class="line">firewall-cmd  --zone=public --add-port=80/tcp --permanent </span><br><span class="line"></span><br><span class="line"><span class="comment">#永久删除80端口例外(区域public)</span></span><br><span class="line">firewall-cmd  --zone=public --remove-port=80/tcp --permanent </span><br><span class="line"></span><br><span class="line"><span class="comment">#永久增加65001-65010例外(区域public) </span></span><br><span class="line">firewall-cmd  --zone=public --add-port=65001-65010/tcp --permanent </span><br><span class="line"></span><br><span class="line"><span class="comment">#查询端口是否开放</span></span><br><span class="line">firewall-cmd --query-port=8080/tcp </span><br><span class="line"></span><br><span class="line"><span class="comment">#开放80端口</span></span><br><span class="line">firewall-cmd --permanent --add-port=80/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment">#移除端口</span></span><br><span class="line">firewall-cmd --permanent --remove-port=8080/tcp </span><br><span class="line"></span><br><span class="line"><span class="comment">#重启防火墙(修改配置后要重启防火墙)</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>



<h3 id="二、CentOS7以下版本"><a href="#二、CentOS7以下版本" class="headerlink" title="二、CentOS7以下版本"></a>二、CentOS7以下版本</h3><h5 id="1-开放80，22，8080-端口"><a href="#1-开放80，22，8080-端口" class="headerlink" title="1.开放80，22，8080 端口"></a>1.开放80，22，8080 端口</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/iptables -I INPUT -p tcp *--dport 80 -j ACCEPT*</span><br><span class="line">/sbin/iptables -I INPUT -p tcp *--dport 22 -j ACCEPT*</span><br><span class="line">/sbin/iptables -I INPUT -p tcp *--dport 8080 -j ACCEPT*</span><br></pre></td></tr></table></figure>

<h5 id="2-保存"><a href="#2-保存" class="headerlink" title="2.保存"></a>2.保存</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/rc.d/init.d/iptables save</span><br></pre></td></tr></table></figure>

<h5 id="3-查看打开的端口"><a href="#3-查看打开的端口" class="headerlink" title="3.查看打开的端口"></a>3.查看打开的端口</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/iptables status</span><br></pre></td></tr></table></figure>

<h5 id="4-关闭防火墙"><a href="#4-关闭防火墙" class="headerlink" title="4.关闭防火墙"></a>4.关闭防火墙</h5><p>1） 永久性生效，重启后不会复原</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开启： chkconfig iptables on</span><br><span class="line">关闭： chkconfig iptables off</span><br></pre></td></tr></table></figure>

<p>2） 即时生效，重启后复原</p>
<p>开启： service iptables start</p>
<p>关闭： service iptables stop</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>firewall</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7/8 中设置时间、时区、时间同步</title>
    <url>/2019/11/20/CentOS-7-8-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4%E3%80%81%E6%97%B6%E5%8C%BA%E3%80%81%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<blockquote>
<p>在安装设置服务器时，经常需要同步或设置Linux系统的时间，本文将通过终端命令<code>timedatectl</code>设置<code>date</code>、<code>time</code>、<code>timezone</code>和<code>synchronize time</code>，以此来管理服务器时间。<br>在CentOS 8 中，使用<code>chrony</code>来实现时间同步，如果最小化安装系统，需要使用下面命令安装<code>chrony</code>服务。<br><code>yum install -y chrony</code></p>
</blockquote>
<a id="more"></a>

<h3 id="查找和设置Linux本地时区"><a href="#查找和设置Linux本地时区" class="headerlink" title="查找和设置Linux本地时区"></a>查找和设置Linux本地时区</h3><h5 id="1、要显示系统的当前时间和日期，使用命令行中的timedatectl命令，如下："><a href="#1、要显示系统的当前时间和日期，使用命令行中的timedatectl命令，如下：" class="headerlink" title="1、要显示系统的当前时间和日期，使用命令行中的timedatectl命令，如下："></a>1、要显示系统的当前时间和日期，使用命令行中的<code>timedatectl</code>命令，如下：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl</span><br><span class="line">OR</span><br><span class="line"># timedatectl status</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl</span><br><span class="line">               Local time: 三 2019-11-20 15:42:13 CST</span><br><span class="line">           Universal time: 三 2019-11-20 07:42:13 UTC</span><br><span class="line">                 RTC time: 三 2019-11-20 15:42:13</span><br><span class="line">                Time zone: Asia&#x2F;Shanghai (CST, +0800)</span><br><span class="line">System clock synchronized: yes</span><br><span class="line">              NTP service: active</span><br><span class="line">          RTC in local TZ: no</span><br></pre></td></tr></table></figure>

<p>　　在上面的示例中，RTC time是指硬件时钟的时间、Time zone为时区。</p>
<h5 id="2、要查看所有可用的时区，运行以下命令："><a href="#2、要查看所有可用的时区，运行以下命令：" class="headerlink" title="2、要查看所有可用的时区，运行以下命令："></a>2、要查看所有可用的时区，运行以下命令：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl list-timezones</span><br></pre></td></tr></table></figure>

<h5 id="3、要根据地理位置找到本地的时区，运行以下命令："><a href="#3、要根据地理位置找到本地的时区，运行以下命令：" class="headerlink" title="3、要根据地理位置找到本地的时区，运行以下命令："></a>3、要根据地理位置找到本地的时区，运行以下命令：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl list-timezones | egrep -o ‘’Asia&#x2F;B.*”</span><br><span class="line"># timedatectl list-timezones | egrep -o “America&#x2F;N.*”</span><br></pre></td></tr></table></figure>

<h5 id="4、要设置本地时区，使用set-timezone选项："><a href="#4、要设置本地时区，使用set-timezone选项：" class="headerlink" title="4、要设置本地时区，使用set-timezone选项："></a>4、要设置本地时区，使用set-timezone选项：</h5><p>​      中国上海的时区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl set-timezone &quot;Asia&#x2F;Shanghai&quot;</span><br></pre></td></tr></table></figure>

<p>​      也可以使用协调世界时，即UTC (Universal Time Coordinated) </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl set-timezone UTC</span><br></pre></td></tr></table></figure>



<h3 id="设置Linux时间和日期"><a href="#设置Linux时间和日期" class="headerlink" title="设置Linux时间和日期"></a>设置Linux时间和日期</h3><p>​      可以使用timedatectl命令，设置系统上的日期和时间，如下所示：</p>
<h5 id="5、同时设置日期和时间："><a href="#5、同时设置日期和时间：" class="headerlink" title="5、同时设置日期和时间："></a>5、同时设置日期和时间：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl set-time &#39;16:10:40 2015-11-20&#39;</span><br></pre></td></tr></table></figure>
<h5 id="6、只设置时间可以使用set-time选项，按HH-MM-SS（时，分，秒）的时间格式。"><a href="#6、只设置时间可以使用set-time选项，按HH-MM-SS（时，分，秒）的时间格式。" class="headerlink" title="6、只设置时间可以使用set-time选项，按HH:MM:SS（时，分，秒）的时间格式。"></a>6、只设置时间可以使用set-time选项，按HH:MM:SS（时，分，秒）的时间格式。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl set-time 15:58:30</span><br></pre></td></tr></table></figure>

<h5 id="7、只设置日期可以使用set-time选项，按YY-MM-DD（年，月，日）的日期格式。"><a href="#7、只设置日期可以使用set-time选项，按YY-MM-DD（年，月，日）的日期格式。" class="headerlink" title="7、只设置日期可以使用set-time选项，按YY:MM:DD（年，月，日）的日期格式。"></a>7、只设置日期可以使用set-time选项，按YY:MM:DD（年，月，日）的日期格式。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl set-time 20151120</span><br></pre></td></tr></table></figure>



<h3 id="设置Linux硬件时钟"><a href="#设置Linux硬件时钟" class="headerlink" title="设置Linux硬件时钟"></a>设置Linux硬件时钟</h3><h5 id="8、要设置硬件时钟以协调世界时，UTC，可以使用-set-local-rtc-boolean-value选项，如下所示："><a href="#8、要设置硬件时钟以协调世界时，UTC，可以使用-set-local-rtc-boolean-value选项，如下所示：" class="headerlink" title="8、要设置硬件时钟以协调世界时，UTC，可以使用 set-local-rtc boolean-value选项，如下所示："></a>8、要设置硬件时钟以协调世界时，UTC，可以使用 set-local-rtc boolean-value选项，如下所示：</h5><p>​      首先确定你的硬件时钟是否设置为本地时区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl | grep local</span><br><span class="line">  RTC in local TZ: no</span><br></pre></td></tr></table></figure>

<p>​      将你的硬件时钟设置为本地时区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl set-local-rtc 1</span><br></pre></td></tr></table></figure>

<p>​      将你的硬件时钟设置为协调世界时（UTC）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl set-local-rtc 0</span><br></pre></td></tr></table></figure>



<h3 id="设置同步远程NTP服务器时间"><a href="#设置同步远程NTP服务器时间" class="headerlink" title="设置同步远程NTP服务器时间"></a>设置同步远程NTP服务器时间</h3><p>​      NTP即Network Time Protocol（网络时间协议），是一个互联网协议，用于同步计算机之间的系统时钟。<code>timedatectl</code>程序可以使用NTP服务器自动同步Linux系统时钟。</p>
<p>​      注意，你必须在系统上安装NTP以实现与NTP服务器的自动时间同步，并确保<code>chrony</code>服务正常运行。</p>
<p>​      要开启NTP时间同步，在终端键入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl set-ntp true</span><br></pre></td></tr></table></figure>
<p>​      要禁用NTP时间同步，在终端键入以下命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl set-ntp false</span><br></pre></td></tr></table></figure>

<p>​      同步的NTP服务器信息存储在 /etc/chrony.conf 文件中，可以根据自己的需要自行添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat &#x2F;etc&#x2F;chrony.conf </span><br><span class="line">server 0.centos.pool.ntp.org iburst</span><br><span class="line">server 1.centos.pool.ntp.org iburst</span><br><span class="line">server 2.centos.pool.ntp.org iburst</span><br><span class="line">server 3.centos.pool.ntp.org iburst</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>timezone</tag>
        <tag>ntp</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7/8两种防火墙命令使用示例</title>
    <url>/2019/11/07/CentOS7-8%E4%B8%A4%E7%A7%8D%E9%98%B2%E7%81%AB%E5%A2%99%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>转发修改自：<a href="https://www.toutiao.com/i6755704307607142920/" target="_blank" rel="noopener"> https://www.toutiao.com/i6755704307607142920/ </a></p>
</blockquote>
<h4 id="一、CentOS7-8关闭防火墙的命令"><a href="#一、CentOS7-8关闭防火墙的命令" class="headerlink" title="一、CentOS7/8关闭防火墙的命令"></a>一、CentOS7/8关闭防火墙的命令</h4><h5 id="1-查看防火状态"><a href="#1-查看防火状态" class="headerlink" title="1:查看防火状态"></a>1:查看防火状态</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br><span class="line">service iptables status</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h5 id="2-暂时关闭防火墙"><a href="#2-暂时关闭防火墙" class="headerlink" title="2:暂时关闭防火墙"></a>2:暂时关闭防火墙</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure>

<h5 id="3-永久关闭防火墙"><a href="#3-永久关闭防火墙" class="headerlink" title="3:永久关闭防火墙"></a>3:永久关闭防火墙</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure>

<h5 id="4-重启防火墙"><a href="#4-重启防火墙" class="headerlink" title="4:重启防火墙"></a>4:重启防火墙</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable firewalld</span><br><span class="line">service iptables restart</span><br></pre></td></tr></table></figure>

<h5 id="5-永久关闭后重启"><a href="#5-永久关闭后重启" class="headerlink" title="5:永久关闭后重启"></a>5:永久关闭后重启</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig iptables on</span><br></pre></td></tr></table></figure>

<h3 id="二、firewalld"><a href="#二、firewalld" class="headerlink" title="二、firewalld"></a>二、firewalld</h3><blockquote>
<p>Centos7默认安装了firewalld，如果没有安装的话，可以使用以下命令进行安装。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install firewalld firewalld-config</span><br></pre></td></tr></table></figure>

<h4 id="1-启动防火墙"><a href="#1-启动防火墙" class="headerlink" title="1.启动防火墙"></a>1.启动防火墙</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure>

<h4 id="2-禁用防火墙"><a href="#2-禁用防火墙" class="headerlink" title="2.禁用防火墙"></a>2.禁用防火墙</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<h4 id="3-设置开机启动"><a href="#3-设置开机启动" class="headerlink" title="3.设置开机启动"></a>3.设置开机启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure>

<h4 id="4-停止并禁用开机启动"><a href="#4-停止并禁用开机启动" class="headerlink" title="4.停止并禁用开机启动"></a>4.停止并禁用开机启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sytemctl disable firewalld</span><br></pre></td></tr></table></figure>

<h4 id="5-重启防火墙"><a href="#5-重启防火墙" class="headerlink" title="5.重启防火墙"></a>5.重启防火墙</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h4 id="6-查看状态"><a href="#6-查看状态" class="headerlink" title="6.查看状态"></a>6.查看状态</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br><span class="line">或</span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure>

<h4 id="7-查看版本"><a href="#7-查看版本" class="headerlink" title="7.查看版本"></a>7.查看版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --version</span><br></pre></td></tr></table></figure>

<h4 id="8-查看帮助"><a href="#8-查看帮助" class="headerlink" title="8.查看帮助"></a>8.查看帮助</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --help</span><br></pre></td></tr></table></figure>

<h4 id="9-查看区域信息"><a href="#9-查看区域信息" class="headerlink" title="9.查看区域信息"></a>9.查看区域信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure>

<h4 id="10-查看指定接口所属区域信息"><a href="#10-查看指定接口所属区域信息" class="headerlink" title="10.查看指定接口所属区域信息"></a>10.查看指定接口所属区域信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-zone-of-interface&#x3D;eth0</span><br></pre></td></tr></table></figure>

<h4 id="11-拒绝所有包"><a href="#11-拒绝所有包" class="headerlink" title="11.拒绝所有包"></a>11.拒绝所有包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --panic-on</span><br></pre></td></tr></table></figure>

<h4 id="12-取消拒绝状态"><a href="#12-取消拒绝状态" class="headerlink" title="12.取消拒绝状态"></a>12.取消拒绝状态</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --panic-off</span><br></pre></td></tr></table></figure>

<h4 id="13-查看是否拒绝"><a href="#13-查看是否拒绝" class="headerlink" title="13.查看是否拒绝"></a>13.查看是否拒绝</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-panic</span><br></pre></td></tr></table></figure>

<h4 id="14-将接口添加到区域-默认接口都在public"><a href="#14-将接口添加到区域-默认接口都在public" class="headerlink" title="14.将接口添加到区域(默认接口都在public)"></a>14.将接口添加到区域(默认接口都在public)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-interface&#x3D;eth0</span><br><span class="line">(永久生效再加上 --permanent 然后reload防火墙)</span><br></pre></td></tr></table></figure>

<h4 id="15-设置默认接口区域"><a href="#15-设置默认接口区域" class="headerlink" title="15.设置默认接口区域"></a>15.设置默认接口区域</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --set-default-zone&#x3D;public</span><br><span class="line">(立即生效，无需重启)</span><br></pre></td></tr></table></figure>

<h4 id="16-更新防火墙规则"><a href="#16-更新防火墙规则" class="headerlink" title="16.更新防火墙规则"></a>16.更新防火墙规则</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br><span class="line">或</span><br><span class="line">firewall-cmd --complete-reload</span><br><span class="line">(两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务)</span><br></pre></td></tr></table></figure>

<h4 id="17-查看指定区域所有打开的端口"><a href="#17-查看指定区域所有打开的端口" class="headerlink" title="17.查看指定区域所有打开的端口"></a>17.查看指定区域所有打开的端口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --list-ports</span><br></pre></td></tr></table></figure>

<h4 id="18-在指定区域打开端口（记得重启防火墙）"><a href="#18-在指定区域打开端口（记得重启防火墙）" class="headerlink" title="18.在指定区域打开端口（记得重启防火墙）"></a>18.在指定区域打开端口（记得重启防火墙）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp</span><br><span class="line">(永久生效再加上 --permanent)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7/8修改主机名的几种方法</title>
    <url>/2019/11/07/CentOS7-8%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在CentOS7/8中，有三种定义的主机名:</p>
<blockquote>
<ul>
<li>静态的（Static hostname）<br>“静态”主机名也称为内核主机名，是系统在启动时从/etc/hostname自动初始化的主机名。</li>
<li>瞬态的（Tansient hostname）<br>“瞬态”主机名是在系统运行时临时分配的主机名，例如，通过DHCP或mDNS服务器分配。</li>
<li>灵活的（Pretty hostname）<br>“灵活”主机名也有人叫做“别名”主机名。<br>“灵活”主机名则允许使用自由形式（包括特殊/空白字符）的主机名，以展示给终端用户（如aibox@user01）。</li>
<li>“静态”主机名和“瞬态”主机名都遵从作为互联网域名同样的字符限制规则。</li>
</ul>
</blockquote>
<a id="more"></a>

<p>在CentOS 7/8 中，有个叫hostnamectl的命令行工具，它允许你查看或修改与主机名相关的配置。</p>
<h4 id="查看主机名"><a href="#查看主机名" class="headerlink" title="查看主机名:"></a>查看主机名:</h4><h5 id="查看当前主机名，显示全部三种主机名"><a href="#查看当前主机名，显示全部三种主机名" class="headerlink" title="查看当前主机名，显示全部三种主机名"></a>查看当前主机名，显示全部三种主机名</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hostnamectl</span><br><span class="line">or</span><br><span class="line">$ hostnamectl status</span><br><span class="line">Static hostname: aibox</span><br><span class="line">      Icon name: computer-desktop</span><br><span class="line">      Chassis: desktop</span><br><span class="line">      Machine ID: 6394c3b5598044e6bd2da1862eafa27d</span><br><span class="line">      Boot ID: cb326252e23d470a820b681f9b129bcd</span><br><span class="line">Operating System: CentOS Linux 8 (Core)</span><br><span class="line">      CPE OS Name: cpe:&#x2F;o:centos:centos:8</span><br><span class="line">      Kernel: Linux 4.18.0-80.11.2.el8_0.x86_64</span><br><span class="line">      Architecture: x86-64</span><br></pre></td></tr></table></figure>

<h5 id="只查看静态、瞬态或灵活主机名，分别使用–static，–transient或–pretty选项"><a href="#只查看静态、瞬态或灵活主机名，分别使用–static，–transient或–pretty选项" class="headerlink" title="只查看静态、瞬态或灵活主机名，分别使用–static，–transient或–pretty选项"></a>只查看静态、瞬态或灵活主机名，分别使用–static，–transient或–pretty选项</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hostnamectl --static</span><br><span class="line">aibox</span><br><span class="line">$ hostnamectl --transient</span><br><span class="line">aibox</span><br><span class="line">$ hostnamectl --pretty</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者使用hostname查看到的是瞬态的（Tansient hostname）</span><br><span class="line">$ hostname</span><br><span class="line">aibox</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者查看主机名配置文件，查看到的是静态的（Static hostname）</span><br><span class="line">#cat &#x2F;etc&#x2F;hostname</span><br><span class="line">aibox</span><br><span class="line">查看当前Linux操作系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）:</span><br><span class="line"></span><br><span class="line">uname -a			&#x2F;&#x2F;查看到的是瞬态的（Tansient hostname）</span><br><span class="line">cat &#x2F;etc&#x2F;redhat-release		&#x2F;&#x2F;查看操作系统环境</span><br></pre></td></tr></table></figure>

<h4 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名:"></a>修改主机名:</h4><h5 id="方法1：临时有效"><a href="#方法1：临时有效" class="headerlink" title="方法1：临时有效"></a>方法1：临时有效</h5><p>只能临时修改的主机名，当重启机器后，主机名称会变回来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostname 主机名 </span><br><span class="line">hostname aibox</span><br></pre></td></tr></table></figure>

<h5 id="方法2：永久生效（不需重启–建议使用）"><a href="#方法2：永久生效（不需重启–建议使用）" class="headerlink" title="方法2：永久生效（不需重启–建议使用）"></a>方法2：永久生效（不需重启–建议使用）</h5><p>永久性的修改主机名称，重启后能保持修改后的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname aibox</span><br></pre></td></tr></table></figure>

<p>删除主机名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname &quot;&quot;</span><br><span class="line">hostnamectl set-hostname &quot;&quot; --static</span><br><span class="line">hostnamectl set-hostname &quot;&quot; --pretty</span><br></pre></td></tr></table></figure>

<p>修改所有三个主机名：静态、瞬态和灵活主机名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hostnamectl set-hostname aibox</span><br><span class="line">$ hostnamectl set-hostname aibox --static</span><br></pre></td></tr></table></figure>

<p>修改灵活主机名和瞬态主机名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hostnamectl set-hostname www.aibox.one --pretty</span><br><span class="line">$ hostnamectl set-hostname aibox --transient</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  ​        就像上面示例的那样，在修改静态/瞬态主机名时，任何特殊字符或空白字符会被移除，而提供的参数中的任何大写字母会自动转化为小写。<br>  ​       一旦修改了静态主机名，/etc/hostname 将被自动更新。然而，/etc/hosts 不会更新以保存所做的修改，所以你每次在修改主机名后一定要手动更新/etc/hosts，之后再重启CentOS。否则系统再启动时会很慢。</p>
</blockquote>
<p>手动更新/etc/hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;hosts </span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">127.0.0.1   aibox</span><br></pre></td></tr></table></figure>

<p>修改后会立即生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ping aibox</span><br><span class="line">PING aibox (127.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from localhost (127.0.0.1): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.045 ms</span><br><span class="line">64 bytes from localhost (127.0.0.1): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.024 ms</span><br></pre></td></tr></table></figure>



<h5 id="方法3：永久生效（需要重启）"><a href="#方法3：永久生效（需要重启）" class="headerlink" title="方法3：永久生效（需要重启）"></a>方法3：永久生效（需要重启）</h5><p>修改配置文件/etc/hostname来实现主机名的修改。把该文件中的aibox替换成自己想要的主机名重启即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;hostname </span><br><span class="line">aibox</span><br></pre></td></tr></table></figure>

<h5 id="方法4：永久生效"><a href="#方法4：永久生效" class="headerlink" title="方法4：永久生效"></a>方法4：永久生效</h5><p>通过nmcli修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmcli general hostname aibox</span><br></pre></td></tr></table></figure>

<p>还可以通过<code>nmtui</code>进入图形界面来修改主机名。<br>将光标通过键盘的上下键移动到“设定系统主机名”菜单处，按下回车键。<br>此时，屏幕出现“设定主机名”选项卡，输入需要设定的主机名，通过键盘方向键将光标移动到“确定”处，回车键确定即可完成主机名的修改。</p>
<blockquote>
<p>版权声明：本文修改自 <a href="https://blog.csdn.net/xuheng8600/article/details/79983927" target="_blank" rel="noopener">https://blog.csdn.net/xuheng8600/article/details/79983927</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS实用技巧备忘</title>
    <url>/2019/10/30/CentOS%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h4 id="用命令反查安装包"><a href="#用命令反查安装包" class="headerlink" title="用命令反查安装包"></a>用命令反查安装包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum whatprovides command</span><br></pre></td></tr></table></figure>
<h4 id="关闭SELinux"><a href="#关闭SELinux" class="headerlink" title="关闭SELinux"></a>关闭SELinux</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 临时关闭</span><br><span class="line">setenforce 0 </span><br><span class="line"># 永久关闭</span><br><span class="line">sed -i &#39;s&#x2F;SELINUX&#x3D;enforcing&#x2F;SElINUX&#x3D;disabled&#x2F;g&#39; &#x2F;etc&#x2F;selinux&#x2F;config</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="开启bash命令补全"><a href="#开启bash命令补全" class="headerlink" title="开启bash命令补全"></a>开启bash命令补全</h4><blockquote>
<p>如nmcli、yum等命令，参数比较多，开启后按<code>tab</code>即可补全</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install bash-completion -y</span><br></pre></td></tr></table></figure>
<h4 id="创建自解压包"><a href="#创建自解压包" class="headerlink" title="创建自解压包"></a>创建自解压包</h4><blockquote>
<p>makeself.sh是一个Shell脚本，可从目录生成自解压文件。生成的文件显示为Shell脚本（一般后缀为.run），可以直接启动。归档文件将自身解压缩到一个临时目录，并执行一个可选的任意命令（例如，安装脚本）。这与Windows中使用WinZip自解压器生成的存档非常相似。<br>下载地址：<a href="https://github.com/megastep/makeself" target="_blank" rel="noopener">https://github.com/megastep/makeself</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;makeself.sh [args] archive_dir file_name label startup_script [script_args]</span><br><span class="line">.&#x2F;makeself.sh --gzip updata updata.bin CentOS_7_Updata .&#x2F;install.sh</span><br><span class="line"># 还有很多可选参数请查看作者github地址</span><br></pre></td></tr></table></figure>
<h4 id="使用downloadonly下载安装包及其依赖"><a href="#使用downloadonly下载安装包及其依赖" class="headerlink" title="使用downloadonly下载安装包及其依赖"></a>使用downloadonly下载安装包及其依赖</h4><blockquote>
<p>主要解决某些内网的主机安装软件的问题。可以先在有互联网的主机上下载包，再到内网中安装</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在有网络的主机上下载一个安装包</span><br><span class="line">yum install -y --downloadonly --downloaddir&#x3D;.&#x2F; lrzsz</span><br><span class="line"># 在没有网络（内网）的主机上安装包</span><br><span class="line">rpm -ivh lrzsz-0.12.20-43.el8.x86_64.rpm -y</span><br></pre></td></tr></table></figure>

<h4 id="关闭并禁用系统服务"><a href="#关闭并禁用系统服务" class="headerlink" title="关闭并禁用系统服务"></a>关闭并禁用系统服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop nginx.service &amp;&amp; systemctl disable nginx.service</span><br><span class="line">systemctl stop firewalld.service &amp;&amp; systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h4 id="tar压缩包简单加密"><a href="#tar压缩包简单加密" class="headerlink" title="tar压缩包简单加密"></a>tar压缩包简单加密</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#加密压缩</span><br><span class="line">tar -czvf - file | openssl des3 -salt -k password -out &#x2F;path&#x2F;to&#x2F;file.tar.gz</span><br><span class="line">#解密解压</span><br><span class="line">openssl des3 -d -k password -salt -in &#x2F;path&#x2F;to&#x2F;file.tar.gz | tar xzf -</span><br></pre></td></tr></table></figure>

<h4 id="CentOS-7-替换阿里源"><a href="#CentOS-7-替换阿里源" class="headerlink" title="CentOS 7 替换阿里源"></a>CentOS 7 替换阿里源</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</span><br><span class="line">wget http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure>

<h4 id="CentOS-安装epel扩展源"><a href="#CentOS-安装epel扩展源" class="headerlink" title="CentOS 安装epel扩展源"></a>CentOS 安装epel扩展源</h4><blockquote>
<p>EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，用以创建、维护以及管理针对企业版 Linux 的一个高质量附加软件包集，面向的对象包括但不限于 红帽企业版 Linux (RHEL)、 CentOS、Scientific Linux (SL)、Oracle Linux (OL) 。</p>
</blockquote>
<blockquote>
<p>EPEL 的软件包通常不会与企业版 Linux 官方源中的软件包发生冲突，或者互相替换文件。EPEL 项目与 Fedora 基本一致，包含完整的构建系统、升级管理器、镜像管理器等等。</p>
</blockquote>
<blockquote>
<p>官网：<a href="https://fedoraproject.org/wiki/EPEL" target="_blank" rel="noopener"> https://fedoraproject.org/wiki/EPEL </a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h4 id="查找进程-PPID（查找并杀死僵尸进程）"><a href="#查找进程-PPID（查找并杀死僵尸进程）" class="headerlink" title="查找进程 PPID（查找并杀死僵尸进程）"></a>查找进程 PPID（查找并杀死僵尸进程）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -p 29327 -o ppid </span><br><span class="line">ps -p 29327 -o ppid&#x3D;</span><br><span class="line"></span><br><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e &#39;^[Zz]&#39; | awk &#39;&#123; print $2 &#125;&#39; | xargs kill 9</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装Python3.8.0</title>
    <url>/2019/10/26/CentOS7%E5%AE%89%E8%A3%85Python3-8/</url>
    <content><![CDATA[<blockquote>
<p>在CentOS7上安装Python3.8.0版（编译安装方式）</p>
</blockquote>
<a id="more"></a>

<h4 id="安装支持库"><a href="#安装支持库" class="headerlink" title="安装支持库"></a>安装支持库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel -y</span><br><span class="line">yum install sqlite-devel readline-devel tk-devel libffi-devel -y</span><br><span class="line">yum install gcc make -y</span><br></pre></td></tr></table></figure>

<h4 id="安装Python3"><a href="#安装Python3" class="headerlink" title="安装Python3"></a>安装Python3</h4><p><strong>下载安装包</strong><br>以3.8.0为例，需要下载其它版本请访问：<a href="https://www.python.org/ftp/python" target="_blank" rel="noopener">https://www.python.org/ftp/python</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.8.0&#x2F;Python-3.8.0.tgz</span><br></pre></td></tr></table></figure>
<p><strong>解压安装包</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xzvf Python-3.8.0.tgz</span><br><span class="line">cd Python-3.8.0</span><br></pre></td></tr></table></figure>
<p><strong>编译安装</strong><br>指定安装目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3 --with-ssl</span><br></pre></td></tr></table></figure>
<p><em>–enable-shared 启用动态连接库（可选），方便其他依赖库的正常安装。如：mysqlclient pyinstall<br>如果选择该参数，您可能需要设置动态库的环境变量,否则可能出现打不到库文件“libpython3.8m.so.1.0”的情况</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --enable-shared</span><br><span class="line"># 最好将下面的环境变量加到开机自启动脚本中</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;lib:&#x2F;usr&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;python3&#x2F;lib</span><br><span class="line">export $PATH:&#x2F;usr&#x2F;local&#x2F;python3&#x2F;lib:&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin</span><br><span class="line"></span><br><span class="line">ldconfig &#x2F;usr&#x2F;local&#x2F;python3&#x2F;lib</span><br><span class="line">或者</span><br><span class="line">echo &quot;&#x2F;usr&#x2F;local&#x2F;python3&#x2F;lib&quot; &gt;&gt; &#x2F;etc&#x2F;ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
<p><em>–enable-optimizations 优化选项（可选）执行完上一步后会提示执行以下的代码对Python解释器进行优化，据说性能有10%左右的提升，执行该代码后，会编译安装到 /usr/local/bin/python3.8 下，且不用添加软连接或环境变量。但安装目录也许并不是你想要的</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --enable-optimizations</span><br></pre></td></tr></table></figure>
<p>编译并安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><strong>创建软链接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3</span><br></pre></td></tr></table></figure>

<h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器数据卷挂载小结</title>
    <url>/2019/10/26/Docker-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8C%82%E8%BD%BD%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>为了更直观了解数据卷挂载的操作，做个实验一一验证数据卷挂载的各种情况。</p>
</blockquote>
<a id="more"></a>

<p><strong>情况一、本地不存在文件挂载到容器存在文件</strong></p>
<p>首先是当本地不存在该文件，而容器内存在该文件的情况，尝试把不存在的文件挂载到存在该文件的容器中。以一个 Alpine 镜像为例，这里把一个修改后的 Alpine 镜像打了新标签，叫做 volume_test：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 本地目录不存在 test 文件。</span><br><span class="line">$ docker run --name&#x3D;test -v ~&#x2F;test.txt:&#x2F;etc&#x2F;hosts -d volume_test</span><br><span class="line">0cba2e50229df7508c616bd456c4ab131f2fe1a88385c34f8a5876fbc577b176</span><br><span class="line">docker: Error response from daemon: oci runtime error: rootfs_linux.go:53: mounting</span><br><span class="line">&quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;devicemapper&#x2F;mnt&#x2F;6b83c07ebedcb828f34cac69eac5a85ce3a5f59e1e8688c8dae40198671d0ecb&#x2F;rootfs&#x2F;etc&#x2F;hosts&quot; to rootfs</span><br><span class="line">&quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;devicemapper&#x2F;mnt&#x2F;6b83c07ebedcb828f34cac69eac5a85ce3a5f59e1e8688c8dae40198671d0ecb&#x2F;rootfs&quot; caused &quot;not a directory&quot;.</span><br><span class="line"># 启动容器失败。</span><br></pre></td></tr></table></figure>

<p><strong>情况二、本地不存在文件夹挂载到容器存在文件夹</strong></p>
<p>然后是把本地不存在的文件夹挂载到容器内存在的文件夹，在 volume_test 镜像中存在一个 /srv 的文件夹，文件夹里面有一个 index.php 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 本地目录不存在 srv文件夹。</span><br><span class="line">$ docker run --name&#x3D;test -v ~&#x2F;srv:&#x2F;srv -d volume_test </span><br><span class="line">c71cf1cfa4932e3e398a7d6c4e2ae94f915b832f5506e374aedb19af4cb1ac62</span><br><span class="line"># 启动正常，但是进入容器发现目录被清空。</span><br><span class="line">$ docker exec -it test sh</span><br><span class="line">&#x2F;srv # ls</span><br><span class="line">&#x2F;srv #</span><br></pre></td></tr></table></figure>

<p><strong>情况三、宿主机存在文件挂载到容器不存在文件</strong></p>
<p>我们继续，假设宿主机存在文件，容器内不存在该文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 本地目录存在 test.txt文件</span><br><span class="line">$ docker run --name&#x3D;test -v ~&#x2F;test.txt:&#x2F;srv&#x2F;test.txt-d volume_test </span><br><span class="line">2d6853c10643a735ae3d7f3aaac8c6344f9c75170e531f613d08db7cdf484e54</span><br><span class="line"># 容器内存在 &#x2F;srv 文件夹，里面原本有一个 index.php 。</span><br><span class="line">$ docker exec -it test sh</span><br><span class="line">&#x2F;srv # ls</span><br><span class="line">index.php  test.txt</span><br><span class="line">&#x2F;srv # </span><br><span class="line"># 可以看到文件挂载成功。</span><br></pre></td></tr></table></figure>

<p><strong>情况四、宿主机存在文件夹挂载到容器不存在文件夹</strong></p>
<p>接下来是宿主机存在文件夹，容器不存在该文件夹，宿主机的 test 文件夹里面存在一个 hello 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name&#x3D;test -v ~&#x2F;test:&#x2F;srv&#x2F;test -d volume_test </span><br><span class="line">c935ffa0d9fc5e5ac8f213a51a878e71056472b0597d2e385a29e5c748012958</span><br><span class="line"># 进入容器，查看是否存在 test 文件夹，以及文件夹里面是否有 hello 文件。</span><br><span class="line">$ docker exec -it test sh</span><br><span class="line">&#x2F;srv # ls</span><br><span class="line">index.php  test</span><br><span class="line">&#x2F;srv # cd test&#x2F;</span><br><span class="line">&#x2F;srv&#x2F;test # ls</span><br><span class="line">hello</span><br><span class="line">&#x2F;srv&#x2F;test #</span><br></pre></td></tr></table></figure>

<p>上面两个例子说明了，容器内部如果不存在文件，宿主机直接挂载。</p>
<p><strong>情况五、宿主机文件夹挂载到容器文件</strong></p>
<p>接下来假设宿主机存在 test 文件夹，而容器内部存在的是名为 test 文件，这样挂载会怎样呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name&#x3D;test -v ~&#x2F;test:&#x2F;srv&#x2F;test-d volume_test </span><br><span class="line">385bc78e5333460da11f04535da27a3fd226df218f95c970ff2dd5609b17f816</span><br><span class="line">docker: Error response from daemon: oci runtime error: rootfs_linux.go:53: mounting </span><br><span class="line">&quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;devicemapper&#x2F;mnt&#x2F;fd5c42e844c3550d1a372ed939ed57f90dcacbd375dfed1bedfbb71ef6f3f185&#x2F;rootfs&#x2F;etc&#x2F;hosts&quot; to rootfs </span><br><span class="line">&quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;devicemapper&#x2F;mnt&#x2F;fd5c42e844c3550d1a372ed939ed57f90dcacbd375dfed1bedfbb71ef6f3f185&#x2F;rootfs&quot; caused &quot;not a directory&quot;.</span><br></pre></td></tr></table></figure>

<p>上面的情况不出意外是启动错误。</p>
<p><strong>情况六、同名文件夹挂载</strong></p>
<p>那么假设宿主机是文件夹，容器也是文件夹，两个文件夹里面内容不一样，宿主机内部有一个 hello 文件，容器的文件夹里面有一个 index.php ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name&#x3D;test -v ~&#x2F;srv:&#x2F;srv -d volume_test </span><br><span class="line">3aec30122bd7010c694e0ff8b77f7b7b6bb6f850c258786db125313060fad43b</span><br><span class="line">$ docker exec-it test sh</span><br><span class="line">&#x2F;srv # ls</span><br><span class="line">hello</span><br><span class="line">&#x2F;srv # </span><br><span class="line"># 可以看到，宿主机文件夹会覆盖容器内部的文件夹。</span><br></pre></td></tr></table></figure>

<p><strong>情况七、同名文件挂载</strong></p>
<p>假设宿主机有一个 test.txt 文件，里面写着 Hello World，而容器里面也存在一个 test.txt 文件，里面写着 Hi World，现在挂载文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name&#x3D;test -v ~&#x2F;test.txt:&#x2F;srv&#x2F;test.txt -d volume_test </span><br><span class="line">047cbfe45b5bc868c864fe94f7a22643d52b644947f40260097dbb579de56c5c</span><br><span class="line">$ docker exec -it test sh</span><br><span class="line">&#x2F;srv # cat &#x2F;test</span><br><span class="line">Hello World</span><br><span class="line">&#x2F;srv # </span><br><span class="line"># 宿主机会覆盖容器的文件。</span><br></pre></td></tr></table></figure>

<p><strong>情况八、宿主机文件挂载到容器文件夹</strong></p>
<p>最后一种情况，宿主机存在文件 test.txt，而容器内部存在一个 test 的文件夹，现在把 文件挂载到文件夹中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name&#x3D;test -v ~&#x2F;test.txt:&#x2F;test -d volume_test </span><br><span class="line">59b5fd74a1e9e17aa2a6a9be7900b16c7dd4b3c424a4fa72a7671fa1c51bdf69</span><br><span class="line">docker: Error response from daemon: oci runtime error: rootfs_linux.go:53: mounting </span><br><span class="line">&quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;devicemapper&#x2F;mnt&#x2F;b201054ed36a189b5abb599082d0b5bcbe31d07611a0985deefd79d1221447fd&#x2F;rootfs&#x2F;home&quot; to rootfs </span><br><span class="line">&quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;devicemapper&#x2F;mnt&#x2F;b201054ed36a189b5abb599082d0b5bcbe31d07611a0985deefd79d1221447fd&#x2F;rootfs&quot; caused &quot;not a directory&quot;.</span><br><span class="line"># 启动失败。</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>宿主机文件</strong></th>
<th align="left"><strong>容器内文件</strong></th>
<th align="left"><strong>启动参数(加粗为不存在)</strong></th>
<th align="left"><strong>容器启动情况</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">不存在</td>
<td align="left">文件</td>
<td align="left">-v <strong>~/test.txt</strong>:/etc/hosts</td>
<td align="left">启动错误</td>
</tr>
<tr>
<td align="left">不存在</td>
<td align="left">文件夹</td>
<td align="left">-v <strong>~/srv</strong>:/srv</td>
<td align="left">启动正常</td>
</tr>
<tr>
<td align="left">文件</td>
<td align="left">不存在</td>
<td align="left">-v ~/test.txt:<strong>/srv/test.txt</strong></td>
<td align="left">启动正常</td>
</tr>
<tr>
<td align="left">文件夹</td>
<td align="left">不存在</td>
<td align="left">~/test:<strong>/srv/test</strong></td>
<td align="left">启动正常</td>
</tr>
<tr>
<td align="left">文件夹</td>
<td align="left">文件</td>
<td align="left">~/test:/srv/test</td>
<td align="left">启动错误</td>
</tr>
<tr>
<td align="left">文件夹</td>
<td align="left">文件夹</td>
<td align="left">-v ~/srv:/srv</td>
<td align="left">启动正常</td>
</tr>
<tr>
<td align="left">文件</td>
<td align="left">文件</td>
<td align="left">-v ~/test.txt:/srv/test.txt</td>
<td align="left">启动正常</td>
</tr>
<tr>
<td align="left">文件</td>
<td align="left">文件夹</td>
<td align="left">-v ~/test.txt:/test</td>
<td align="left">启动错误</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile指令ADD和COPY介绍</title>
    <url>/2019/10/27/Dockerfile%E6%8C%87%E4%BB%A4ADD%E5%92%8CCOPY%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h4 id="一、ADD指令"><a href="#一、ADD指令" class="headerlink" title="一、ADD指令"></a>一、ADD指令</h4><p>ADD指令的功能是将主机构建环境（上下文）目录中的文件和目录、以及一个URL标记的文件 拷贝到镜像中。</p>
<a id="more"></a>

<p>其格式是： ADD  源路径  目标路径<br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#test</span><br><span class="line">FROM ubuntu</span><br><span class="line">MAINTAINER hello</span><br><span class="line">ADD test1.txt test1.txt</span><br><span class="line">ADD test1.txt test1.txt.bak</span><br><span class="line">ADD test1.txt &#x2F;mydir&#x2F;</span><br><span class="line">ADD data1  data1</span><br><span class="line">ADD data2  data2</span><br><span class="line">ADD zip.tar &#x2F;myzip</span><br></pre></td></tr></table></figure>
<p>有如下注意事项：<br>1、如果源路径是个文件，且目标路径是以 / 结尾， 则docker会把目标路径当作一个目录，会把源文件拷贝到该目录下。<br>如果目标路径不存在，则会自动创建目标路径。</p>
<p>2、如果源路径是个文件，且目标路径是不是以 / 结尾，则docker会把目标路径当作一个文件。<br>如果目标路径不存在，会以目标路径为名创建一个文件，内容同源文件；<br>如果目标文件是个存在的文件，会用源文件覆盖它，当然只是内容覆盖，文件名还是目标文件名。<br>如果目标文件实际是个存在的目录，则会源文件拷贝到该目录下。 注意，这种情况下，最好显示的以 / 结尾，以避免混淆。</p>
<p>3、如果源路径是个目录，且目标路径不存在，则docker会自动以目标路径创建一个目录，把源路径目录下的文件拷贝进来。<br>如果目标路径是个已经存在的目录，则docker会把源路径目录下的文件拷贝到该目录下。</p>
<p>4、如果源文件是个归档文件（压缩文件），则docker会自动帮解压。</p>
<h4 id="二、COPY指令"><a href="#二、COPY指令" class="headerlink" title="二、COPY指令"></a>二、COPY指令</h4><p>COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言北京UTC+8时间问题</title>
    <url>/2021/07/01/Go%E8%AF%AD%E8%A8%80%E5%8C%97%E4%BA%ACUTC-8%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Go语言-北京UTC-8-时间问题"><a href="#Go语言-北京UTC-8-时间问题" class="headerlink" title="Go语言 北京UTC+8 时间问题"></a>Go语言 北京UTC+8 时间问题</h2><p>go语言(golang)时间问题：</p>
<p>获取系统当前时间（2017-06-05 16:22:30.628247233 +0800 CST）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curNow :&#x3D; time.Now().Local()</span><br></pre></td></tr></table></figure>

<p>得出的结果有时会出现：2017-06-05 8:22:30.628247233 +0800 CST，与当前系统时间相差8小时</p>
<p>解决问题：</p>
<p>只要在 init中 或者 相关时间调用函数的代码使用之前加入如下代码：</p>
<p>方案一、</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timelocal &#x3D; time.FixedZone(&quot;CST&quot;, 3600*8)</span><br><span class="line">time.Local &#x3D; timelocal</span><br></pre></td></tr></table></figure>

  <a id="more"></a>

<p>方案二、</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timelocal &#x3D; time.LoadLocation(&quot;Asia&#x2F;Chongqing&quot;)</span><br><span class="line">time.Local &#x3D; timelocal</span><br></pre></td></tr></table></figure>

<p> 之后获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curNow :&#x3D; time.Now().Local()</span><br></pre></td></tr></table></figure>

<p>就正常了。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Gunicorn参数说明</title>
    <url>/2019/12/18/Gunicorn%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>gunicorn是目前使用最广泛的高性能的Python WSGI（WEB Server Gateway interface）服务器，移植自Ruby的Unicorn项目，使用pre-fork worker模式，具有简单、易用、轻量级、低资源消耗和高性能等特点。</p>
<a id="more"></a>

<h2 id="二、参数说明"><a href="#二、参数说明" class="headerlink" title="二、参数说明"></a>二、参数说明</h2><h3 id="2-1-启动参数说明"><a href="#2-1-启动参数说明" class="headerlink" title="2.1 启动参数说明"></a>2.1 启动参数说明</h3><table>
<thead>
<tr>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-c CONFIG, --config=CONFIG</code></td>
<td>指定配置文件</td>
</tr>
<tr>
<td><code>-b BIND, --bind=BIND</code></td>
<td>绑定运行的主机加端口</td>
</tr>
<tr>
<td><code>-w INT, --workers INT</code></td>
<td>用于处理工作进程的数量，整数，默认为1</td>
</tr>
<tr>
<td><code>-k STRTING, --worker-class STRTING</code></td>
<td>要使用的工作模式，默认为sync异步，类型：sync, eventlet, gevent, tornado, gthread, gaiohttp</td>
</tr>
<tr>
<td><code>--threads INT</code></td>
<td>处理请求的工作线程数，使用指定数量的线程运行每个worker。为正整数，默认为1</td>
</tr>
<tr>
<td><code>--worker-connections INT</code></td>
<td>最大客户端并发数量，默认1000</td>
</tr>
<tr>
<td><code>--backlog int</code></td>
<td>等待连接的最大数，默认2048</td>
</tr>
<tr>
<td><code>-p FILE, --pid FILE</code></td>
<td>设置pid文件的文件名，如果不设置将不会创建pid文件</td>
</tr>
<tr>
<td><code>--access-logfile FILE</code></td>
<td>日志文件路径</td>
</tr>
<tr>
<td><code>--access-logformat STRING</code></td>
<td>日志格式，<code>--access_log_format &#39;%(h)s %(l)s %(u)s %(t)s&#39;</code></td>
</tr>
<tr>
<td><code>--error-logfile FILE, --log-file FILE</code></td>
<td>错误日志文件路径</td>
</tr>
<tr>
<td><code>--log-level LEVEL</code></td>
<td>日志输出等级</td>
</tr>
<tr>
<td><code>--limit-request-line INT</code></td>
<td>限制HTTP请求行的允许大小，默认4094。取值范围0~8190，此参数可以防止任何DDOS攻击</td>
</tr>
<tr>
<td><code>--limit-request-fields INT</code></td>
<td>限制HTTP请求头字段的数量以防止DDOS攻击，与limit-request-field-size一起使用可以提高安全性。默认100，最大值32768</td>
</tr>
<tr>
<td><code>--limit-request-field-size INT</code></td>
<td>限制HTTP请求中请求头的大小，默认8190。值是一个整数或者0，当该值为0时，表示将对请求头大小不做限制</td>
</tr>
<tr>
<td><code>-t INT, --timeout INT</code></td>
<td>超过设置后工作将被杀掉并重新启动，默认30s，nginx默认60s</td>
</tr>
<tr>
<td><code>--reload</code></td>
<td>在代码改变时自动重启，默认False</td>
</tr>
<tr>
<td><code>--daemon</code></td>
<td>是否以守护进程启动，默认False</td>
</tr>
<tr>
<td><code>--chdir</code></td>
<td>在加载应用程序之前切换目录</td>
</tr>
<tr>
<td><code>--graceful-timeout INT</code></td>
<td>默认30，在超时(从接收到重启信号开始)之后仍然活着的工作将被强行杀死；一般默认</td>
</tr>
<tr>
<td><code>--keep-alive INT</code></td>
<td>在keep-alive连接上等待请求的秒数，默认情况下值为2。一般设定在1~5秒之间</td>
</tr>
<tr>
<td><code>--spew</code></td>
<td>打印服务器执行过的每一条语句，默认False。此选择为原子性的，即要么全部打印，要么全部不打印</td>
</tr>
<tr>
<td><code>--check-config</code></td>
<td>显示当前的配置，默认False，即显示</td>
</tr>
<tr>
<td><code>-e ENV, --env ENV</code></td>
<td>设置环境变量</td>
</tr>
</tbody></table>
<h3 id="2-2-配置文件示例"><a href="#2-2-配置文件示例" class="headerlink" title="2.2 配置文件示例"></a>2.2 配置文件示例</h3><h4 id="c-CONFIG-config-CONFIG"><a href="#c-CONFIG-config-CONFIG" class="headerlink" title="-c CONFIG, --config=CONFIG"></a><code>-c CONFIG, --config=CONFIG</code></h4><p>配置文件方式<br><em>vim gunicorn.conf</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 并行进程数</span><br><span class="line">workers &#x3D; 4</span><br><span class="line"> </span><br><span class="line"># 指定每个工作的线程数</span><br><span class="line">threads &#x3D; 2</span><br><span class="line"> </span><br><span class="line"># 监听端口8000</span><br><span class="line">bind &#x3D; &#39;127.0.0.1:8000&#39;</span><br><span class="line"> </span><br><span class="line"># 守护进程,将进程交给supervisor管理</span><br><span class="line">daemon &#x3D; &#39;false&#39;</span><br><span class="line"> </span><br><span class="line"># 工作模式协程</span><br><span class="line">worker_class &#x3D; &#39;gevent&#39;</span><br><span class="line"> </span><br><span class="line"># 最大并发量</span><br><span class="line">worker_connections &#x3D; 2000</span><br><span class="line"> </span><br><span class="line"># 进程文件</span><br><span class="line">pidfile &#x3D; &#39;&#x2F;var&#x2F;run&#x2F;gunicorn.pid&#39;</span><br><span class="line"> </span><br><span class="line"># 访问日志和错误日志</span><br><span class="line">accesslog &#x3D; &#39;&#x2F;var&#x2F;log&#x2F;gunicorn_acess.log&#39;</span><br><span class="line">errorlog &#x3D; &#39;&#x2F;var&#x2F;log&#x2F;gunicorn_error.log&#39;</span><br><span class="line"> </span><br><span class="line"># 日志级别</span><br><span class="line">loglevel &#x3D; &#39;debug&#39;</span><br></pre></td></tr></table></figure>

<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn -c gunicorn.conf app:app</span><br></pre></td></tr></table></figure>

<h3 id="2-3-日志格式说明"><a href="#2-3-日志格式说明" class="headerlink" title="2.3 日志格式说明"></a>2.3 日志格式说明</h3><h4 id="access-logformat"><a href="#access-logformat" class="headerlink" title="--access-logformat"></a><code>--access-logformat</code></h4><table>
<thead>
<tr>
<th align="center">识别码</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">h</td>
<td align="center">远程地址</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">“-“</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">用户名</td>
</tr>
<tr>
<td align="center">t</td>
<td align="center">时间</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">状态行，如：<code>GET /test HTTP/1.1</code></td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">请求方法</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">没有查询字符串的URL</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">查询字符串</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">协议</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">状态码</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">response长度</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">response长度(CLF格式)</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">参考</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">用户代理</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">请求时间，单位为s</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">请求时间，单位为ms</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">进程id</td>
</tr>
<tr>
<td align="center">{Header}i</td>
<td align="center">请求头</td>
</tr>
<tr>
<td align="center">{Header}o</td>
<td align="center">相应头</td>
</tr>
<tr>
<td align="center">{Variable}e</td>
<td align="center">环境变量</td>
</tr>
</tbody></table>
<h4 id="2-3-1-获取客户端真实IP"><a href="#2-3-1-获取客户端真实IP" class="headerlink" title="2.3.1 获取客户端真实IP"></a>2.3.1 获取客户端真实IP</h4><h5 id="Nginx代理配置"><a href="#Nginx代理配置" class="headerlink" title="Nginx代理配置"></a>Nginx代理配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_set_header  Host              $host;</span><br><span class="line">proxy_set_header  X-Real-IP         $remote_addr;</span><br><span class="line">proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_pass        http:&#x2F;&#x2F;127.0.0.1:8080;</span><br></pre></td></tr></table></figure>


<h5 id="logformat"><a href="#logformat" class="headerlink" title="logformat"></a>logformat</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%(h)s %(l)s %(u)s %(t)s &quot;%(r)s&quot; %(s)s %(b)s &quot;%(f)s&quot; &quot;%(a)s&quot; &quot;%(&#123;X-Real-IP&#125;i)s&quot;</span><br></pre></td></tr></table></figure>

<p>通过配置环境变量”X-Real-IP”获取客户端IP</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell取之前的日期及时间</title>
    <url>/2019/11/13/Linux-Shell%E5%8F%96%E4%B9%8B%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E5%8F%8A%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<blockquote>
<p> 写脚本时经常用到取之前日期的情况，解决方法总结如下：</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash </span><br><span class="line">#一月前  </span><br><span class="line">historyTime&#x3D;$(date &quot;+%Y-%m-%d %H&quot; -d &#39;1 month ago&#39;)  </span><br><span class="line">echo $&#123;historyTime&#125;  </span><br><span class="line"></span><br><span class="line">#一个月前时间戳</span><br><span class="line">historyTimeStamp&#x3D;$(date -d &quot;$historyTime&quot; +%s)  </span><br><span class="line">echo $&#123;historyTimeStamp&#125;  </span><br><span class="line"></span><br><span class="line">#一周前  </span><br><span class="line">historyWeek&#x3D;$(date &quot;+%Y-%m-%d %H&quot; -d &#39;7 day ago&#39;) </span><br><span class="line">echo $&#123;historyWeek&#125; </span><br><span class="line"></span><br><span class="line">#本月一月一日  </span><br><span class="line">date_this_month&#x3D;&#96;date +%Y%m01&#96;  </span><br><span class="line">echo $data_this_month </span><br><span class="line"></span><br><span class="line">#一天前  </span><br><span class="line">date_today&#x3D;&#96;date -d &#39;1 day ago&#39; +%Y%m%d&#96;  </span><br><span class="line">echo $date_today </span><br><span class="line"></span><br><span class="line">#一小时前  </span><br><span class="line">one_Hour&#x3D;$(date &quot;+%Y-%m-%d %H&quot; -d &#39;-1 hours&#39;) </span><br><span class="line">echo $one_Hour</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux CURL命令使用示例</title>
    <url>/2019/11/07/Linux-CURL%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>1.curl是libcurl这个库支持的，默认支持HTTP1.1（也支持1.0）。<br>2.curl支持很多的协议。curl supports FTP, FTPS, HTTP, HTTPS, SCP, SFTP, TFTP, TELNET, DICT, LDAP, LDAPS, FILE, POP3, IMAP, SMTP and RTSP at the time of this writing. Wget supports HTTP, HTTPS and FTP.</p>
</blockquote>
<a id="more"></a>

<h3 id="curl-option-url"><a href="#curl-option-url" class="headerlink" title="curl [option] [url]"></a>curl [option] [url]</h3><h4 id="1-获取页面内容"><a href="#1-获取页面内容" class="headerlink" title="1.获取页面内容"></a>1.获取页面内容</h4><p>当我们不加任何选项使用curl时，默认会发送GET请求来获取链接内容到标准输出</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">curl</span> <span class="selector-tag">localhost</span><span class="selector-pseudo">:80</span></span><br></pre></td></tr></table></figure>

<h4 id="2-显示HTTP头"><a href="#2-显示HTTP头" class="headerlink" title="2.显示HTTP头"></a>2.显示HTTP头</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option： -I</span><br><span class="line">curl -I localhost:80</span><br></pre></td></tr></table></figure>

<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, <span class="number">06</span> Nov <span class="number">2019</span> <span class="number">01</span>:<span class="number">54</span>:<span class="number">45</span> GMT</span><br><span class="line">Content-<span class="built_in">Type</span>: text/html; charset=UTF<span class="number">-8</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line"><span class="built_in">Set</span>-Cookie: PHPSESSID=<span class="number">123</span>sfjd7pudferq6dmvtnfhang; path=/</span><br><span class="line">Expires: Thu, <span class="number">19</span> Nov <span class="number">1981</span> <span class="number">08</span>:<span class="number">52</span>:<span class="number">00</span> GMT</span><br><span class="line">Cache-Control: no-store, no-cache, must-revalidate</span><br><span class="line">Pragma: no-cache</span><br><span class="line"><span class="built_in">Set</span>-Cookie: user%<span class="number">5</span>BmultiLogin%<span class="number">5</span>D=no; path=/</span><br></pre></td></tr></table></figure>

<h4 id="3-显示HTTP头和文件内容"><a href="#3-显示HTTP头和文件内容" class="headerlink" title="3.显示HTTP头和文件内容"></a>3.显示HTTP头和文件内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option： -i</span><br><span class="line">curl -i localhost:80</span><br></pre></td></tr></table></figure>

<h5 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 06 Nov 2019 01:55:11 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Set-Cookie: PHPSESSID=ueuau8ks4ufltk1vhc39tps8va; path=/</span><br><span class="line">Expires: Thu, 19 Nov 1981 08:52:00 GMT</span><br><span class="line">Cache-Control: no-store, no-cache, must-revalidate</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Set-Cookie: user%5BmultiLogin%5D=no; path=/</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-将链接保存到文件"><a href="#4-将链接保存到文件" class="headerlink" title="4.将链接保存到文件"></a>4.将链接保存到文件</h4><p>通过输出重定向符号“&gt;”将输出指定到文件中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">curl</span> <span class="selector-tag">localhost</span><span class="selector-pseudo">:80</span> &gt; <span class="selector-tag">index</span><span class="selector-class">.html</span></span><br><span class="line"><span class="selector-tag">option</span>：<span class="selector-tag">-o</span></span><br><span class="line"><span class="selector-tag">curl</span> <span class="selector-tag">-o</span> <span class="selector-tag">index</span><span class="selector-class">.html</span> <span class="selector-tag">localhost</span><span class="selector-pseudo">:80</span></span><br><span class="line"><span class="selector-tag">option</span>：<span class="selector-tag">-O</span>    <span class="selector-id">#URL</span>中要有文件名</span><br><span class="line">curl -O localhost:80/file</span><br></pre></td></tr></table></figure>

<h4 id="5-同时下载多个文件"><a href="#5-同时下载多个文件" class="headerlink" title="5.同时下载多个文件"></a>5.同时下载多个文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -O localhost:80&#x2F;file1 -O localhost:80&#x2F;file2</span><br><span class="line">curl -o file1.html localhost:80&#x2F;file&#x2F;1 -o file2.html localhost:80&#x2F;file&#x2F;2</span><br></pre></td></tr></table></figure>

<h4 id="6-跟随链接重定向"><a href="#6-跟随链接重定向" class="headerlink" title="6.跟随链接重定向"></a>6.跟随链接重定向</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option -L</span><br><span class="line">curl -L localhost:80</span><br></pre></td></tr></table></figure>

<h4 id="7-自定义header"><a href="#7-自定义header" class="headerlink" title="7.自定义header"></a>7.自定义header</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option -H</span><br><span class="line">curl -H &quot;Host: 118.31.76.144:80&quot; -H &quot;Cookie: token&#x3D;we8rw9r32ujew8r2jew9823&quot; http:&#x2F;&#x2F;zq.com&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure>

<h4 id="8-发送POST请求"><a href="#8-发送POST请求" class="headerlink" title="8.发送POST请求"></a>8.发送POST请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option -d</span><br><span class="line">curl -d &quot;username&#x3D;root&amp;password&#x3D;123456&quot;  -X POST  http:&#x2F;&#x2F;zq.com&#x2F;login</span><br></pre></td></tr></table></figure>

<p><em>-d：用于指定发送的数据，-X：用于指定请求方式</em><br> <em>注：在使用-d(默认为POST请求)发送POST请求是可不加-X</em><br> 如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">"username=root&amp;password=123456"</span>   http:<span class="comment">//zq.com/login</span></span><br><span class="line">curl -d <span class="string">"@data.txt"</span> http:<span class="comment">//zq.com/login      #从文件中读取数据</span></span><br></pre></td></tr></table></figure>

<h4 id="9-发送GET请求"><a href="#9-发送GET请求" class="headerlink" title="9.发送GET请求"></a>9.发送GET请求</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">"data"</span> -X GET <span class="symbol">http:</span>/<span class="regexp">/zq.com/api</span>       <span class="comment">#强制使用GET请求</span></span><br><span class="line">curl -d <span class="string">"data"</span> -G <span class="symbol">http:</span>/<span class="regexp">/zq.com/api</span></span><br></pre></td></tr></table></figure>

<h4 id="10-读取-Cookie"><a href="#10-读取-Cookie" class="headerlink" title="10.读取 Cookie"></a>10.读取 Cookie</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">option -b   <span class="comment">#-b后面可以是 Cookie 字符串，也可以是保存了 Cookie 的文件名</span></span><br><span class="line">curl -b <span class="string">"token=we8rw9r32ujew8r2jew9823"</span> http://zq.com/html/index.html</span><br><span class="line">curl -b <span class="string">"collie-filename"</span> http://zq.com/html/index.html</span><br></pre></td></tr></table></figure>

<h4 id="11-保存-Cookie"><a href="#11-保存-Cookie" class="headerlink" title="11.保存 Cookie"></a>11.保存 Cookie</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">option -<span class="built_in">c</span></span><br><span class="line">curl -<span class="built_in">c</span> <span class="string">"collie-filename"</span> http:<span class="comment">//zq.com/html/index.html</span></span><br></pre></td></tr></table></figure>

<h4 id="11-上传"><a href="#11-上传" class="headerlink" title="11.上传"></a>11.上传</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">option --form</span><br><span class="line"> curl --form &quot;fileupload&#x3D;@filename.txt&quot; http:&#x2F;&#x2F;zq.com&#x2F;resource</span><br></pre></td></tr></table></figure>

<p>常见参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">-A/--user-agent <span class="tag">&lt;<span class="name">string</span>&gt;</span> 设置用户代理发送给服务器</span><br><span class="line">-b/--cookie <span class="tag">&lt;<span class="name">name=string</span>/<span class="attr">file</span>&gt;</span> cookie字符串或文件读取位置</span><br><span class="line">-c/--cookie-jar <span class="tag">&lt;<span class="name">file</span>&gt;</span> 操作结束后把cookie写入到这个文件中</span><br><span class="line">-C/--continue-at <span class="tag">&lt;<span class="name">offset</span>&gt;</span> 断点续转</span><br><span class="line">-D/--dump-header <span class="tag">&lt;<span class="name">file</span>&gt;</span> 把header信息写入到该文件中</span><br><span class="line">-e/--referer 来源网址</span><br><span class="line">-f/--fail 连接失败时不显示http错误</span><br><span class="line">-o/--output 把输出写到该文件中</span><br><span class="line">-O/--remote-name 把输出写到该文件中，保留远程文件的文件名</span><br><span class="line">-r/--range <span class="tag">&lt;<span class="name">range</span>&gt;</span> 检索来自HTTP/1.1或FTP服务器字节范围</span><br><span class="line">-s/--silent 静音模式。不输出任何东西</span><br><span class="line">-T/--upload-file <span class="tag">&lt;<span class="name">file</span>&gt;</span> 上传文件</span><br><span class="line">-u/--user <span class="tag">&lt;<span class="name">user[:password]</span>&gt;</span> 设置服务器的用户和密码</span><br><span class="line">-w/--write-out [format] 什么输出完成后</span><br><span class="line">-x/--proxy <span class="tag">&lt;<span class="name">host[:port]</span>&gt;</span> 在给定的端口上使用HTTP代理</span><br><span class="line">-#/--progress-bar 进度条显示当前的传送状态</span><br><span class="line">-z 判断日期</span><br><span class="line">--limit-rate 下载限速</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux—添加开机启动(服务/脚本)</title>
    <url>/2020/06/05/Linux%E2%80%94%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8-%E6%9C%8D%E5%8A%A1-%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p><strong>系统启动时需要加载的配置文件</strong><br>/etc/profile、/root/.bash_profile<br>/etc/bashrc、/root/.bashrc<br>/etc/profile.d/*.sh、/etc/profile.d/lang.sh<br>/etc/sysconfig/i18n、/etc/rc.local（/etc/rc.d/rc.local）</p>
<a id="more"></a>
<p><strong>一、修改开机启动文件</strong></p>
<ol>
<li>/etc/rc.local（或者/etc/rc.d/rc.local）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.编辑rc.local文件，该文件是一个软链接，可以直接编辑/etc/rc.d/rc.local</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vi /etc/rc.d/rc.local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改rc.local文件加入以下命令。保存并退出。</span></span><br><span class="line">/etc/init.d/mysqld start                                         <span class="comment"># mysql开机启动</span></span><br><span class="line">/etc/init.d/nginx start                                          <span class="comment"># nginx开机启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.最后修改rc.local文件的执行权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod +x  /etc/rc.d/rc.local</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod 755 /etc/rc.d/rc.local</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl status rc-local                    # 查看一下服务是否自启动</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl start rc-local                     # 启动服务</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl enable rc-local                    # 开机自启</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>/etc/profile (或者 /etc/profile.d/)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.编辑profile文件，在文件中添加需要运行的脚本命令</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vi /etc/profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.将脚本(.sh文件)放到目录 /etc/profile.d/ 下，系统启动后就会自动执行该目录下的所有shell脚本  （账号登录执行,开机不执行）</span></span><br></pre></td></tr></table></figure>



<p><strong>二、自己写一个shell脚本</strong><br>将写好的脚本（.sh文件）放到目录 /etc/profile.d/ 下，系统启动后就会自动执行该目录下的所有shell脚本。<br><strong>三、通过chkconfig命令设置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.将(脚本)启动文件移动到 /etc/init.d/或者/etc/rc.d/init.d/目录下。（前者是后者的软连接）</span></span><br><span class="line">mv  /www/wwwroot/test.sh /etc/rc.d/init.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.启动文件前面务必添加如下三行代码，否侧会提示chkconfig不支持。</span></span><br><span class="line"><span class="comment">#!/bin/sh                          告诉系统使用的shell,所以的shell脚本都是这样</span></span><br><span class="line"><span class="comment">#chkconfig: 35 20 80               分别代表运行级别，启动优先权，关闭优先权，此行代码必须</span></span><br><span class="line"><span class="comment">#description: http server          自己随便发挥！！！，此行代码必须</span></span><br><span class="line">/bin/<span class="built_in">echo</span> $(/bin/date +%F_%T) &gt;&gt; /tmp/test.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.增加脚本的可执行权限</span></span><br><span class="line">chmod +x  /etc/rc.d/init.d/test.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.添加脚本到开机自动启动项目中。添加到chkconfig，开机自启动。</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd /etc/rc.d/init.d</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig --add test.sh</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig test.sh on</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.关闭开机启动 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig test.sh off</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.从chkconfig管理中删除test.sh</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig --del test.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看chkconfig管理</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chkconfig --list test.sh</span></span><br></pre></td></tr></table></figure>

<p><strong>四、自定义服务文件，添加到系统服务，通过Systemctl管理</strong><br>1.写服务文件：如nginx.service、redis.service、supervisord.service</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]:服务的说明</span><br><span class="line">Description:描述服务</span><br><span class="line">After:描述服务类别</span><br><span class="line"></span><br><span class="line">[Service]服务运行参数的设置</span><br><span class="line">Type=forking            是后台运行的形式</span><br><span class="line">ExecStart               为服务的具体运行命令</span><br><span class="line">ExecReload              为服务的重启命令</span><br><span class="line">ExecStop                为服务的停止命令</span><br><span class="line">PrivateTmp=True         表示给服务分配独立的临时空间</span><br><span class="line">注意：启动、重启、停止命令全部要求使用绝对路径</span><br><span class="line"></span><br><span class="line">[Install]               服务安装的相关设置，可设置为多用户</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>2.文件保存在目录下：以754的权限。目录路径：/usr/lib/systemd/system。如上面的supervisord.service文件放在这个目录下面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /usr/lib/systemd/system/nginx.service</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /usr/lib/systemd/system/supervisord.service</span></span><br></pre></td></tr></table></figure>

<p>3.设置开机自启动(任意目录下执行)。如果执行启动命令报错，则执行：systemctl daemon-reload</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">设置开机自启动</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl enable nginx.service       </span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl enable supervisord</span></span><br><span class="line"></span><br><span class="line">停止开机自启动</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl disable nginx.service</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl disable supervisord       # 验证一下是否为开机启动</span></span><br></pre></td></tr></table></figure>

<p>4.其他命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">启动nginx服务</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl start nginx.service</span></span><br><span class="line">停止nginx服务</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl start nginx.service</span></span><br><span class="line">重启nginx服务</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl restart nginx.service</span></span><br><span class="line">查看nginx服务当前状态</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl status nginx.service</span></span><br><span class="line">查看所有已启动的服务</span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl list-units --type=service</span></span><br></pre></td></tr></table></figure>

<p>5.服务文件示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># supervisord.service进程管理服务文件[Unit]</span></span><br><span class="line">Description=Process Monitoring and Control Daemon   <span class="comment"># 内容自己定义：Description=Supervisor daemon</span></span><br><span class="line">After=rc-local.service nss-user-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.confExecStop= /usr/bin/supervisorctl shutdown </span><br><span class="line">ExecReload=/usr/bin/supervisorctl reloadRestart=on-failureRestartSec=42sKillMode=process </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx.service服务文件[Unit]</span></span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -c /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s stop</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis.service服务文件</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/redis-server /etc/redis.conf</span><br><span class="line">ExecStop=<span class="built_in">kill</span> -INT `cat /tmp/redis.pid`</span><br><span class="line">User=www</span><br><span class="line">Group=www</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p> <a href="https://www.cnblogs.com/zwcry/p/9602756.html" target="_blank" rel="noopener">https://www.cnblogs.com/zwcry/p/9602756.html</a></p>
<p> <a href="https://www.jianshu.com/p/e1442913eb0e" target="_blank" rel="noopener">https://www.jianshu.com/p/e1442913eb0e</a></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>rc.local</tag>
        <tag>profile</tag>
        <tag>开机启动</tag>
      </tags>
  </entry>
  <entry>
    <title>Go每日一库之cron</title>
    <url>/2020/08/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%E4%B9%8Bcron/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/robfig/cron" target="_blank" rel="noopener"><code>cron</code></a>一个用于管理定时任务的库，用 Go 实现 Linux 中<code>crontab</code>这个命令的效果。之前我们也介绍过一个类似的 Go 库——<a href="https://darjun.github.io/2020/04/20/godailylib/gron/" target="_blank" rel="noopener"><code>gron</code></a>。<code>gron</code>代码小巧，用于学习是比较好的。但是它功能相对简单些，并且已经不维护了。如果有定时任务需求，还是建议使用<code>cron</code>。</p>
<a id="more"></a>

<h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>文本代码使用 Go Modules。</p>
<p>创建目录并初始化：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> cron &amp;&amp; <span class="built_in">cd</span> cron</span><br><span class="line">$ go mod init github.com/darjun/go-daily-lib/cron</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>安装<code>cron</code>，目前最新稳定版本为 v3：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ go get -u github.com/robfig/cron/v3</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"github.com/robfig/cron/v3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">"@every 1s"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"tick every 1 second"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line">  time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>

<p>使用非常简单，创建<code>cron</code>对象，这个对象用于管理定时任务。</p>
<p>调用<code>cron</code>对象的<code>AddFunc()</code>方法向管理器中添加定时任务。<code>AddFunc()</code>接受两个参数，参数 1 以字符串形式指定触发时间规则，参数 2 是一个无参的函数，每次触发时调用。<code>@every 1s</code>表示每秒触发一次，<code>@every</code>后加一个时间间隔，表示每隔多长时间触发一次。例如<code>@every 1h</code>表示每小时触发一次，<code>@every 1m2s</code>表示每隔 1 分 2 秒触发一次。<code>time.ParseDuration()</code>支持的格式都可以用在这里。</p>
<p>调用<code>c.Start()</code>启动定时循环。</p>
<p>注意一点，因为<code>c.Start()</code>启动一个新的 goroutine 做循环检测，我们在代码最后加了一行<code>time.Sleep(time.Second * 5)</code>防止主 goroutine 退出。</p>
<p>运行效果，每隔 1s 输出一行字符串：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ go run main.go </span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line">tick every <span class="number">1</span> second</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h2 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h2><p>与Linux 中<code>crontab</code>命令相似，<code>cron</code>库支持用 <strong>5</strong> 个空格分隔的域来表示时间。这 5 个域含义依次为：</p>
<ul>
<li><code>Minutes</code>：分钟，取值范围<code>[0-59]</code>，支持特殊字符<code>* / , -</code>；</li>
<li><code>Hours</code>：小时，取值范围<code>[0-23]</code>，支持特殊字符<code>* / , -</code>；</li>
<li><code>Day of month</code>：每月的第几天，取值范围<code>[1-31]</code>，支持特殊字符<code>* / , - ?</code>；</li>
<li><code>Month</code>：月，取值范围<code>[1-12]</code>或者使用月份名字缩写<code>[JAN-DEC]</code>，支持特殊字符<code>* / , -</code>；</li>
<li><code>Day of week</code>：周历，取值范围<code>[0-6]</code>或名字缩写<code>[JUN-SAT]</code>，支持特殊字符<code>* / , - ?</code>。</li>
</ul>
<p>注意，月份和周历名称都是不区分大小写的，也就是说<code>SUN/Sun/sun</code>表示同样的含义（都是周日）。</p>
<p>特殊字符含义如下：</p>
<ul>
<li><code>*</code>：使用<code>*</code>的域可以匹配任何值，例如将月份域（第 4 个）设置为<code>*</code>，表示每个月；</li>
<li><code>/</code>：用来指定范围的<strong>步长</strong>，例如将小时域（第 2 个）设置为<code>3-59/15</code>表示第 3 分钟触发，以后每隔 15 分钟触发一次，因此第 2 次触发为第 18 分钟，第 3 次为 33 分钟。。。直到分钟大于 59；</li>
<li><code>,</code>：用来列举一些离散的值和多个范围，例如将周历的域（第 5 个）设置为<code>MON,WED,FRI</code>表示周一、三和五；</li>
<li><code>-</code>：用来表示范围，例如将小时的域（第 1 个）设置为<code>9-17</code>表示上午 9 点到下午 17 点（包括 9 和 17）；</li>
<li><code>?</code>：只能用在月历和周历的域中，用来代替<code>*</code>，表示每月/周的任意一天。</li>
</ul>
<p>了解规则之后，我们可以定义任意时间：</p>
<ul>
<li><code>30 * * * *</code>：分钟域为 30，其他域都是<code>*</code>表示任意。每小时的 30 分触发；</li>
<li><code>30 3-6,20-23 * * *</code>：分钟域为 30，小时域的<code>3-6,20-23</code>表示 3 点到 6 点和 20 点到 23 点。3,4,5,6,20,21,22,23 时的 30 分触发；</li>
<li><code>0 0 1 1 *</code>：1（第 4 个） 月 1（第 3 个） 号的 0（第 2 个） 时 0（第 1 个） 分触发。</li>
</ul>
<p>记熟了这几个域的顺序，再多练习几次很容易就能掌握格式。熟悉规则了之后，就能熟练使用<code>crontab</code>命令了。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">"30 * * * *"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Every hour on the half hour"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">"30 3-6,20-23 * * *"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"On the half hour of 3-6am, 8-11pm"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">"0 0 1 1 *"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Jun 1 every year"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>

<h3 id="预定义时间规则"><a href="#预定义时间规则" class="headerlink" title="预定义时间规则"></a>预定义时间规则</h3><p>为了方便使用，<code>cron</code>预定义了一些时间规则：</p>
<ul>
<li><code>@yearly</code>：也可以写作<code>@annually</code>，表示每年第一天的 0 点。等价于<code>0 0 1 1 *</code>；</li>
<li><code>@monthly</code>：表示每月第一天的 0 点。等价于<code>0 0 1 * *</code>；</li>
<li><code>@weekly</code>：表示每周第一天的 0 点，注意第一天为周日，即周六结束，周日开始的那个 0 点。等价于<code>0 0 * * 0</code>；</li>
<li><code>@daily</code>：也可以写作<code>@midnight</code>，表示每天 0 点。等价于<code>0 0 * * *</code>；</li>
<li><code>@hourly</code>：表示每小时的开始。等价于<code>0 * * * *</code>。</li>
</ul>
<p>例如：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">"@hourly"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Every hour"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">"@daily"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Every day on midnight"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">"@weekly"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Every week"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>

<p>上面代码只是演示用法，实际运行可能要等待非常长的时间才能有输出。</p>
<h3 id="固定时间间隔"><a href="#固定时间间隔" class="headerlink" title="固定时间间隔"></a>固定时间间隔</h3><p><code>cron</code>支持固定时间间隔，格式为：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">@every &lt;duration&gt;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>含义为每隔<code>duration</code>触发一次。<code>&lt;duration&gt;</code>会调用<code>time.ParseDuration()</code>函数解析，所以<code>ParseDuration</code>支持的格式都可以。例如<code>1h30m10s</code>。在快速开始部分，我们已经演示了<code>@every</code>的用法了，这里就不赘述了。</p>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>默认情况下，所有时间都是基于当前时区的。当然我们也可以指定时区，有 2 两种方式：</p>
<ul>
<li>在时间字符串前面添加一个<code>CRON_TZ=</code> + 具体时区，具体时区的格式在之前<a href="https://darjun.github.io/2020/02/14/godailylib/carbon/" target="_blank" rel="noopener"><code>carbon</code></a>的文章中有详细介绍。东京时区为<code>Asia/Tokyo</code>，纽约时区为<code>America/New_York</code>；</li>
<li>创建<code>cron</code>对象时增加一个时区选项<code>cron.WithLocation(location)</code>，<code>location</code>为<code>time.LoadLocation(zone)</code>加载的时区对象，<code>zone</code>为具体的时区格式。或者调用已创建好的<code>cron</code>对象的<code>SetLocation()</code>方法设置时区。</li>
</ul>
<p>示例：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  nyc, _ := time.LoadLocation(<span class="string">"America/New_York"</span>)</span><br><span class="line">  c := cron.New(cron.WithLocation(nyc))</span><br><span class="line">  c.AddFunc(<span class="string">"0 6 * * ?"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Every 6 o'clock at New York"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.AddFunc(<span class="string">"CRON_TZ=Asia/Tokyo 0 6 * * ?"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Every 6 o'clock at Tokyo"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<h2 id="Job接口"><a href="#Job接口" class="headerlink" title="Job接口"></a><code>Job</code>接口</h2><p>除了直接将无参函数作为回调外，<code>cron</code>还支持<code>Job</code>接口：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cron.go</span></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">interface</span> &#123;</span><br><span class="line">  Run()</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>我们定义一个实现接口<code>Job</code>的结构：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GreetingJob <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GreetingJob)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello "</span>, g.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>调用<code>cron</code>对象的<code>AddJob()</code>方法将<code>GreetingJob</code>对象添加到定时管理器中：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line">  c.AddJob(<span class="string">"@every 1s"</span>, GreetingJob&#123;<span class="string">"dj"</span>&#125;)</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ go run main.go </span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line">Hello  dj</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>使用自定义的结构可以让任务携带状态（<code>Name</code>字段）。</p>
<p>实际上<code>AddFunc()</code>方法内部也调用了<code>AddJob()</code>方法。首先，<code>cron</code>基于<code>func()</code>类型定义一个新的类型<code>FuncJob</code>：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cron.go</span></span><br><span class="line"><span class="keyword">type</span> FuncJob <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">12</span></span><br></pre></td></tr></table></figure>

<p>然后让<code>FuncJob</code>实现<code>Job</code>接口：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cron.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f FuncJob)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>在<code>AddFunc()</code>方法中，将传入的回调转为<code>FuncJob</code>类型，然后调用<code>AddJob()</code>方法：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cron)</span> <span class="title">AddFunc</span><span class="params">(spec <span class="keyword">string</span>, cmd <span class="keyword">func</span>()</span>) <span class="params">(EntryID, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c.AddJob(spec, FuncJob(cmd))</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><code>cron</code>会创建一个新的 goroutine 来执行触发回调。如果这些回调需要并发访问一些资源、数据，我们需要显式地做同步。</p>
<h2 id="自定义时间格式"><a href="#自定义时间格式" class="headerlink" title="自定义时间格式"></a>自定义时间格式</h2><p><code>cron</code>支持灵活的时间格式，如果默认的格式不能满足要求，我们可以自己定义时间格式。时间规则字符串需要<code>cron.Parser</code>对象来解析。我们先来看看默认的解析器是如何工作的。</p>
<p>首先定义各个域：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parser.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Second         ParseOption = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">  SecondOptional                        </span><br><span class="line">  Minute                                </span><br><span class="line">  Hour                                  </span><br><span class="line">  Dom                                   </span><br><span class="line">  Month                                 </span><br><span class="line">  Dow                                   </span><br><span class="line">  DowOptional                           </span><br><span class="line">  Descriptor                            </span><br><span class="line">)</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>除了<code>Minute/Hour/Dom(Day of month)/Month/Dow(Day of week)</code>外，还可以支持<code>Second</code>。相对顺序都是固定的：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parser.go</span></span><br><span class="line"><span class="keyword">var</span> places = []ParseOption&#123;</span><br><span class="line">  Second,</span><br><span class="line">  Minute,</span><br><span class="line">  Hour,</span><br><span class="line">  Dom,</span><br><span class="line">  Month,</span><br><span class="line">  Dow,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaults = []<span class="keyword">string</span>&#123;</span><br><span class="line">  <span class="string">"0"</span>,</span><br><span class="line">  <span class="string">"0"</span>,</span><br><span class="line">  <span class="string">"0"</span>,</span><br><span class="line">  <span class="string">"*"</span>,</span><br><span class="line">  <span class="string">"*"</span>,</span><br><span class="line">  <span class="string">"*"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>默认的时间格式使用 5 个域。</p>
<p>我们可以调用<code>cron.NewParser()</code>创建自己的<code>Parser</code>对象，以位格式传入使用哪些域，例如下面的<code>Parser</code>使用 6 个域，支持<code>Second</code>（秒）：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">parser := cron.NewParser(</span><br><span class="line">  cron.Second | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor,</span><br><span class="line">)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>调用<code>cron.WithParser(parser)</code>创建一个选项传入构造函数<code>cron.New()</code>，使用时就可以指定秒了：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">c := cron.New(cron.WithParser(parser))</span><br><span class="line">c.AddFunc(<span class="string">"1 * * * * *"</span>, <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"every 1 second"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>这里时间格式必须使用 6 个域，顺序与上面的<code>const</code>定义一致。</p>
<p>因为上面的时间格式太常见了，<code>cron</code>定义了一个便捷的函数：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// option.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithSeconds</span><span class="params">()</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> WithParser(NewParser(</span><br><span class="line">    Second | Minute | Hour | Dom | Month | Dow | Descriptor,</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>注意<code>Descriptor</code>表示对<code>@every/@hour</code>等的支持。有了<code>WithSeconds()</code>，我们不用手动创建<code>Parser</code>对象了：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">c := cron.New(cron.WithSeconds())</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><code>cron</code>对象创建使用了选项模式，我们前面已经介绍了 3 个选项：</p>
<ul>
<li><code>WithLocation</code>：指定时区；</li>
<li><code>WithParser</code>：使用自定义的解析器；</li>
<li><code>WithSeconds</code>：让时间格式支持秒，实际上内部调用了<code>WithParser</code>。</li>
</ul>
<p><code>cron</code>还提供了另外两种选项：</p>
<ul>
<li><code>WithLogger</code>：自定义<code>Logger</code>；</li>
<li><code>WithChain</code>：Job 包装器。</li>
</ul>
<h3 id="WithLogger"><a href="#WithLogger" class="headerlink" title="WithLogger"></a><code>WithLogger</code></h3><p><code>WithLogger</code>可以设置<code>cron</code>内部使用我们自定义的<code>Logger</code>：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New(</span><br><span class="line">    cron.WithLogger(</span><br><span class="line">      cron.VerbosePrintfLogger(log.New(os.Stdout, <span class="string">"cron: "</span>, log.LstdFlags))))</span><br><span class="line">  c.AddFunc(<span class="string">"@every 1s"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>上面调用<code>cron.VerbosPrintfLogger()</code>包装<code>log.Logger</code>，这个<code>logger</code>会详细记录<code>cron</code>内部的调度过程：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line"><span class="function">cron: 2020/06/26 07:09:14 <span class="title">start</span></span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:14 <span class="title">schedule</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:14+08:00, <span class="title">entry</span>=1, <span class="title">next</span>=2020-06-26<span class="title">T07</span>:09:15+08:00</span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:15 <span class="title">wake</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:15+08:00</span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:15 <span class="title">run</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:15+08:00, <span class="title">entry</span>=1, <span class="title">next</span>=2020-06-26<span class="title">T07</span>:09:16+08:00</span></span><br><span class="line"><span class="function"><span class="title">hello</span> <span class="title">world</span></span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:16 <span class="title">wake</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:16+08:00</span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:16 <span class="title">run</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:16+08:00, <span class="title">entry</span>=1, <span class="title">next</span>=2020-06-26<span class="title">T07</span>:09:17+08:00</span></span><br><span class="line"><span class="function"><span class="title">hello</span> <span class="title">world</span></span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:17 <span class="title">wake</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:17+08:00</span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:17 <span class="title">run</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:17+08:00, <span class="title">entry</span>=1, <span class="title">next</span>=2020-06-26<span class="title">T07</span>:09:18+08:00</span></span><br><span class="line"><span class="function"><span class="title">hello</span> <span class="title">world</span></span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:18 <span class="title">wake</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:18+08:00</span></span><br><span class="line"><span class="function"><span class="title">hello</span> <span class="title">world</span></span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:18 <span class="title">run</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:18+08:00, <span class="title">entry</span>=1, <span class="title">next</span>=2020-06-26<span class="title">T07</span>:09:19+08:00</span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:19 <span class="title">wake</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:19+08:00</span></span><br><span class="line"><span class="function"><span class="title">hello</span> <span class="title">world</span></span></span><br><span class="line"><span class="function"><span class="title">cron</span>: 2020/06/26 07:09:19 <span class="title">run</span>, <span class="title">now</span>=2020-06-26<span class="title">T07</span>:09:19+08:00, <span class="title">entry</span>=1, <span class="title">next</span>=2020-06-26<span class="title">T07</span>:09:20+08:0</span></span><br><span class="line"><span class="function">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>我们看看默认的<code>Logger</code>是什么样的：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logger.go</span></span><br><span class="line"><span class="keyword">var</span> DefaultLogger Logger = PrintfLogger(log.New(os.Stdout, <span class="string">"cron: "</span>, log.LstdFlags))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintfLogger</span><span class="params">(l <span class="keyword">interface</span>&#123; Printf(<span class="keyword">string</span>, ...<span class="keyword">interface</span>&#123;&#125;)</span> &#125;) <span class="title">Logger</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> printfLogger&#123;l, <span class="literal">false</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerbosePrintfLogger</span><span class="params">(l <span class="keyword">interface</span>&#123; Printf(<span class="keyword">string</span>, ...<span class="keyword">interface</span>&#123;&#125;)</span> &#125;) <span class="title">Logger</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> printfLogger&#123;l, <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printfLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">  logger  <span class="keyword">interface</span>&#123; Printf(<span class="keyword">string</span>, ...<span class="keyword">interface</span>&#123;&#125;) &#125;</span><br><span class="line">  logInfo <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<h3 id="WithChain"><a href="#WithChain" class="headerlink" title="WithChain"></a><code>WithChain</code></h3><p>Job 包装器可以在执行实际的<code>Job</code>前后添加一些逻辑：</p>
<ul>
<li>捕获<code>panic</code>；</li>
<li>如果<code>Job</code>上次运行还未结束，推迟本次执行;</li>
<li>如果<code>Job</code>上次运行还未介绍，跳过本次执行；</li>
<li>记录每个<code>Job</code>的执行情况。</li>
</ul>
<p>我们可以将<code>Chain</code>类比为 Web 处理器的中间件。实际上就是在<code>Job</code>的执行逻辑外在封装一层逻辑。我们的封装逻辑需要写成一个函数，传入一个<code>Job</code>类型，返回封装后的<code>Job</code>。<code>cron</code>为这种函数定义了一个类型<code>JobWrapper</code>：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chain.go</span></span><br><span class="line"><span class="keyword">type</span> JobWrapper <span class="function"><span class="keyword">func</span><span class="params">(Job)</span> <span class="title">Job</span></span></span><br><span class="line"><span class="function">12</span></span><br></pre></td></tr></table></figure>

<p>然后使用一个<code>Chain</code>对象将这些<code>JobWrapper</code>组合到一起：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Chain <span class="keyword">struct</span> &#123;</span><br><span class="line">  wrappers []JobWrapper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChain</span><span class="params">(c ...JobWrapper)</span> <span class="title">Chain</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Chain&#123;c&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>调用<code>Chain</code>对象的<code>Then(job)</code>方法应用这些<code>JobWrapper</code>，返回最终的`Job：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Chain)</span> <span class="title">Then</span><span class="params">(j Job)</span> <span class="title">Job</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> c.wrappers &#123;</span><br><span class="line">    j = c.wrappers[<span class="built_in">len</span>(c.wrappers)-i<span class="number">-1</span>](j)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>注意应用<code>JobWrapper</code>的顺序。</p>
<h3 id="内置JobWrapper"><a href="#内置JobWrapper" class="headerlink" title="内置JobWrapper"></a>内置<code>JobWrapper</code></h3><p><code>cron</code>内置了 3 个用得比较多的<code>JobWrapper</code>：</p>
<ul>
<li><code>Recover</code>：捕获内部<code>Job</code>产生的 panic；</li>
<li><code>DelayIfStillRunning</code>：触发时，如果上一次任务还未执行完成（耗时太长），则等待上一次任务完成之后再执行；</li>
<li><code>SkipIfStillRunning</code>：触发时，如果上一次任务还未完成，则跳过此次执行。</li>
</ul>
<p>下面分别介绍。</p>
<h4 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a><code>Recover</code></h4><p>先看看如何使用：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> panicJob <span class="keyword">struct</span> &#123;</span><br><span class="line">  count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *panicJob)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p.count++</span><br><span class="line">  <span class="keyword">if</span> p.count == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"oooooooooooooops!!!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line">  c.AddJob(<span class="string">"@every 1s"</span>, cron.NewChain(cron.Recover(cron.DefaultLogger)).Then(&amp;panicJob&#123;&#125;))</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<p><code>panicJob</code>在第一次触发时，触发了<code>panic</code>。因为有<code>cron.Recover()</code>保护，后续任务还能执行：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">go run main.go </span><br><span class="line"><span class="function">cron: 2020/06/27 14:02:00 <span class="title">panic</span>, <span class="title">error</span>=<span class="title">oooooooooooooops</span>!!!, <span class="title">stack</span>=...</span></span><br><span class="line"><span class="function"><span class="title">goroutine</span> 18 [<span class="title">running</span>]:</span></span><br><span class="line"><span class="function"><span class="title">github.com</span>/<span class="title">robfig</span>/<span class="title">cron</span>/<span class="title">v3.Recover.func1</span>.1.1(0<span class="title">x514ee0</span>, 0<span class="title">xc0000044a0</span>)</span></span><br><span class="line"><span class="function">        <span class="title">D</span>:/<span class="title">code</span>/<span class="title">golang</span>/<span class="title">pkg</span>/<span class="title">mod</span>/<span class="title">github.com</span>/<span class="title">robfig</span>/<span class="title">cron</span>/<span class="title">v3</span>@<span class="title">v3</span>.0.1/<span class="title">chain.go</span>:45 +0<span class="title">xbc</span></span></span><br><span class="line"><span class="function"><span class="title">panic</span>(0<span class="title">x4cf380</span>, 0<span class="title">x513280</span>)</span></span><br><span class="line"><span class="function">        <span class="title">C</span>:/<span class="title">Go</span>/<span class="title">src</span>/<span class="title">runtime</span>/<span class="title">panic.go</span>:969 +0<span class="title">x174</span></span></span><br><span class="line"><span class="function"><span class="title">main</span>.(*<span class="title">panicJob</span>).<span class="title">Run</span>(0<span class="title">xc0000140e8</span>)</span></span><br><span class="line"><span class="function">        <span class="title">D</span>:/<span class="title">code</span>/<span class="title">golang</span>/<span class="title">src</span>/<span class="title">github.com</span>/<span class="title">darjun</span>/<span class="title">go</span>-<span class="title">daily</span>-<span class="title">lib</span>/<span class="title">cron</span>/<span class="title">recover</span>/<span class="title">main.go</span>:17 +0<span class="title">xba</span></span></span><br><span class="line"><span class="function"><span class="title">github.com</span>/<span class="title">robfig</span>/<span class="title">cron</span>/<span class="title">v3.Recover.func1</span>.1()</span></span><br><span class="line"><span class="function">        <span class="title">D</span>:/<span class="title">code</span>/<span class="title">golang</span>/<span class="title">pkg</span>/<span class="title">mod</span>/<span class="title">github.com</span>/<span class="title">robfig</span>/<span class="title">cron</span>/<span class="title">v3</span>@<span class="title">v3</span>.0.1/<span class="title">chain.go</span>:53 +0<span class="title">x6f</span></span></span><br><span class="line"><span class="function"><span class="title">github.com</span>/<span class="title">robfig</span>/<span class="title">cron</span>/<span class="title">v3.FuncJob.Run</span>(0<span class="title">xc000070390</span>)</span></span><br><span class="line"><span class="function">        <span class="title">D</span>:/<span class="title">code</span>/<span class="title">golang</span>/<span class="title">pkg</span>/<span class="title">mod</span>/<span class="title">github.com</span>/<span class="title">robfig</span>/<span class="title">cron</span>/<span class="title">v3</span>@<span class="title">v3</span>.0.1/<span class="title">cron.go</span>:136 +0<span class="title">x2c</span></span></span><br><span class="line"><span class="function"><span class="title">github.com</span>/<span class="title">robfig</span>/<span class="title">cron</span>/<span class="title">v3</span>.(*<span class="title">Cron</span>).<span class="title">startJob.func1</span>(0<span class="title">xc00005c0a0</span>, 0<span class="title">x514d20</span>, 0<span class="title">xc000070390</span>)</span></span><br><span class="line"><span class="function">        <span class="title">D</span>:/<span class="title">code</span>/<span class="title">golang</span>/<span class="title">pkg</span>/<span class="title">mod</span>/<span class="title">github.com</span>/<span class="title">robfig</span>/<span class="title">cron</span>/<span class="title">v3</span>@<span class="title">v3</span>.0.1/<span class="title">cron.go</span>:312 +0<span class="title">x68</span></span></span><br><span class="line"><span class="function"><span class="title">created</span> <span class="title">by</span> <span class="title">github.com</span>/<span class="title">robfig</span>/<span class="title">cron</span>/<span class="title">v3</span>.(*<span class="title">Cron</span>).<span class="title">startJob</span></span></span><br><span class="line"><span class="function">        <span class="title">D</span>:/<span class="title">code</span>/<span class="title">golang</span>/<span class="title">pkg</span>/<span class="title">mod</span>/<span class="title">github.com</span>/<span class="title">robfig</span>/<span class="title">cron</span>/<span class="title">v3</span>@<span class="title">v3</span>.0.1/<span class="title">cron.go</span>:310 +0<span class="title">x7a</span></span></span><br><span class="line"><span class="function"><span class="title">hello</span> <span class="title">world</span></span></span><br><span class="line"><span class="function"><span class="title">hello</span> <span class="title">world</span></span></span><br><span class="line"><span class="function"><span class="title">hello</span> <span class="title">world</span></span></span><br><span class="line"><span class="function"><span class="title">hello</span> <span class="title">world</span></span></span><br><span class="line"><span class="function">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>

<p>我们看看<code>cron.Recover()</code>的实现，很简单：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cron.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recover</span><span class="params">(logger Logger)</span> <span class="title">JobWrapper</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(j Job)</span> <span class="title">Job</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> FuncJob(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">          buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">          buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">          err, ok := r.(error)</span><br><span class="line">          <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">"%v"</span>, r)</span><br><span class="line">          &#125;</span><br><span class="line">          logger.Error(err, <span class="string">"panic"</span>, <span class="string">"stack"</span>, <span class="string">"...\n"</span>+<span class="keyword">string</span>(buf))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">      j.Run()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<p>就是在执行内层的<code>Job</code>逻辑前，添加<code>recover()</code>调用。如果<code>Job.Run()</code>执行过程中有<code>panic</code>。这里的<code>recover()</code>会捕获到，输出调用堆栈。</p>
<h4 id="DelayIfStillRunning"><a href="#DelayIfStillRunning" class="headerlink" title="DelayIfStillRunning"></a><code>DelayIfStillRunning</code></h4><p>还是先看如何使用：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> delayJob <span class="keyword">struct</span> &#123;</span><br><span class="line">  count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *delayJob)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">  d.count++</span><br><span class="line">  log.Printf(<span class="string">"%d: hello world\n"</span>, d.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line">  c.AddJob(<span class="string">"@every 1s"</span>, cron.NewChain(cron.DelayIfStillRunning(cron.DefaultLogger)).Then(&amp;delayJob&#123;&#125;))</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>上面我们在<code>Run()</code>中增加了一个 2s 的延迟，输出中间隔变为 2s，而不是定时的 1s：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span> </span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">11</span>:<span class="number">16</span> <span class="number">1</span>: hello world</span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">11</span>:<span class="number">18</span> <span class="number">2</span>: hello world</span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">11</span>:<span class="number">20</span> <span class="number">3</span>: hello world</span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">11</span>:<span class="number">22</span> <span class="number">4</span>: hello world</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>看看源码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DelayIfStillRunning</span><span class="params">(logger Logger)</span> <span class="title">JobWrapper</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(j Job)</span> <span class="title">Job</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="keyword">return</span> FuncJob(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      start := time.Now()</span><br><span class="line">      mu.Lock()</span><br><span class="line">      <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">      <span class="keyword">if</span> dur := time.Since(start); dur &gt; time.Minute &#123;</span><br><span class="line">        logger.Info(<span class="string">"delay"</span>, <span class="string">"duration"</span>, dur)</span><br><span class="line">      &#125;</span><br><span class="line">      j.Run()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>首先定义一个该任务共用的互斥锁<code>sync.Mutex</code>，每次执行任务前获取锁，执行结束之后释放锁。所以在上一个任务结束前，下一个任务获取锁是无法成功的，从而保证的任务的串行执行。</p>
<h4 id="SkipIfStillRunning"><a href="#SkipIfStillRunning" class="headerlink" title="SkipIfStillRunning"></a><code>SkipIfStillRunning</code></h4><p>还是先看看如何使用：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> skipJob <span class="keyword">struct</span> &#123;</span><br><span class="line">  count <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *skipJob)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  atomic.AddInt32(&amp;d.count, <span class="number">1</span>)</span><br><span class="line">  log.Printf(<span class="string">"%d: hello world\n"</span>, d.count)</span><br><span class="line">  <span class="keyword">if</span> atomic.LoadInt32(&amp;d.count) == <span class="number">1</span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := cron.New()</span><br><span class="line">  c.AddJob(<span class="string">"@every 1s"</span>, cron.NewChain(cron.SkipIfStillRunning(cron.DefaultLogger)).Then(&amp;skipJob&#123;&#125;))</span><br><span class="line">  c.Start()</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">07</span> <span class="number">1</span>: hello world</span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">10</span> <span class="number">2</span>: hello world</span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">11</span> <span class="number">3</span>: hello world</span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">12</span> <span class="number">4</span>: hello world</span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">13</span> <span class="number">5</span>: hello world</span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">14</span> <span class="number">6</span>: hello world</span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">15</span> <span class="number">7</span>: hello world</span><br><span class="line"><span class="number">2020</span>/<span class="number">06</span>/<span class="number">27</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">16</span> <span class="number">8</span>: hello world</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>注意观察时间，第一个与第二个输出之间相差 3s，因为跳过了两次执行。</p>
<p>注意<code>DelayIfStillRunning</code>与<code>SkipIfStillRunning</code>是有本质上的区别的，前者<code>DelayIfStillRunning</code>只要时间足够长，所有的任务都会按部就班地完成，只是可能前一个任务耗时过长，导致后一个任务的执行时间推迟了一点。<code>SkipIfStillRunning</code>会跳过一些执行。</p>
<p>看看源码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SkipIfStillRunning</span><span class="params">(logger Logger)</span> <span class="title">JobWrapper</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(j Job)</span> <span class="title">Job</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> FuncJob(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">        j.Run()</span><br><span class="line">        ch &lt;- v</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        logger.Info(<span class="string">"skip"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>定义一个该任务共用的缓存大小为 1 的通道<code>chan struct{}</code>。执行任务时，从通道中取值，如果成功，执行，否则跳过。执行完成之后再向通道中发送一个值，确保下一个任务能执行。初始发送一个值到通道中，保证第一个任务的执行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>cron</code>实现比较小巧，且优雅，代码行数也不多，非常值得一看！</p>
<p>大家如果发现好玩、好用的 Go 语言库，欢迎到 Go 每日一库 GitHub 上提交 issue😄</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>cron GitHub：<a href="https://github.com/robfig/cron" target="_blank" rel="noopener">https://github.com/robfig/cron</a></li>
<li>Go 每日一库之 carbon：<a href="https://darjun.github.io/2020/02/14/godailylib/carbon/" target="_blank" rel="noopener">https://darjun.github.io/2020/02/14/godailylib/carbon/</a></li>
<li>Go 每日一库之 gron：<a href="https://darjun.github.io/2020/04/20/godailylib/gron/" target="_blank" rel="noopener">https://darjun.github.io/2020/04/20/godailylib/gron/</a></li>
<li>Go 每日一库 GitHub：<a href="https://github.com/darjun/go-daily-lib" target="_blank" rel="noopener">https://github.com/darjun/go-daily-lib</a></li>
</ol>
<h2 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h2><p>博客：<a href="https://darjun.github.io/" target="_blank" rel="noopener">https://darjun.github.io</a></p>
<p>微信公众号【GoUpUp】，共同学习，一起进步~</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下使用convert批量压缩图片</title>
    <url>/2019/10/27/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8convert%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<blockquote>
<p>convert的功能相当强大，先来个示例，再慢慢研究其它的功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;www&#x2F;images  -regex &#39;.*\(jpg\|JPG\|png\|PNG\|jpeg\)&#39; -size +1000k -mtime -1 \</span><br><span class="line">    -exec convert -quality 75 &#123;&#125; &#123;&#125; \; </span><br><span class="line"># 参数解释    </span><br><span class="line">&#x2F;www&#x2F;images            # 要压缩图片的目录</span><br><span class="line">-regex &#39;.*\(jpg...|jpeg\)&#39;  # 正则匹配需要压缩的文件扩展名</span><br><span class="line">-size +1000k                # 要压缩图片的最小尺寸</span><br><span class="line">-mtime -1                   # -mtime -n +n (按文件更改时间来查找文件，-n指n天以内，+n指n天以前)</span><br><span class="line">-quality 75         # 压缩后的图片质量</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p><strong>安装</strong><br>如果系统中没有convert命令，就需要先安装了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CentOS:yum install ImageMagick #注意包名大小写</span><br><span class="line">Ubuntu:apt install imagemagick</span><br></pre></td></tr></table></figure>

<p><strong>转换图像格式</strong><br>支持JPG, BMP, PCX, GIF, PNG, TIFF, XPM和XWD等类型，下面举几个例子: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">convert xxx.jpg xxx.png  #将jpeg转成png文件 </span><br><span class="line">convert xxx.gif xxx.bmp  #将gif转换成bmp图像 </span><br><span class="line">convert xxx.tiff xxx.pcx #将tiff转换成pcx图像</span><br></pre></td></tr></table></figure>

<p><strong>改变图像的大小</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">convert -resize 1024x768 xxx.jpg xxx1.jpg #将图像的像素改为1024*768，注意1024与768之间是小写字母x </span><br><span class="line">convert -sample 50%x50% xxx.jpg xxx1.jpg  #将图像的缩减为原来的50%*50%</span><br></pre></td></tr></table></figure>

<p><strong>旋转图像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">convert -rotate 270 sky.jpg sky-final.jpg #将图像顺时针旋转270度</span><br></pre></td></tr></table></figure>

<p><strong>加边框</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">convert -raise 5x5 input.jpg output.jpg</span><br><span class="line">convert +raise 5x5 input.jpg output.jpg</span><br></pre></td></tr></table></figure>

<p><strong>添加文字水印</strong><br>使用-draw选项还可以在图像里面添加文字：<br>在图像的10,80 位置采用60磅的全黑Helvetica字体写上 Hello, World!<br>convert还有其他很多有趣和强大的功能，大家不妨可以试试。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">convert -fill black -pointsize 60 -font helvetica -draw &#39;text 10,80 &quot;Hello, World!&quot; hello.jpg helloworld.jpg</span><br></pre></td></tr></table></figure>
<p><strong>批量图像格式转换</strong><br>如果想将某目录下的所有jpg文件转换为png文件，在命令行模式下输入: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in *.JPG; do</span><br><span class="line">    convert -sample 25% &quot;$x&quot; &quot;$&#123;x%.JPG&#125;_converted.jpg&quot;</span><br><span class="line">    rm &quot;$x&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC下删除Docker容器日志方法</title>
    <url>/2020/04/13/MAC%E4%B8%8B%E5%88%A0%E9%99%A4Docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>第一步. 取容器的日志路径</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect fr2 | grep LogPath</span><br><span class="line"><span class="string">"LogPath"</span>: <span class="string">"/var/lib/docker/containers/</span></span><br><span class="line"><span class="string">b03099af97b289629f00e677ab58a740699b7c982b470d589ecdcbf52cd4e674/b03099af97b289629f00e677</span></span><br><span class="line"><span class="string">ab58a740699b7c982b470d589ecdcbf52cd4e674-json.log"</span>,</span><br></pre></td></tr></table></figure>

<p><strong>第二步.进入VM</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty</span><br></pre></td></tr></table></figure>

<p><strong>第三步.清空日志文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> &gt; /var/lib/docker/containers/b03099af97b289629f00e677ab58a740699b7c982b470d589ecdcbf52cd4e6</span><br><span class="line">74/b03099af97b289629f00e677ab58a740699b7c982b470d589ecdcbf52cd4e674-json.log</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置参数中文详细说明</title>
    <url>/2020/06/05/Nginx%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E4%B8%AD%E6%96%87%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p>可以在大多数 UnixLinux OS 上编译运行，并有 Windows 移植版。是一个很强大的高性能Web和反向代理服务，它具有很多非常优越的特性，在连接高并发的情况下，Nginx是Apache服务不错的替代品：Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一，能够支持高达 50,000 个并发连接数的响应。</p>
<p>Nginx作为负载均衡服务：Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务，也可以支持作为 HTTP 代理服务 对外进行服务。Nginx采用C进行编写，不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多。那对于Nginx的相应配置，当集群出现某些问题的时候，参数会起到相当重要的作用，但是大家也知道，包括官网在内，很多的参数配置都是用英文进行讲解，今天就给大家整理一些配置中文详解</p>
<a id="more"></a>
<h2 id="Nginx配置参数中文详细说明："><a href="#Nginx配置参数中文详细说明：" class="headerlink" title="Nginx配置参数中文详细说明："></a>Nginx配置参数中文详细说明：</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义Nginx运行的用户和用户组</span></span><br><span class="line"><span class="string">user</span> <span class="string">www</span> <span class="string">www;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#nginx进程数,建议设置为等于CPU总核心数.</span></span><br><span class="line"><span class="string">worker_processes</span> <span class="number">8</span><span class="string">;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#全局错误日志定义类型,[ debug | info | notice | warn | error | crit ]</span></span><br><span class="line"><span class="string">error_log</span> <span class="string">/var/log/nginx/error.log</span> <span class="string">info;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#进程文件</span></span><br><span class="line"><span class="string">pid</span> <span class="string">/var/run/nginx.pid;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#一个nginx进程打开的最多文件描述符数目,理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除,但是nginx分配请求并不均匀,所以建议与ulimit -n的值保持一致.</span></span><br><span class="line"><span class="string">worker_rlimit_nofile</span> <span class="number">65535</span><span class="string">;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#工作模式与连接数上限</span></span><br><span class="line"><span class="string">events</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="comment">#参考事件模型,use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型,如果跑在FreeBSD上面,就用kqueue模型.</span></span><br><span class="line">    <span class="string">use</span> <span class="string">epoll;</span></span><br><span class="line">    <span class="comment">#单个进程最大连接数（最大连接数=连接数*进程数）</span></span><br><span class="line">    <span class="string">worker_connections</span> <span class="number">65535</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#设定http服务器</span></span><br><span class="line"><span class="string">http</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="string">include</span> <span class="string">mime.types;</span> <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="string">default_type</span> <span class="string">application/octet-stream;</span> <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="comment">#charset utf-8; #默认编码</span></span><br><span class="line">    <span class="string">server_names_hash_bucket_size</span> <span class="number">128</span><span class="string">;</span> <span class="comment">#服务器名字的hash表大小</span></span><br><span class="line">    <span class="string">client_header_buffer_size</span> <span class="number">32</span><span class="string">k;</span> <span class="comment">#上传文件大小限制</span></span><br><span class="line">    <span class="string">large_client_header_buffers</span> <span class="number">4</span> <span class="number">64</span><span class="string">k;</span> <span class="comment">#设定请求缓</span></span><br><span class="line">    <span class="string">client_max_body_size</span> <span class="number">8</span><span class="string">m;</span> <span class="comment">#设定请求缓</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启目录列表访问,合适下载服务器,默认关闭.</span></span><br><span class="line">    <span class="string">autoindex</span> <span class="string">on;</span> <span class="comment"># 显示目录</span></span><br><span class="line">    <span class="string">autoindex_exact_size</span> <span class="string">on;</span> <span class="comment"># 显示文件大小 默认为on,显示出文件的确切大小,单位是bytes 改为off后,显示出文件的大概大小,单位是kB或者MB或者GB</span></span><br><span class="line">    <span class="string">autoindex_localtime</span> <span class="string">on;</span> <span class="comment"># 显示文件时间 默认为off,显示的文件时间为GMT时间 改为on后,显示的文件时间为文件的服务器时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">sendfile</span> <span class="string">on;</span> <span class="comment"># 开启高效文件传输模式,sendfile指令指定nginx是否调用sendfile函数来输出文件,对于普通应用设为 on,如果用来进行下载等应用磁盘IO重负载应用,可设置为off,以平衡磁盘与网络I/O处理速度,降低系统的负载.注意：如果图片显示不正常把这个改成off.</span></span><br><span class="line">    <span class="string">tcp_nopush</span> <span class="string">on;</span> <span class="comment"># 防止网络阻塞</span></span><br><span class="line">    <span class="string">tcp_nodelay</span> <span class="string">on;</span> <span class="comment"># 防止网络阻塞</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">keepalive_timeout</span> <span class="number">120</span><span class="string">;</span> <span class="comment"># (单位s)设置客户端连接保持活动的超时时间,在超过这个时间后服务器会关闭该链接</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># FastCGI相关参数是为了改善网站的性能：减少资源占用,提高访问速度.下面参数看字面意思都能理解.</span></span><br><span class="line">    <span class="string">fastcgi_connect_timeout</span> <span class="number">300</span><span class="string">;</span></span><br><span class="line">    <span class="string">fastcgi_send_timeout</span> <span class="number">300</span><span class="string">;</span></span><br><span class="line">    <span class="string">fastcgi_read_timeout</span> <span class="number">300</span><span class="string">;</span></span><br><span class="line">    <span class="string">fastcgi_buffer_size</span> <span class="number">64</span><span class="string">k;</span></span><br><span class="line">    <span class="string">fastcgi_buffers</span> <span class="number">4</span> <span class="number">64</span><span class="string">k;</span></span><br><span class="line">    <span class="string">fastcgi_busy_buffers_size</span> <span class="number">128</span><span class="string">k;</span></span><br><span class="line">    <span class="string">fastcgi_temp_file_write_size</span> <span class="number">128</span><span class="string">k;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># gzip模块设置</span></span><br><span class="line">    <span class="string">gzip</span> <span class="string">on;</span> <span class="comment">#开启gzip压缩输出</span></span><br><span class="line">    <span class="string">gzip_min_length</span> <span class="number">1</span><span class="string">k;</span> <span class="comment">#允许压缩的页面的最小字节数,页面字节数从header偷得content-length中获取.默认是0,不管页面多大都进行压缩.建议设置成大于1k的字节数,小于1k可能会越压越大</span></span><br><span class="line">    <span class="string">gzip_buffers</span> <span class="number">4</span> <span class="number">16</span><span class="string">k;</span> <span class="comment">#表示申请4个单位为16k的内存作为压缩结果流缓存,默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果</span></span><br><span class="line">    <span class="string">gzip_http_version</span> <span class="number">1.1</span><span class="string">;</span> <span class="comment">#压缩版本（默认1.1,目前大部分浏览器已经支持gzip解压.前端如果是squid2.5请使用1.0）</span></span><br><span class="line">    <span class="string">gzip_comp_level</span> <span class="number">2</span><span class="string">;</span> <span class="comment">#压缩等级.1压缩比最小,处理速度快.9压缩比最大,比较消耗cpu资源,处理速度最慢,但是因为压缩比最大,所以包最小,传输速度快</span></span><br><span class="line">    <span class="string">gzip_types</span> <span class="string">text/plain</span> <span class="string">application/x-javascript</span> <span class="string">text/css</span> <span class="string">application/xml;</span></span><br><span class="line">    <span class="comment">#压缩类型,默认就已经包含text/html,所以下面就不用再写了,写上去也不会有问题,但是会有一个warn.</span></span><br><span class="line">    <span class="string">gzip_vary</span> <span class="string">on;#选项可以让前端的缓存服务器缓存经过gzip压缩的页面.例如:用squid缓存经过nginx压缩的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#开启限制IP连接数的时候需要使用</span></span><br><span class="line">    <span class="comment">#limit_zone crawler $binary_remote_addr 10m;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##upstream的负载均衡,四种调度算法(下例主讲)##</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#虚拟主机的配置</span></span><br><span class="line">    <span class="string">server</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="comment"># 监听端口</span></span><br><span class="line">        <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">        <span class="comment"># 域名可以有多个,用空格隔开</span></span><br><span class="line">        <span class="string">server_name</span> <span class="string">ably.com;</span></span><br><span class="line">        <span class="comment"># HTTP 自动跳转 HTTPS</span></span><br><span class="line">        <span class="string">rewrite</span> <span class="string">^(.*)</span> <span class="attr">https://$server_name$1</span> <span class="string">permanent;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">server</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="comment"># 监听端口 HTTPS</span></span><br><span class="line">        <span class="string">listen</span> <span class="number">443</span> <span class="string">ssl;</span></span><br><span class="line">        <span class="string">server_name</span> <span class="string">ably.com;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 配置域名证书</span></span><br><span class="line">        <span class="string">ssl_certificate</span>      <span class="attr">C:\WebServer\Certs\certificate.crt;</span></span><br><span class="line">        <span class="string">ssl_certificate_key</span>  <span class="attr">C:\WebServer\Certs\private.key;</span></span><br><span class="line">        <span class="string">ssl_session_cache</span>    <span class="attr">shared:SSL:1m;</span></span><br><span class="line">        <span class="string">ssl_session_timeout</span>  <span class="number">5</span><span class="string">m;</span></span><br><span class="line">        <span class="string">ssl_protocols</span> <span class="string">SSLv2</span> <span class="string">SSLv3</span> <span class="string">TLSv1;</span></span><br><span class="line">        <span class="string">ssl_ciphers</span> <span class="attr">ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;</span></span><br><span class="line">        <span class="string">ssl_prefer_server_ciphers</span>  <span class="string">on;</span></span><br><span class="line">    </span><br><span class="line">        <span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm</span> <span class="string">index.php;</span></span><br><span class="line">        <span class="string">root</span> <span class="string">/data/www/;</span></span><br><span class="line">        <span class="string">location</span> <span class="string">~</span> <span class="string">.*\.(php|php5)?$</span></span><br><span class="line">        <span class="string">&#123;</span></span><br><span class="line">            <span class="string">fastcgi_pass</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9000;</span></span><br><span class="line">            <span class="string">fastcgi_index</span> <span class="string">index.php;</span></span><br><span class="line">            <span class="string">include</span> <span class="string">fastcgi.conf;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 配置地址拦截转发，解决跨域验证问题</span></span><br><span class="line">        <span class="string">location</span> <span class="string">/oauth/&#123;</span></span><br><span class="line">            <span class="string">proxy_pass</span> <span class="attr">https://localhost:13580/oauth/;</span></span><br><span class="line">            <span class="string">proxy_set_header</span> <span class="string">HOST</span> <span class="string">$host;</span></span><br><span class="line">            <span class="string">proxy_set_header</span> <span class="string">X-Real-IP</span> <span class="string">$remote_addr;</span></span><br><span class="line">            <span class="string">proxy_set_header</span> <span class="string">X-Forwarded-For</span> <span class="string">$proxy_add_x_forwarded_for;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 图片缓存时间设置</span></span><br><span class="line">        <span class="string">location</span> <span class="string">~</span> <span class="string">.*\.(gif|jpg|jpeg|png|bmp|swf)$</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">expires</span> <span class="number">10</span><span class="string">d;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># JS和CSS缓存时间设置</span></span><br><span class="line">        <span class="string">location</span> <span class="string">~</span> <span class="string">.*\.(js|css)?$</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">expires</span> <span class="number">1</span><span class="string">h;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 日志格式设定</span></span><br><span class="line">        <span class="string">log_format</span> <span class="string">access</span> <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">        <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">        <span class="string">'"$http_user_agent" $http_x_forwarded_for'</span><span class="string">;</span></span><br><span class="line">        <span class="comment"># 定义本虚拟主机的访问日志</span></span><br><span class="line">        <span class="string">access_log</span> <span class="string">/var/log/nginx/access.log</span> <span class="string">access;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设定查看Nginx状态的地址.StubStatus模块能够获取Nginx自上次启动以来的工作状态，此模块非核心模块，需要在Nginx编译安装时手工指定才能使用</span></span><br><span class="line">        <span class="string">location</span> <span class="string">/NginxStatus</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">stub_status</span> <span class="string">on;</span></span><br><span class="line">            <span class="string">access_log</span> <span class="string">on;</span></span><br><span class="line">            <span class="string">auth_basic</span> <span class="string">"NginxStatus"</span><span class="string">;</span></span><br><span class="line">            <span class="string">auth_basic_user_file</span> <span class="string">conf/htpasswd;</span></span><br><span class="line">            <span class="comment">#htpasswd文件的内容可以用apache提供的htpasswd工具来产生.</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Nginx多台服务器实现负载均衡："><a href="#Nginx多台服务器实现负载均衡：" class="headerlink" title="Nginx多台服务器实现负载均衡："></a>Nginx多台服务器实现负载均衡：</h2><p>1.Nginx负载均衡服务器：<br>IP：192.168.0.4（Nginx-Server）</p>
<p>2.Web服务器列表：<br>Web1:192.168.0.5（Nginx-Node1/Nginx-Web1） ；Web2:192.168.0.7（Nginx-Node2/Nginx-Web2）</p>
<p>3.实现目的：用户访问Nginx-Server（mongo.demo.com:8888）时，通过Nginx负载均衡到Web1和Web2服务器</p>
<p>Nginx负载均衡服务器的nginx.conf配置注释如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">events</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="string">use</span> <span class="string">epoll;</span></span><br><span class="line">    <span class="string">worker_connections</span> <span class="number">65535</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">http</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="comment">##upstream的负载均衡,四种调度算法##</span></span><br><span class="line">    <span class="comment">#调度算法1:轮询.每个请求按时间顺序逐一分配到不同的后端服务器,如果后端某台服务器宕机,故障系统被自动剔除,使用户访问不受影响</span></span><br><span class="line">    <span class="string">upstream</span> <span class="string">webhost</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">server</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span><span class="string">:6666</span> <span class="string">;</span></span><br><span class="line">        <span class="string">server</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.7</span><span class="string">:6666</span> <span class="string">;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="comment">#调度算法2:weight(权重).可以根据机器配置定义权重.权重越高被分配到的几率越大</span></span><br><span class="line">    <span class="string">upstream</span> <span class="string">webhost</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">server</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span><span class="string">:6666</span> <span class="string">weight=2;</span></span><br><span class="line">        <span class="string">server</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.7</span><span class="string">:6666</span> <span class="string">weight=3;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="comment">#调度算法3:ip_hash. 每个请求按访问IP的hash结果分配,这样来自同一个IP的访客固定访问一个后端服务器,有效解决了动态网页存在的session共享问题</span></span><br><span class="line">    <span class="string">upstream</span> <span class="string">webhost</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">ip_hash;</span></span><br><span class="line">        <span class="string">server</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span><span class="string">:6666</span> <span class="string">;</span></span><br><span class="line">        <span class="string">server</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.7</span><span class="string">:6666</span> <span class="string">;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="comment">#调度算法4:url_hash(需安装第三方插件).此方法按访问url的hash结果来分配请求,使每个url定向到同一个后端服务器,可以进一步提高后端缓存服务器的效率.Nginx本身是不支持url_hash的,如果需要使用这种调度算法,必须安装Nginx 的hash软件包</span></span><br><span class="line">    <span class="string">upstream</span> <span class="string">webhost</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">server</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span><span class="string">:6666</span> <span class="string">;</span></span><br><span class="line">        <span class="string">server</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.7</span><span class="string">:6666</span> <span class="string">;</span></span><br><span class="line">        <span class="string">hash</span> <span class="string">$request_uri;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="comment">#调度算法5:fair(需安装第三方插件).这是比上面两个更加智能的负载均衡算法.此种算法可以依据页面大小和加载时间长短智能地进行负载均衡,也就是根据后端服务器的响应时间来分配请求,响应时间短的优先分配.Nginx本身是不支持fair的,如果需要使用这种调度算法,必须下载Nginx的upstream_fair模块</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#虚拟主机的配置(采用调度算法3:ip_hash)</span></span><br><span class="line">    <span class="string">server</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">        <span class="string">server_name</span> <span class="string">mongo.demo.com;</span></span><br><span class="line">        <span class="comment">#对 "/" 启用反向代理</span></span><br><span class="line">        <span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">proxy_pass</span> <span class="attr">http://webhost;</span></span><br><span class="line">            <span class="string">proxy_redirect</span> <span class="string">off;</span></span><br><span class="line">            <span class="string">proxy_set_header</span> <span class="string">X-Real-IP</span> <span class="string">$remote_addr;</span></span><br><span class="line">            <span class="comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span></span><br><span class="line">            <span class="string">proxy_set_header</span> <span class="string">X-Forwarded-For</span> <span class="string">$proxy_add_x_forwarded_for;</span></span><br><span class="line">            <span class="comment">#以下是一些反向代理的配置,可选.</span></span><br><span class="line">            <span class="string">proxy_set_header</span> <span class="string">Host</span> <span class="string">$host;</span></span><br><span class="line">            <span class="string">client_max_body_size</span> <span class="number">10</span><span class="string">m;</span> <span class="comment">#允许客户端请求的最大单文件字节数</span></span><br><span class="line">            <span class="string">client_body_buffer_size</span> <span class="number">128</span><span class="string">k;</span> <span class="comment">#缓冲区代理缓冲用户端请求的最大字节数,</span></span><br><span class="line">            <span class="string">proxy_connect_timeout</span> <span class="number">90</span><span class="string">;</span> <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class="line">            <span class="string">proxy_send_timeout</span> <span class="number">90</span><span class="string">;</span> <span class="comment">#后端服务器数据回传时间(代理发送超时)</span></span><br><span class="line">            <span class="string">proxy_read_timeout</span> <span class="number">90</span><span class="string">;</span> <span class="comment">#连接成功后,后端服务器响应时间(代理接收超时)</span></span><br><span class="line">            <span class="string">proxy_buffer_size</span> <span class="number">4</span><span class="string">k;</span> <span class="comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class="line">            <span class="string">proxy_buffers</span> <span class="number">4</span> <span class="number">32</span><span class="string">k;</span> <span class="comment">#proxy_buffers缓冲区,网页平均在32k以下的设置</span></span><br><span class="line">            <span class="string">proxy_busy_buffers_size</span> <span class="number">64</span><span class="string">k;</span> <span class="comment">#高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class="line">            <span class="string">proxy_temp_file_write_size</span> <span class="number">64</span><span class="string">k;</span></span><br><span class="line">            <span class="comment">#设定缓存文件夹大小,大于这个值,将从upstream服务器传</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>负载均衡操作演示如下：</p>
<p>操作对象：192.168.0.4（Nginx-Server）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹准备存放配置文件</span></span><br><span class="line"><span class="string">$</span> <span class="string">mkdir</span> <span class="bullet">-p</span> <span class="string">/opt/confs</span></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">/opt/confs/nginx.conf</span></span><br><span class="line"><span class="comment"># 编辑内容如下：</span></span><br><span class="line"><span class="string">events</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="string">use</span> <span class="string">epoll;</span></span><br><span class="line">  <span class="string">worker_connections</span> <span class="number">65535</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">http</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="string">upstream</span> <span class="string">webhost</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">ip_hash;</span></span><br><span class="line">        <span class="string">server</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span><span class="string">:6666</span> <span class="string">;</span></span><br><span class="line">        <span class="string">server</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.7</span><span class="string">:6666</span> <span class="string">;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">server</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">        <span class="string">server_name</span> <span class="string">mongo.demo.com;</span></span><br><span class="line">        <span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">proxy_pass</span> <span class="attr">http://webhost;</span></span><br><span class="line">            <span class="string">proxy_redirect</span> <span class="string">off;</span></span><br><span class="line">            <span class="string">proxy_set_header</span> <span class="string">X-Real-IP</span> <span class="string">$remote_addr;</span></span><br><span class="line">            <span class="string">proxy_set_header</span> <span class="string">X-Forwarded-For</span> <span class="string">$proxy_add_x_forwarded_for;</span></span><br><span class="line">            <span class="string">proxy_set_header</span> <span class="string">Host</span> <span class="string">$host;</span></span><br><span class="line">            <span class="string">client_max_body_size</span> <span class="number">10</span><span class="string">m;</span></span><br><span class="line">            <span class="string">client_body_buffer_size</span> <span class="number">128</span><span class="string">k;</span></span><br><span class="line">            <span class="string">proxy_connect_timeout</span> <span class="number">90</span><span class="string">;</span></span><br><span class="line">            <span class="string">proxy_send_timeout</span> <span class="number">90</span><span class="string">;</span></span><br><span class="line">            <span class="string">proxy_read_timeout</span> <span class="number">90</span><span class="string">;</span></span><br><span class="line">            <span class="string">proxy_buffer_size</span> <span class="number">4</span><span class="string">k;</span></span><br><span class="line">            <span class="string">proxy_buffers</span> <span class="number">4</span> <span class="number">32</span><span class="string">k;</span></span><br><span class="line">            <span class="string">proxy_busy_buffers_size</span> <span class="number">64</span><span class="string">k;</span></span><br><span class="line">            <span class="string">proxy_temp_file_write_size</span> <span class="number">64</span><span class="string">k;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="comment"># 然后保存并退出</span></span><br><span class="line"><span class="comment"># 启动负载均衡服务器192.168.0.4（Nginx-Server）</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="bullet">-d</span> <span class="bullet">-p</span> <span class="number">8888</span><span class="string">:80</span> <span class="bullet">--name</span> <span class="string">nginx-server</span> <span class="bullet">-v</span> <span class="string">/opt/confs/nginx.conf:/etc/nginx/nginx.conf</span> <span class="bullet">--restart</span> <span class="string">always</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>操作对象：192.168.0.5（Nginx-Node1/Nginx-Web1）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹用于存放web页面</span></span><br><span class="line"><span class="string">$</span> <span class="string">mkdir</span> <span class="bullet">-p</span> <span class="string">/opt/html</span></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">/opt/html/index.html</span></span><br><span class="line"><span class="comment"># 编辑内容如下：</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line">    <span class="string">&lt;h1&gt;</span></span><br><span class="line">        <span class="string">The</span> <span class="string">host</span> <span class="string">is</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span><span class="string">(Docker02)</span> <span class="bullet">-</span> <span class="string">Node</span> <span class="number">1</span><span class="string">!</span></span><br><span class="line">    <span class="string">&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="comment"># 然后保存并退出</span></span><br><span class="line"><span class="comment"># 启动192.168.0.5（Nginx-Node1/Nginx-Web1）</span></span><br><span class="line"><span class="string">$</span> <span class="string">docker</span> <span class="string">run</span> <span class="bullet">-d</span> <span class="bullet">-p</span> <span class="number">6666</span><span class="string">:80</span> <span class="bullet">--name</span> <span class="string">nginx-node1</span> <span class="bullet">-v</span> <span class="string">/opt/html:/usr/share/nginx/html</span> <span class="bullet">--restart</span> <span class="string">always</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>操作对象：192.168.0.7（Nginx-Node2/Nginx-Web2）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹用于存放web页面</span></span><br><span class="line"><span class="string">$</span> <span class="string">mkdir</span> <span class="bullet">-p</span> <span class="string">/opt/html</span></span><br><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">/opt/html/index.html</span></span><br><span class="line"><span class="comment"># 编辑内容如下：</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line">  <span class="string">&lt;h1&gt;</span></span><br><span class="line">    <span class="string">The</span> <span class="string">host</span> <span class="string">is</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.7</span><span class="string">(Docker03)</span> <span class="bullet">-</span> <span class="string">Node</span> <span class="number">2</span><span class="string">!</span></span><br><span class="line">  <span class="string">&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="comment"># 然后保存并退出</span></span><br><span class="line"><span class="comment"># 启动192.168.0.7（Nginx-Node2/Nginx-Web2）</span></span><br><span class="line"><span class="string">$</span> <span class="string">docker</span> <span class="string">run</span> <span class="bullet">-d</span> <span class="bullet">-p</span> <span class="number">6666</span><span class="string">:80</span> <span class="bullet">--name</span> <span class="string">nginx-node2</span> <span class="bullet">-v</span> <span class="string">$(pwd)/html:/usr/share/nginx/html</span> <span class="bullet">--restart</span> <span class="string">always</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth 2.0 的四种方式</title>
    <url>/2021/07/01/OAuth-2-0-%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>OAuth 2.0 的四种方式</strong></p>
<p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">上一篇文章</a>介绍了 OAuth 2.0 是一种授权机制，主要用来颁发令牌（token）。本文接着介绍颁发令牌的实务操作。</p>
<p><img src="https://images.codeflag.cn/g2019040901.jpeg" alt="img"></p>
<p>下面我假定，你已经理解了 OAuth 2.0 的含义和设计思想，否则请先阅读这个系列的<a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">上一篇文章</a>。</p>
<a id="more"></a>

<p><strong>RFC 6749</strong></p>
<p>OAuth 2.0 的标准是 <a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">RFC 6749</a> 文件。该文件先解释了 OAuth 是什么。</p>
<p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p>
<p>这段话的意思就是，<strong>OAuth 的核心就是向第三方应用颁发令牌。</strong>然后，RFC 6749 接着写道：</p>
<p>（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。</p>
<p>也就是说，<strong>OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。</strong>下面就是这四种授权方式。</p>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）：</li>
<li>客户端凭证（client credentials）</li>
</ul>
<p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p>
<p><strong>第一种授权方式：授权码</strong></p>
<p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p>
<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p>
<p><a href="https://b.com/oauth/authorize" target="_blank" rel="noopener">https://b.com/oauth/authorize</a>?  response_type=code&amp;  client_id=CLIENT_ID&amp;  redirect_uri=CALLBACK_URL&amp;  scope=read</p>
<p>上面 URL 中，response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。</p>
<p><img src="https://images.codeflag.cn/g2019040902.jpeg" alt="img"></p>
<p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p>
<p><a href="https://a.com/callback?code=AUTHORIZATION_CODE" target="_blank" rel="noopener">https://a.com/callback?code=AUTHORIZATION_CODE</a></p>
<p>上面 URL 中，code参数就是授权码。</p>
<p><img src="https://images.codeflag.cn/g2019040907.jpeg" alt="img"></p>
<p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p>
<p><a href="https://b.com/oauth/token" target="_blank" rel="noopener">https://b.com/oauth/token</a>? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL</p>
<p>上面 URL 中，client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。</p>
<p><img src="https://images.codeflag.cn/g2019040904.jpeg" alt="img"></p>
<p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。</p>
<p>{      “access_token”:”ACCESS_TOKEN”,  “token_type”:”bearer”,  “expires_in”:2592000,  “refresh_token”:”REFRESH_TOKEN”,  “scope”:”read”,  “uid”:100101,  “info”:{…} }</p>
<p>上面 JSON 数据中，access_token字段就是令牌，A 网站在后端拿到了。</p>
<p><img src="https://images.codeflag.cn/g2019040905.jpeg" alt="img"></p>
<p><strong>第二种方式：隐藏式</strong></p>
<p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p>
<p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p>
<p><a href="https://b.com/oauth/authorize" target="_blank" rel="noopener">https://b.com/oauth/authorize</a>?  response_type=token&amp;  client_id=CLIENT_ID&amp;  redirect_uri=CALLBACK_URL&amp;  scope=read</p>
<p>上面 URL 中，response_type参数为token，表示要求直接返回令牌。</p>
<p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p>
<p><a href="https://a.com/callback#token=ACCESS_TOKEN" target="_blank" rel="noopener">https://a.com/callback#token=ACCESS_TOKEN</a></p>
<p>上面 URL 中，token参数就是令牌，A 网站因此直接在前端拿到令牌。</p>
<p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p>
<p><img src="https://images.codeflag.cn/g2019040906.jpeg" alt="img"></p>
<p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p>
<p><strong>第三种方式：密码式</strong></p>
<p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p>
<p>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p>
<p><a href="https://oauth.b.com/token" target="_blank" rel="noopener">https://oauth.b.com/token</a>?  grant_type=password&amp;  username=USERNAME&amp;  password=PASSWORD&amp;  client_id=CLIENT_ID</p>
<p>上面 URL 中，grant_type参数是授权方式，这里的password表示”密码式”，username和password是 B 的用户名和密码。</p>
<p>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p>
<p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p>
<p><strong>第四种方式：凭证式</strong></p>
<p><strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong></p>
<p>第一步，A 应用在命令行向 B 发出请求。</p>
<p><a href="https://oauth.b.com/token" target="_blank" rel="noopener">https://oauth.b.com/token</a>?  grant_type=client_credentials&amp;  client_id=CLIENT_ID&amp;  client_secret=CLIENT_SECRET</p>
<p>上面 URL 中，grant_type参数等于client_credentials表示采用凭证式，client_id和client_secret用来让 B 确认 A 的身份。</p>
<p>第二步，B 网站验证通过以后，直接返回令牌。</p>
<p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p>
<p><strong>令牌的使用</strong></p>
<p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p>
<p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。</p>
<p>curl -H “Authorization: Bearer ACCESS_TOKEN” \ “<a href="https://api.b.com&quot;" target="_blank" rel="noopener">https://api.b.com&quot;</a></p>
<p>上面命令中，ACCESS_TOKEN就是拿到的令牌。</p>
<p><strong>更新令牌</strong></p>
<p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p>
<p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p>
<p><a href="https://b.com/oauth/token" target="_blank" rel="noopener">https://b.com/oauth/token</a>?  grant_type=refresh_token&amp;  client_id=CLIENT_ID&amp;  client_secret=CLIENT_SECRET&amp;  refresh_token=REFRESH_TOKEN</p>
<p>上面 URL 中，grant_type参数为refresh_token表示要求更新令牌，client_id参数和client_secret参数用于确认身份，refresh_token参数就是用于更新令牌的令牌。</p>
<p>B 网站验证通过以后，就会颁发新的令牌。</p>
<p>写到这里，颁发令牌的四种方式就介绍完了。<a href="http://www.ruanyifeng.com/blog/2019/04/github-oauth.html" target="_blank" rel="noopener">下一篇文章</a>会编写一个真实的 Demo，演示如何通过 OAuth 2.0 向 GitHub 的 API 申请令牌，然后再用令牌获取数据。</p>
<p>作者： <a href="http://www.ruanyifeng.com" target="_blank" rel="noopener">阮一峰</a></p>
<p>（正文完）</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyinstall详解</title>
    <url>/2019/11/07/Pyinstall%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>当我们希望将自己编写好的程序传送给他人使用时，如果对方没有安装 Python 环境就无法使用程序了，我们难以让每个使用者都安装 Python 环境，是否可以在不必安装 Python 环境的前提下使用 Python 程序呢🤔？</p>
<p>可以使用 Pyinstaller 将程序打包，然后再分享给其他人使用，他人使用只需双击运行打包好的程序。</p>
<a id="more"></a>
<p>可以通过 pip 来安装，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>pyinstaller 最重要的两个参数就是 -F 与 -D 参数。</p>
<p>使用 - F 参数， pyinstaller 会将 python 程序打包成单个可执行文件。</p>
<p>使用 - D 参数， pyinstaller 会将 python 程序打包成一个文件夹，运行程序时，需要进入该文件夹，点击运行相应的可执行程序。</p>
<p>为了美观，还可以通过 - i 参数指定打包程序的图标 (icon)，但这个命令只能在 Windows 平台下生效，此外还可以使用 - n 参数指定生成打包文件的名称。</p>
<p>如果你使用了 PyQt5 或 tkinter 开发了界面，通常不会希望程序运行时弹出 cmd 命令行，此时就可以使用 - w 参数。</p>
<p>🙂简单总结一下：</p>
<p>-F：打包 Python 程序为单个可执行文件 -D：打包 Python 程序为一个文件夹 -i：生成图标，只适用于 Windows 平台 -n：指定打包后生成文件的名称 -w：禁止命令行弹出</p>
<p>综上所述，最常见的命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyinstaller -i xxx.ico -n xxx -w -D xxx.py</span><br></pre></td></tr></table></figure>

<p>-i 参数后必须接 .ico 结尾的图标文件 -D 或 -F 后必须接 python 程序的入库程序，常见情况为 main.py</p>
<p>对应依赖比较多的程序，建议使用 -D， -F 更适合单文件的 py 脚本。</p>
<h3 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h3><p>打包时，pyinstaller 此时会生成相应的 spec 文件，大体流程如下：</p>
<p>🚀1、在脚本目录生成 xxx.spec 文件 (取决于 -n 参数，没传，则与 xxx.py 同名为 xxx)；</p>
<p>🚀2、创建一个 build 目录；</p>
<p>🚀3、写入一些日志文件和中间流程文件到 build 目录；</p>
<p>🚀4、创建 dist 目录；</p>
<p>🚀5、生成可执行文件或文件夹到 dist 目录；</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Pyinstaller 是跨平台的，但并不是指其生成应用是跨平台的，而是 Pyinstaller 本身是跨平台的，在 Windows 平台下，可以打包出 exe 文件。</p>
<p>👹避免打包后，包文件过大</p>
<p>为了避免 Pyinstaller 打包后程序或文件夹过大，如：几百 KB 的程序打包后编程 500M 左右的程序，在引用包时，尽量使用 from … import … 语句，这是因为 Pyinstaller 打包的路径其实是将 python 解释器以及项目中使用的库直接复制过来，所以如果你没事就别 import… ，那么 Pyinstaller 会将整个模块复制过去，此时打出来的包就会很大。</p>
<p>👹考虑路径问题</p>
<p>使用 python 时，要养成使用 os.path.join 的习惯，这不仅可以避免跨平台的路径坑 (windows 路径表达与类 Unix 是不同)，又可以在打包时不会出现相对路径的问题，很多 python 程序员编写路径喜欢使用 + 号来链接路径，这会增加项目的维护成本</p>
<p>pyinstaller 打包的项目遇到路径都使用 os.path.join 则可</p>
<p>👹外部数据问题</p>
<p>虽然在上节中，提及了使用外部数据时，可以自定义 spec 文件中的 datas 字段，但我更常用的做法是直接将数据复制过去，不去修改 datas。</p>
<p>比如我的项目中依赖 config 文件夹下的配置文件，执行将 config 文件夹整体直接复制到打包好的文件夹中则可</p>
<p>👹闪屏结束</p>
<p>如果是简单的程序，可能会出现运行可执行程序后出现一闪而过的情况，这种情况下要么是程序运行结束（比如直接打印的 helloWorld），要么程序出现错误退出了。</p>
<p>这种情况要么通过 input () 函数捕捉输入自己主动结束程序，要么就在 cmd 下运行 exe 文件，从而通过 cmd 看到效果</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>掌握了 Pyinstaller 后，你就可以将任意程序打包发送给他人了，最后欢迎学习 HackPython 的教学课程并感觉您的阅读与支持。</p>
<p>👋👋</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python asyncio协程学习</title>
    <url>/2020/06/04/Python-asyncio%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>不知道你是否发现，身边聊异步的人越来越多了，比如：FastAPI、Tornado、Sanic、Django 3、aiohttp等。<br>听说异步如何如何牛逼？性能如何吊炸天。。。。但他到底是咋回事呢？ </p>
<p>本节要跟大家一起聊聊关于asyncio异步的那些事！<br>asyncio讲解教程：<a href="https://study.163.com/instructor/3525856.htm" target="_blank" rel="noopener">https://study.163.com/instructor/3525856.htm</a><br>博客园同步：<a href="https://www.cnblogs.com/wupeiqi/" target="_blank" rel="noopener">https://www.cnblogs.com/wupeiqi/</a></p>
</blockquote>
<h2 id="1-协程"><a href="#1-协程" class="headerlink" title="1.协程"></a>1.协程</h2><blockquote>
<p>想学asyncio，得先了解协程，协程是根本呀！<br>协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现代码块相互切换执行。例如：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line">    ...</span><br><span class="line">    print(<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    ...</span><br><span class="line">    print(<span class="number">4</span>)</span><br><span class="line">func1()</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>上述代码是普通的函数定义和执行，按流程分别执行两个函数中的代码，并先后会输出：<code>1、2、3、4</code>。但如果介入协程技术那么就可以实现函数见代码切换执行，最终输入：<code>1、3、2、4</code> 。  </p>
<p>在Python中有多种方式可以实现协程，例如：  </p>
<ul>
<li>greenlet，是一个第三方模块，用于实现协程代码（Gevent协程就是基于greenlet实现）  </li>
<li>yield，生成器，借助生成器的特点也可以实现协程代码。  </li>
<li>asyncio，在Python3.4中引入的模块用于编写协程代码。  </li>
<li>async &amp; awiat，在Python3.5中引入的两个关键字，结合asyncio模块可以更方便的编写协程代码。</li>
</ul>
</blockquote>
<h3 id="1-1-greenlet"><a href="#1-1-greenlet" class="headerlink" title="1.1 greenlet"></a>1.1 greenlet</h3><blockquote>
<p>greentlet是一个第三方模块，需要提前安装 <code>pip3 install greenlet</code>才能使用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1</span>)        <span class="comment"># 第2步：输出 1</span></span><br><span class="line">    gr2.switch()    <span class="comment"># 第3步：切换到 func2 函数</span></span><br><span class="line">    print(<span class="number">2</span>)        <span class="comment"># 第6步：输出 2</span></span><br><span class="line">    gr2.switch()    <span class="comment"># 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">3</span>)        <span class="comment"># 第4步：输出 3</span></span><br><span class="line">    gr1.switch()    <span class="comment"># 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line">    print(<span class="number">4</span>)        <span class="comment"># 第8步：输出 4</span></span><br><span class="line">gr1 = greenlet(func1)</span><br><span class="line">gr2 = greenlet(func2)</span><br><span class="line">gr1.switch()        <span class="comment"># 第1步：去执行 func1 函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：switch中也可以传递参数用于在切换执行时相互传递值。</p>
</blockquote>
<h3 id="1-2-yield"><a href="#1-2-yield" class="headerlink" title="1.2 yield"></a>1.2 yield</h3><blockquote>
<p>基于Python的生成器的yield和yield form关键字实现协程代码。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> func2()</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">f1 = func1()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f1:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：yield form关键字是在Python3.3中引入的。</p>
</blockquote>
<h3 id="1-3-asyncio"><a href="#1-3-asyncio" class="headerlink" title="1.3 asyncio"></a>1.3 asyncio</h3><blockquote>
<p>在Python3.4之前官方未提供协程的类库，一般大家都是使用greenlet等其他来实现。在Python3.4发布后官方正式支持协程，即：asyncio模块。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务</span></span><br><span class="line">    print(<span class="number">2</span>)</span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务</span></span><br><span class="line">    print(<span class="number">4</span>)</span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future( func1() ),</span><br><span class="line">    asyncio.ensure_future( func2() )</span><br><span class="line">]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>

<pre><code>1
3
2
4
({&lt;Task finished coro=&lt;func1() done, defined at &lt;ipython-input-3-1dbe3490c41e&gt;:5&gt; result=None&gt;,
  &lt;Task finished coro=&lt;func2() done, defined at &lt;ipython-input-3-1dbe3490c41e&gt;:10&gt; result=None&gt;},
 set())</code></pre><blockquote>
<p>注意：基于asyncio模块实现的协程比之前的要更厉害，因为他的内部还集成了遇到IO耗时操作自动切花的功能。</p>
</blockquote>
<h3 id="1-4-async-amp-awit"><a href="#1-4-async-amp-awit" class="headerlink" title="1.4 async &amp; awit"></a>1.4 async &amp; awit</h3><blockquote>
<p>async &amp; awit 关键字在Python3.5版本中正式引入，基于他编写的协程代码其实就是 上一示例 的加强版，让代码可以更加简便。<br>Python3.8之后 <code>@asyncio.coroutine</code> 装饰器就会被移除，推荐使用async &amp; awit 关键字实现协程代码。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="number">4</span>)</span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(func1()),</span><br><span class="line">    asyncio.ensure_future(func2())</span><br><span class="line">]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>

<pre><code>1
3
2
4
({&lt;Task finished coro=&lt;func1() done, defined at &lt;ipython-input-4-3cb45ff996e6&gt;:5&gt; result=None&gt;,
  &lt;Task finished coro=&lt;func2() done, defined at &lt;ipython-input-4-3cb45ff996e6&gt;:9&gt; result=None&gt;},
 set())</code></pre><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><blockquote>
<p>关于协程有多种实现方式，目前主流使用是Python官方推荐的asyncio模块和async&amp;await关键字的方式，例如：在tonado、sanic、fastapi、django3 中均已支持。  </p>
<p>接下来，我们也会针对 <code>asyncio模块</code> + <code>async &amp; await</code> 关键字进行更加详细的讲解。</p>
</blockquote>
<h2 id="2-协程的意义"><a href="#2-协程的意义" class="headerlink" title="2.协程的意义"></a>2.协程的意义</h2><blockquote>
<p>通过学习，我们已经了解到协程可以通过一个线程在多个上下文中进行来回切换执行。  </p>
<p><strong>但是</strong>，协程来回切换执行的意义何在呢？（网上看到很多文章舔协程，协程牛逼之处是哪里呢？）  </p>
</blockquote>
<blockquote>
<p>计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。</p>
</blockquote>
<h3 id="2-1-爬虫案例"><a href="#2-1-爬虫案例" class="headerlink" title="2.1 爬虫案例"></a>2.1 爬虫案例</h3><blockquote>
<p>例如：用代码实现下载 <code>url_list</code> 中的图片。</p>
</blockquote>
<p><strong>- 方式一：同步编程实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">下载图片使用第三方模块requests，请提前安装：pip3 install requests</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_image</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"开始下载:"</span>,url)</span><br><span class="line">    <span class="comment"># 发送网络请求，下载图片</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    print(<span class="string">"下载完成"</span>)</span><br><span class="line">    <span class="comment"># 图片保存到本地文件</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">'_'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">with</span> open(file_name, mode=<span class="string">'wb'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">        file_object.write(response.content)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg'</span>,</span><br><span class="line">        <span class="string">'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg'</span>,</span><br><span class="line">        <span class="string">'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg'</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> url_list:</span><br><span class="line">        download_image(item)</span><br></pre></td></tr></table></figure>

<pre><code>开始下载: https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg
下载完成
AAFocMs8nzU621.jpg
开始下载: https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg
下载完成
ChcCSV2BBICAUntfAADjJFd6800429.jpg
开始下载: https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg
下载完成
ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg
Wall time: 260 ms</code></pre><p><strong>- 方式二：基于协程的异步编程实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">下载图片使用第三方模块aiohttp，请提前安装：pip3 install aiohttp</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(session, url)</span>:</span></span><br><span class="line">    print(<span class="string">"发送请求："</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.content.read()</span><br><span class="line">        file_name = url.rsplit(<span class="string">'_'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">with</span> open(file_name, mode=<span class="string">'wb'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">            file_object.write(content)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg'</span>,</span><br><span class="line">            <span class="string">'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg'</span>,</span><br><span class="line">            <span class="string">'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg'</span></span><br><span class="line">        ]</span><br><span class="line">        tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<pre><code>发送请求： https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg
发送请求： https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg
发送请求： https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg
ChcCSV2BBICAUntfAADjJFd6800429.jpg
AAFocMs8nzU621.jpg
ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg
Wall time: 50 ms</code></pre><blockquote>
<p>上述两种的执行对比之后会发现，<code>基于协程的异步编程</code> 要比 <code>同步编程</code>的效率高了很多。因为：  </p>
<ul>
<li>同步编程，按照顺序逐一排队执行，如果图片下载时间为2分钟，那么全部执行完则需要6分钟。  </li>
<li>异步编程，几乎同时发出了3个下载任务的请求（遇到IO请求自动切换去发送其他任务请求），如果图片下载时间为2分钟，那么全部执行完毕也大概需要2分钟左右就可以了。</li>
</ul>
</blockquote>
<h3 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h3><blockquote>
<p>协程一般应用在有IO操作的程序中，因为协程可以利用IO等待的时间去执行一些其他的代码，从而提升代码执行效率。  </p>
<p>生活中不也是这样的么，假设 你是一家制造汽车的老板，员工点击设备的【开始】按钮之后，在设备前需等待30分钟，然后点击【结束】按钮，此时作为老板的你一定希望这个员工在等待的那30分钟的时间去做点其他的工作。</p>
</blockquote>
<h2 id="3-异步编程"><a href="#3-异步编程" class="headerlink" title="3.异步编程"></a>3.异步编程</h2><blockquote>
<p>基于<code>async</code> &amp; <code>await</code>关键字的协程可以实现异步编程，这也是目前python异步相关的主流技术。  </p>
<p>想要真正的了解Python中内置的异步编程，根据下文的顺序一点点来看。</p>
</blockquote>
<h3 id="3-1-事件循环"><a href="#3-1-事件循环" class="headerlink" title="3.1 事件循环"></a>3.1 事件循环</h3><blockquote>
<p>事件循环，可以把他当做是一个while循环，这个while循环在周期性的运行并执行一些<code>任务</code>，在特定条件下终止循环。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line">任务列表 = [ 任务<span class="number">1</span>, 任务<span class="number">2</span>, 任务<span class="number">3</span>,... ]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有的任务，将<span class="string">'可执行'</span>和<span class="string">'已完成'</span>的任务返回</span><br><span class="line">    <span class="keyword">for</span> 就绪任务 <span class="keyword">in</span> 已准备就绪的任务列表:</span><br><span class="line">        执行已就绪的任务</span><br><span class="line">    <span class="keyword">for</span> 已完成的任务 <span class="keyword">in</span> 已完成的任务列表:</span><br><span class="line">        在任务列表中移除 已完成的任务</span><br><span class="line">    如果 任务列表 中的任务都已完成，则终止循环</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在编写程序时候可以通过如下代码来获取和创建事件循环。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line">loop = asyncio.get_event_loop()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-协程和异步编程"><a href="#3-2-协程和异步编程" class="headerlink" title="3.2 协程和异步编程"></a>3.2 协程和异步编程</h3><blockquote>
<p>协程函数，定义形式为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 的函数。 </p>
<p>协程对象，调用 <em>协程函数</em> 所返回的对象。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个协程函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 调用协程函数，返回一个协程对象</span></span><br><span class="line">result = func()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：调用协程函数时，函数内部代码不会执行，只是会返回一个协程对象。</p>
</blockquote>
<h4 id="3-2-1-基本应用"><a href="#3-2-1-基本应用" class="headerlink" title="3.2.1 基本应用"></a>3.2.1 基本应用</h4><blockquote>
<p>程序中，如果想要执行协程函数的内部代码，需要 <code>事件循环</code> 和 <code>协程对象</code> 配合才能实现，如：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"协程内部代码"</span>)</span><br><span class="line"><span class="comment"># 调用协程函数，返回一个协程对象。</span></span><br><span class="line">result = func()</span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">loop = asyncio.get_event_loop() <span class="comment"># 创建一个事件循环</span></span><br><span class="line">loop.run_until_complete(result) <span class="comment"># 将协程当做任务提交到事件循环的任务列表中，协程执行完成之后终止。</span></span><br></pre></td></tr></table></figure>

<pre><code>协程内部代码</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"协程内部代码"</span>)</span><br><span class="line"><span class="comment"># 调用协程函数，返回一个协程对象。</span></span><br><span class="line">result = func()</span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">asyncio.run(result)</span><br><span class="line"><span class="comment"># 本质上方式一是一样的，内部先 创建事件循环 然后执行 run_until_complete，一个简便的写法。</span></span><br><span class="line"><span class="comment"># asyncio.run 函数在 Python 3.7 中加入 asyncio 模块</span></span><br></pre></td></tr></table></figure>

<pre><code>协程内部代码</code></pre><blockquote>
<p>这个过程可以简单理解为：将<code>协程</code>当做任务添加到 <code>事件循环</code> 的任务列表，然后事件循环检测列表中的<code>协程</code>是否 已准备就绪（默认可理解为就绪状态），如果准备就绪则执行其内部代码。</p>
</blockquote>
<h4 id="3-2-2-await"><a href="#3-2-2-await" class="headerlink" title="3.2.2 await"></a>3.2.2 await</h4><blockquote>
<p>await是一个只能在协程函数中使用的关键字，用于遇到IO操作时挂起 当前协程（任务），当前协程（任务）挂起过程中 事件循环可以去执行其他的协程（任务），当前协程IO处理完成时，可以再次切换回来执行await之后的代码。代码如下：</p>
</blockquote>
<p><strong>示例1：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"执行协程函数内部代码"</span>)</span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。</span></span><br><span class="line">    <span class="comment"># 当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"IO请求结束，结果为："</span>, response)</span><br><span class="line">result = func()</span><br><span class="line">asyncio.run(result)</span><br></pre></td></tr></table></figure>

<pre><code>执行协程函数内部代码
IO请求结束，结果为： None</code></pre><p><strong>示例2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">others</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'返回值'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"执行协程函数内部代码"</span>)</span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> others()</span><br><span class="line">    print(<span class="string">"IO请求结束，结果为："</span>, response)</span><br><span class="line">    </span><br><span class="line">asyncio.run( func() )</span><br></pre></td></tr></table></figure>

<pre><code>执行协程函数内部代码
start
end
IO请求结束，结果为： 返回值</code></pre><p><strong>示例3：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">others</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'返回值'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"执行协程函数内部代码"</span>)</span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response1 = <span class="keyword">await</span> others()</span><br><span class="line">    print(<span class="string">"IO请求结束，结果为："</span>, response1)</span><br><span class="line">    response2 = <span class="keyword">await</span> others()</span><br><span class="line">    print(<span class="string">"IO请求结束，结果为："</span>, response2)</span><br><span class="line">    </span><br><span class="line">asyncio.run( func() )</span><br></pre></td></tr></table></figure>

<pre><code>执行协程函数内部代码
start
end
IO请求结束，结果为： 返回值
start
end
IO请求结束，结果为： 返回值</code></pre><blockquote>
<p>上述的所有示例都只是创建了一个任务，即：事件循环的任务列表中只有一个任务，所以在IO等待时无法演示切换到其他任务效果。<br>在程序想要创建多个任务对象，需要使用Task对象来实现。</p>
</blockquote>
<h4 id="3-2-3-Task对象"><a href="#3-2-3-Task对象" class="headerlink" title="3.2.3 Task对象"></a>3.2.3 Task对象</h4><blockquote>
<p><em>Tasks</em> are used to schedule coroutines <em>concurrently</em>.<br>When a coroutine is wrapped into a <em>Task</em> with functions like <a href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> the coroutine is automatically scheduled to run soon。<br>Tasks用于并发调度协程，通过<code>asyncio.create_task(协程对象)</code>的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行。除了使用 <code>asyncio.create_task()</code> 函数以外，还可以用低层级的 <code>loop.create_task()</code> 或 <code>ensure_future()</code> 函数。不建议手动实例化 Task 对象。<br>本质上是将协程对象封装成task对象，并将协程立即加入事件循环，同时追踪协程的状态。<br>注意：<code>asyncio.create_task()</code> 函数在 Python 3.7 中被加入。在 Python 3.7 之前，可以改用低层级的 <code>asyncio.ensure_future()</code> 函数。</p>
</blockquote>
<p><strong>示例1：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"返回值"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main开始"</span>)</span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    task1 = asyncio.create_task(func())</span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    task2 = asyncio.create_task(func())</span><br><span class="line">    print(<span class="string">"main结束"</span>)</span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务。</span></span><br><span class="line">    <span class="comment"># 此处的await是等待相对应的协程全都执行完毕并获取结果</span></span><br><span class="line">    ret1 = <span class="keyword">await</span> task1</span><br><span class="line">    ret2 = <span class="keyword">await</span> task2</span><br><span class="line">    print(ret1, ret2)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<pre><code>main开始
main结束
1
1
2
2
返回值 返回值</code></pre><p><strong>示例2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"返回值"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"main开始"</span>)</span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到Task对象中并添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    <span class="comment"># 在调用</span></span><br><span class="line">    task_list = [</span><br><span class="line">        asyncio.create_task(func()),</span><br><span class="line">        asyncio.create_task(func())</span><br><span class="line">    ]</span><br><span class="line">    print(<span class="string">"main结束"</span>)</span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务。</span></span><br><span class="line">    <span class="comment"># 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done</span></span><br><span class="line">    <span class="comment"># 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中。</span></span><br><span class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(task_list, timeout=<span class="literal">None</span>)</span><br><span class="line">    print(done, pending)</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<pre><code>main开始
main结束
1
1
2
2
{&lt;Task finished coro=&lt;func() done, defined at &lt;ipython-input-32-60081f85a356&gt;:5&gt; result=&apos;返回值&apos;&gt;, &lt;Task finished coro=&lt;func() done, defined at &lt;ipython-input-32-60081f85a356&gt;:5&gt; result=&apos;返回值&apos;&gt;} set()</code></pre><blockquote>
<p>注意：<code>asyncio.wait</code> 源码内部会对列表中的每个协程执行ensure_future从而封装为Task对象，所以在和wait配合使用时task_list的值为<code>[func(),func()]</code> 也是可以的。</p>
</blockquote>
<p><strong>示例3：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"执行协程函数内部代码"</span>)</span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"IO请求结束，结果为："</span>, response)</span><br><span class="line">coroutine_list = [func(), func()]</span><br><span class="line"><span class="comment"># 错误：coroutine_list = [ asyncio.create_task(func()), asyncio.create_task(func()) ]  </span></span><br><span class="line"><span class="comment"># 此处不能直接 asyncio.create_task，因为将Task立即加入到事件循环的任务列表，</span></span><br><span class="line"><span class="comment"># 但此时事件循环还未创建，所以会报错。</span></span><br><span class="line"><span class="comment"># 使用asyncio.wait将列表封装为一个协程，并调用asyncio.run实现执行两个协程</span></span><br><span class="line"><span class="comment"># asyncio.wait内部会对列表中的每个协程执行ensure_future，封装为Task对象。</span></span><br><span class="line">done, pending = asyncio.run( asyncio.wait(coroutine_list) )</span><br><span class="line">print(done, pending)</span><br></pre></td></tr></table></figure>

<pre><code>执行协程函数内部代码
执行协程函数内部代码
IO请求结束，结果为： None
IO请求结束，结果为： None
{&lt;Task finished coro=&lt;func() done, defined at &lt;ipython-input-15-5c3d2d0ace49&gt;:5&gt; result=None&gt;, &lt;Task finished coro=&lt;func() done, defined at &lt;ipython-input-15-5c3d2d0ace49&gt;:5&gt; result=None&gt;} set()</code></pre><h4 id="3-2-4-asyncio-Future对象"><a href="#3-2-4-asyncio-Future对象" class="headerlink" title="3.2.4 asyncio.Future对象"></a>3.2.4 asyncio.Future对象</h4><blockquote>
<p>A <code>Future</code>is a special <strong>low-level</strong> awaitable object that represents an <strong>eventual result</strong> of an asynchronous operation.  </p>
<p>asyncio中的Future对象是一个相对更偏向底层的可对象，通常我们不会直接用到这个对象，而是直接使用Task对象来完成任务的并和状态的追踪。（ Task 是 Futrue的子类 ）<br>Future为我们提供了异步编程中的 最终结果 的处理（Task类也具备状态处理的功能）。</p>
</blockquote>
<p><strong>示例1：</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="comment"># # 创建一个任务（Future对象），这个任务什么都不干。</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line">    <span class="comment"># 等待任务最终结果（Future对象），没有结果则会一直等下去。</span></span><br><span class="line">    <span class="keyword">await</span> fut</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">set_after</span><span class="params">(fut)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    fut.set_result(<span class="string">"666"</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="comment"># 创建一个任务（Future对象），没绑定任何行为，则这个任务永远不知道什么时候结束。</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line">    <span class="comment"># 创建一个任务（Task对象），绑定了set_after函数，函数内部在2s之后，会给fut赋值。</span></span><br><span class="line">    <span class="comment"># 即手动设置future任务的最终结果，那么fut就可以结束了。</span></span><br><span class="line">    <span class="keyword">await</span> loop.create_task(set_after(fut))</span><br><span class="line">    <span class="comment"># 等待 Future对象获取 最终结果，否则一直等下去</span></span><br><span class="line">    data = <span class="keyword">await</span> fut</span><br><span class="line">    print(data)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<pre><code>666</code></pre><blockquote>
<p>Future对象本身函数进行绑定，所以想要让事件循环获取Future的结果，则需要手动设置。而Task对象继承了Future对象，其实就对Future进行扩展，他可以实现在对应绑定的函数执行完成之后，自动执行<code>set_result</code>，从而实现自动结束。  </p>
<p>虽然，平时使用的是Task对象，但对于结果的处理本质是基于Future对象来实现的。  </p>
<p>扩展：支持 <code>await 对象</code>语 法的对象课成为可等待对象，所以 <code>协程对象</code>、<code>Task对象</code>、<code>Future对象</code> 都可以被成为可等待对象。</p>
</blockquote>
<h4 id="3-2-5-futures-Future对象"><a href="#3-2-5-futures-Future对象" class="headerlink" title="3.2.5 futures.Future对象"></a>3.2.5 futures.Future对象</h4><blockquote>
<p>在Python的<code>concurrent.futures</code>模块中也有一个Future对象，这个对象是基于线程池和进程池实现异步操作时使用的对象。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.thread <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.process <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(value)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(value)</span><br><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 或 pool = ProcessPoolExecutor(max_workers=5)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    fut = pool.submit(func, i)</span><br><span class="line">    print(fut)</span><br></pre></td></tr></table></figure>

<pre><code>&lt;Future at 0x1d77467af88 state=running&gt;
&lt;Future at 0x1d7746a68c8 state=running&gt;
&lt;Future at 0x1d77467a508 state=running&gt;
&lt;Future at 0x1d77467afc8 state=running&gt;
&lt;Future at 0x1d773631cc8 state=running&gt;
&lt;Future at 0x1d774692088 state=pending&gt;
&lt;Future at 0x1d774692108 state=pending&gt;
&lt;Future at 0x1d7746921c8 state=pending&gt;
&lt;Future at 0x1d774692288 state=pending&gt;
&lt;Future at 0x1d774692348 state=pending&gt;
0
1
2
3
4
8
7
9
6
5</code></pre><p>​    </p>
<blockquote>
<p>两个Future对象是不同的，他们是为不同的应用场景而设计，例如：<code>concurrent.futures.Future</code>不支持await语法 等。  </p>
<p>官方提示两对象之间不同：</p>
<ul>
<li>unlike asyncio Futures, <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> instances cannot be awaited.  </li>
<li><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result" target="_blank" rel="noopener"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception" target="_blank" rel="noopener"><code>asyncio.Future.exception()</code></a> do not accept the <em>timeout</em> argument.  </li>
<li><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result" target="_blank" rel="noopener"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception" target="_blank" rel="noopener"><code>asyncio.Future.exception()</code></a> raise an <a href="https://docs.python.org/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> exception when the Future is not <em>done</em>.  </li>
<li>Callbacks registered with <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback" target="_blank" rel="noopener"><code>asyncio.Future.add_done_callback()</code></a> are not called immediately. They are scheduled with <a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#asyncio.loop.call_soon" target="_blank" rel="noopener"><code>loop.call_soon()</code></a> instead.  </li>
<li>asyncio Future is not compatible with the <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.wait" target="_blank" rel="noopener"><code>concurrent.futures.wait()</code></a> and <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.as_completed" target="_blank" rel="noopener"><code>concurrent.futures.as_completed()</code></a> functions.  </li>
</ul>
</blockquote>
<blockquote>
<p>在Python提供了一个将<code>futures.Future</code> 对象包装成<code>asyncio.Future</code>对象的函数 <code>asynic.wrap_future</code>。</p>
<p>接下里你肯定问：为什么python会提供这种功能？  </p>
<p>其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果 <code>协程的异步</code>和 <code>进程池/线程池的异步</code> 混搭时，那么就会用到此功能了。 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 某个耗时操作</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"SB"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="comment"># 1. Run in the default loop's executor ( 默认ThreadPoolExecutor )</span></span><br><span class="line">    <span class="comment"># 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象</span></span><br><span class="line">    <span class="comment"># 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。</span></span><br><span class="line">    <span class="comment"># 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用。</span></span><br><span class="line">    fut = loop.run_in_executor(<span class="literal">None</span>, func1)</span><br><span class="line">    result = <span class="keyword">await</span> fut</span><br><span class="line">    print(<span class="string">'default thread pool'</span>, result)</span><br><span class="line">    <span class="comment"># 2. Run in a custom thread pool:</span></span><br><span class="line">    <span class="comment"># with concurrent.futures.ThreadPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     result = await loop.run_in_executor(</span></span><br><span class="line">    <span class="comment">#         pool, func1)</span></span><br><span class="line">    <span class="comment">#     print('custom thread pool', result)</span></span><br><span class="line">    <span class="comment"># 3. Run in a custom process pool:</span></span><br><span class="line">    <span class="comment"># with concurrent.futures.ProcessPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     result = await loop.run_in_executor(</span></span><br><span class="line">    <span class="comment">#         pool, func1)</span></span><br><span class="line">    <span class="comment">#     print('custom process pool', result)</span></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<pre><code>default thread pool SB</code></pre><blockquote>
<p>应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_image</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务）</span></span><br><span class="line">    print(<span class="string">"开始下载:"</span>, url)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># requests模块默认不支持异步操作，所以就使用线程池来配合实现了。</span></span><br><span class="line">    future = loop.run_in_executor(<span class="literal">None</span>, requests.get, url)</span><br><span class="line">    response = <span class="keyword">await</span> future</span><br><span class="line">    print(<span class="string">'下载完成'</span>)</span><br><span class="line">    <span class="comment"># 图片保存到本地文件</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">'_'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">with</span> open(file_name, mode=<span class="string">'wb'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">        file_object.write(response.content)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg'</span>,</span><br><span class="line">        <span class="string">'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg'</span>,</span><br><span class="line">        <span class="string">'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg'</span></span><br><span class="line">    ]</span><br><span class="line">    tasks = [download_image(url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete( asyncio.wait(tasks) )</span><br></pre></td></tr></table></figure>

<pre><code>开始下载: https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg
开始下载: https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg
开始下载: https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg
下载完成
ChcCSV2BBICAUntfAADjJFd6800429.jpg
下载完成
AAFocMs8nzU621.jpg
下载完成
ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg</code></pre><h4 id="3-2-6-异步迭代器"><a href="#3-2-6-异步迭代器" class="headerlink" title="3.2.6 异步迭代器"></a>3.2.6 异步迭代器</h4><p><strong>什么是异步迭代器</strong></p>
<blockquote>
<p>实现了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__" target="_blank" rel="noopener"><code>__aiter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__" target="_blank" rel="noopener"><code>__anext__()</code></a> 方法的对象。<code>__anext__</code> 必须返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 对象。<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 会处理异步迭代器的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__" target="_blank" rel="noopener"><code>__anext__()</code></a> 方法所返回的可等待对象，直到其引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopAsyncIteration" target="_blank" rel="noopener"><code>StopAsyncIteration</code></a> 异常。由 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 引入。</p>
</blockquote>
<p><strong>什么是异步可迭代对象？</strong></p>
<blockquote>
<p>可在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 语句中被使用的对象。必须通过它的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__" target="_blank" rel="noopener"><code>__aiter__()</code></a> 方法返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a>。由 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 引入。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">""" 自定义异步迭代器（同时也是异步可迭代对象） """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">readline</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># await asyncio.sleep(1)</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__aiter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__anext__</span><span class="params">(self)</span>:</span></span><br><span class="line">        val = <span class="keyword">await</span> self.readline()</span><br><span class="line">        <span class="keyword">if</span> val == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建异步可迭代对象</span></span><br><span class="line">    async_iter = Reader()</span><br><span class="line">    <span class="comment"># async for 必须要放在async def函数内，否则语法错误。</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> async_iter:</span><br><span class="line">        print(item)</span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure>

<pre><code>1
2
3
4
5
6
7
8
9</code></pre><blockquote>
<p>异步迭代器其实没什么太大的作用，只是支持了async for语法而已。  </p>
</blockquote>
<h4 id="3-2-6-异步上下文管理器"><a href="#3-2-6-异步上下文管理器" class="headerlink" title="3.2.6 异步上下文管理器"></a>3.2.6 异步上下文管理器</h4><blockquote>
<p>此种对象通过定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aenter__" target="_blank" rel="noopener"><code>__aenter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aexit__" target="_blank" rel="noopener"><code>__aexit__()</code></a> 方法来对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-with" target="_blank" rel="noopener"><code>async with</code></a> 语句中的环境进行控制。由 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 引入。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncContextManager</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.conn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 异步操作数据库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__aenter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 异步链接数据库</span></span><br><span class="line">        self.conn = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__aexit__</span><span class="params">(self, exc_type, exc, tb)</span>:</span></span><br><span class="line">        <span class="comment"># 异步关闭数据库链接</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncContextManager() <span class="keyword">as</span> f:</span><br><span class="line">        result = <span class="keyword">await</span> f.do_something()</span><br><span class="line">        print(result)</span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure>

<pre><code>666</code></pre><blockquote>
<p>这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。</p>
</blockquote>
<h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><blockquote>
<p>在程序中只要看到<code>async</code>和<code>await</code>关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在IO等待时间去执行其他任务，从而实现并发。<br>以上就是异步编程的常见操作，内容参考官方文档。  </p>
</blockquote>
<blockquote>
<ul>
<li>中文版：<a href="https://docs.python.org/zh-cn/3.8/library/asyncio.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/library/asyncio.html</a>  </li>
<li>英文本：<a href="https://docs.python.org/3.8/library/asyncio.html" target="_blank" rel="noopener">https://docs.python.org/3.8/library/asyncio.html</a></li>
</ul>
</blockquote>
<h2 id="4-uvloop"><a href="#4-uvloop" class="headerlink" title="4. uvloop"></a>4. uvloop</h2><blockquote>
<p>Python标准库中提供了<code>asyncio</code>模块，用于支持基于协程的异步编程。<br>uvloop是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。<br>安装uvloop</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install uvloop</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。   </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvloop</span><br><span class="line">asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</span><br><span class="line"><span class="comment"># 编写asyncio的代码，与之前写的代码一致。</span></span><br><span class="line"><span class="comment"># 内部的事件循环自动化会变为uvloop</span></span><br><span class="line">asyncio.run(...)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：知名的asgi uvicorn内部就是使用的uvloop的事件循环。</p>
</blockquote>
<h2 id="5-实战案例"><a href="#5-实战案例" class="headerlink" title="5.实战案例"></a>5.实战案例</h2><blockquote>
<p>为了更好理解，上述所有示例的IO情况都是以 <code>asyncio.sleep</code> 为例，而真实的项目开发中会用到很多IO的情况。</p>
</blockquote>
<h3 id="5-1-异步Redis"><a href="#5-1-异步Redis" class="headerlink" title="5.1 异步Redis"></a>5.1 异步Redis</h3><blockquote>
<p>当通过python去操作redis时，链接、设置值、获取值 这些都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。<br>安装Python异步操作redis模块</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install aioredis</span><br></pre></td></tr></table></figure>

<p><strong>示例1：异步操作redis。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(address, password)</span>:</span></span><br><span class="line">    print(<span class="string">"开始执行"</span>, address)</span><br><span class="line">    <span class="comment"># 网络IO操作：创建redis连接</span></span><br><span class="line">    redis = <span class="keyword">await</span> aioredis.create_redis(address, password=password)</span><br><span class="line">    <span class="comment"># 网络IO操作：在redis中设置哈希值car，内部在设三个键值对，即： redis = &#123; car:&#123;key1:1,key2:2,key3:3&#125;&#125;</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">'car'</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 网络IO操作：去redis中获取值</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">'car'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    print(result)</span><br><span class="line">    redis.close()</span><br><span class="line">    <span class="comment"># 网络IO操作：关闭redis连接</span></span><br><span class="line">    <span class="keyword">await</span> redis.wait_closed()</span><br><span class="line">    print(<span class="string">"结束"</span>, address)</span><br><span class="line">asyncio.run(execute(<span class="string">'redis://47.93.4.198:6379'</span>, <span class="string">"root!2345"</span>))</span><br></pre></td></tr></table></figure>


<p><strong>示例2：连接多个redis做操作（遇到IO会切换其他任务，提供了性能）。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(address, password)</span>:</span></span><br><span class="line">    print(<span class="string">"开始执行"</span>, address)</span><br><span class="line">    <span class="comment"># 网络IO操作：先去连接 47.93.4.197:6379，遇到IO则自动切换任务，去连接47.93.4.198:6379</span></span><br><span class="line">    redis = <span class="keyword">await</span> aioredis.create_redis_pool(address, password=password)</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">'car'</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">'car'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    print(result)</span><br><span class="line">    redis.close()</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> redis.wait_closed()</span><br><span class="line">    print(<span class="string">"结束"</span>, address)</span><br><span class="line">task_list = [</span><br><span class="line">    execute(<span class="string">'redis://47.93.4.197:6379'</span>, <span class="string">"root!2345"</span>),</span><br><span class="line">    execute(<span class="string">'redis://47.93.4.198:6379'</span>, <span class="string">"root!2345"</span>)</span><br><span class="line">]</span><br><span class="line">asyncio.run(asyncio.wait(task_list))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多redis操作参考aioredis官网：<a href="https://aioredis.readthedocs.io/en/v1.3.0/start.html" target="_blank" rel="noopener">https://aioredis.readthedocs.io/en/v1.3.0/start.html</a></p>
</blockquote>
<h3 id="5-2-异步MySQL"><a href="#5-2-异步MySQL" class="headerlink" title="5.2 异步MySQL"></a>5.2 异步MySQL</h3><blockquote>
<p>当通过python去操作MySQL时，连接、执行SQL、关闭都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。 </p>
<p>安装Python异步操作redis模块</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install aiomysql</span><br></pre></td></tr></table></figure>

<p><strong>示例1：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 网络IO操作：连接MySQL</span></span><br><span class="line">    conn = <span class="keyword">await</span> aiomysql.connect(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, password=<span class="string">'123'</span>, db=<span class="string">'mysql'</span>, )</span><br><span class="line">    <span class="comment"># 网络IO操作：创建CURSOR</span></span><br><span class="line">    cur = <span class="keyword">await</span> conn.cursor()</span><br><span class="line">    <span class="comment"># 网络IO操作：执行SQL</span></span><br><span class="line">    <span class="keyword">await</span> cur.execute(<span class="string">"SELECT Host,User FROM user"</span>)</span><br><span class="line">    <span class="comment"># 网络IO操作：获取SQL结果</span></span><br><span class="line">    result = <span class="keyword">await</span> cur.fetchall()</span><br><span class="line">    print(result)</span><br><span class="line">    <span class="comment"># 网络IO操作：关闭链接</span></span><br><span class="line">    <span class="keyword">await</span> cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line">asyncio.run(execute())</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(host, password)</span>:</span></span><br><span class="line">    print(<span class="string">"开始"</span>, host)</span><br><span class="line">    <span class="comment"># 网络IO操作：先去连接 47.93.40.197，遇到IO则自动切换任务，去连接47.93.40.198:6379</span></span><br><span class="line">    conn = <span class="keyword">await</span> aiomysql.connect(host=host, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, password=password, db=<span class="string">'mysql'</span>)</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    cur = <span class="keyword">await</span> conn.cursor()</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> cur.execute(<span class="string">"SELECT Host,User FROM user"</span>)</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    result = <span class="keyword">await</span> cur.fetchall()</span><br><span class="line">    print(result)</span><br><span class="line">    <span class="comment"># 网络IO操作：遇到IO会自动切换任务</span></span><br><span class="line">    <span class="keyword">await</span> cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    print(<span class="string">"结束"</span>, host)</span><br><span class="line">task_list = [</span><br><span class="line">    execute(<span class="string">'47.93.40.197'</span>, <span class="string">"root!2345"</span>),</span><br><span class="line">    execute(<span class="string">'47.93.40.197'</span>, <span class="string">"root!2345"</span>)</span><br><span class="line">]</span><br><span class="line">asyncio.run(asyncio.wait(task_list))</span><br></pre></td></tr></table></figure>

<h3 id="5-3-FastAPI框架"><a href="#5-3-FastAPI框架" class="headerlink" title="5.3 FastAPI框架"></a>5.3 FastAPI框架</h3><blockquote>
<p>FastAPI是一款用于构建API的高性能web框架，框架基于Python3.6+的 <code>type hints</code>搭建。  </p>
<p>接下里的异步示例以<code>FastAPI</code>和<code>uvicorn</code>来讲解（uvicorn是一个支持异步的asgi）。  </p>
<p>安装FastAPI web 框架，  </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install fastapi</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装uvicorn，本质上为web提供socket server的支持的asgi（一般支持异步称asgi、不支持异步称wsgi）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install uvicorn</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"><span class="keyword">from</span> aioredis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line">app = FastAPI()</span><br><span class="line">REDIS_POOL = aioredis.ConnectionsPool(<span class="string">'redis://47.193.14.198:6379'</span>, password=<span class="string">"root123"</span>, minsize=<span class="number">1</span>, maxsize=<span class="number">10</span>)</span><br><span class="line"><span class="meta">@app.get("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" 普通操作接口 """</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"message"</span>: <span class="string">"Hello World"</span>&#125;</span><br><span class="line"><span class="meta">@app.get("/red")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">red</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" 异步操作接口 """</span></span><br><span class="line">    print(<span class="string">"请求来了"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 连接池获取一个连接</span></span><br><span class="line">    conn = <span class="keyword">await</span> REDIS_POOL.acquire()</span><br><span class="line">    redis = Redis(conn)</span><br><span class="line">    <span class="comment"># 设置值</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">'car'</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 读取值</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">'car'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    print(result)</span><br><span class="line">    <span class="comment"># 连接归还连接池</span></span><br><span class="line">    REDIS_POOL.release(conn)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"luffy:app"</span>, host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5000</span>, log_level=<span class="string">"info"</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在有多个用户并发请求的情况下，异步方式来编写的接口可以在IO等待过程中去处理其他的请求，提供性能。  </p>
<p>例如：同时有两个用户并发来向接口 <code>http://127.0.0.1:5000/red</code> 发送请求，服务端只有一个线程，同一时刻只有一个请求被处理。 异步处理可以提供并发是因为：当视图函数在处理第一个请求时，第二个请求此时是等待被处理的状态，当第一个请求遇到IO等待时，会自动切换去接收并处理第二个请求，当遇到IO时自动化切换至其他请求，一旦有请求IO执行完毕，则会再次回到指定请求向下继续执行其功能代码。  </p>
<p>基于上下文管理，来实现自动化管理的案例：  </p>
</blockquote>
<p><strong>示例1：redis</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"><span class="keyword">from</span> aioredis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line">app = FastAPI()</span><br><span class="line">REDIS_POOL = aioredis.ConnectionsPool(<span class="string">'redis://47.193.14.198:6379'</span>, password=<span class="string">"root123"</span>, minsize=<span class="number">1</span>, maxsize=<span class="number">10</span>)</span><br><span class="line"><span class="meta">@app.get("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" 普通操作接口 """</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"message"</span>: <span class="string">"Hello World"</span>&#125;</span><br><span class="line"><span class="meta">@app.get("/red")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">red</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" 异步操作接口 """</span></span><br><span class="line">    print(<span class="string">"请求来了"</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> REDIS_POOL.get() <span class="keyword">as</span> conn:</span><br><span class="line">        redis = Redis(conn)</span><br><span class="line">        <span class="comment"># 设置值</span></span><br><span class="line">        <span class="keyword">await</span> redis.hmset_dict(<span class="string">'car'</span>, key1=<span class="number">1</span>, key2=<span class="number">2</span>, key3=<span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 读取值</span></span><br><span class="line">        result = <span class="keyword">await</span> redis.hgetall(<span class="string">'car'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        print(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"fast3:app"</span>, host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5000</span>, log_level=<span class="string">"info"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>示例2：mysql</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line">app = FastAPI()</span><br><span class="line"><span class="comment"># 创建数据库连接池</span></span><br><span class="line">pool = aiomysql.Pool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, password=<span class="string">'123'</span>, db=<span class="string">'mysql'</span>,</span><br><span class="line">                     minsize=<span class="number">1</span>, maxsize=<span class="number">10</span>, echo=<span class="literal">False</span>, pool_recycle=<span class="number">-1</span>, loop=asyncio.get_event_loop())</span><br><span class="line"><span class="meta">@app.get("/red")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">red</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" 异步操作接口 """</span></span><br><span class="line">    <span class="comment"># 去数据库连接池申请链接</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> pool.acquire() <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cur:</span><br><span class="line">            <span class="comment"># 网络IO操作：执行SQL</span></span><br><span class="line">            <span class="keyword">await</span> cur.execute(<span class="string">"SELECT Host,User FROM user"</span>)</span><br><span class="line">            <span class="comment"># 网络IO操作：获取SQL结果</span></span><br><span class="line">            result = <span class="keyword">await</span> cur.fetchall()</span><br><span class="line">            print(result)</span><br><span class="line">            <span class="comment"># 网络IO操作：关闭链接</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"result"</span>: <span class="string">"ok"</span>&#125;</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    uvicorn.run(<span class="string">"fast2:app"</span>, host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5000</span>, log_level=<span class="string">"info"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-4-爬虫"><a href="#5-4-爬虫" class="headerlink" title="5.4 爬虫"></a>5.4 爬虫</h3><blockquote>
<p>在编写爬虫应用时，需要通过网络IO去请求目标数据，这种情况适合使用异步编程来提升性能，接下来我们使用支持异步编程的aiohttp模块来实现。  </p>
<p>安装aiohttp模块 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install aiohttp</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(session, url)</span>:</span></span><br><span class="line">    print(<span class="string">"发送请求："</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        text = <span class="keyword">await</span> response.text()</span><br><span class="line">        print(<span class="string">"得到结果："</span>, url, len(text))</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">'https://python.org'</span>,</span><br><span class="line">            <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">            <span class="string">'https://www.pythonav.com'</span></span><br><span class="line">        ]</span><br><span class="line">        tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>为了提升性能越来越多的框架都在向异步编程靠拢，例如：sanic、tornado、django3.0、django channels组件 等，用更少资源可以做处理更多的事，何乐而不为呢。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_content</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=<span class="literal">True</span>)) <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">"https://movie.douban.com/cinema/later/beijing/"</span></span><br><span class="line">    init_page = <span class="keyword">await</span> fetch_content(url)</span><br><span class="line">    init_soup = BeautifulSoup(init_page, <span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line">    movie_names, urls_to_fetch, movie_dates = [], [], []</span><br><span class="line"></span><br><span class="line">    all_movies = init_soup.find(<span class="string">'div'</span>, id=<span class="string">"showing-soon"</span>)</span><br><span class="line">    <span class="keyword">for</span> each_movie <span class="keyword">in</span> all_movies.find_all(<span class="string">'div'</span>, class_=<span class="string">"item"</span>):</span><br><span class="line">        all_a_tag = each_movie.find_all(<span class="string">'a'</span>)</span><br><span class="line">        all_li_tag = each_movie.find_all(<span class="string">'li'</span>)</span><br><span class="line"></span><br><span class="line">        movie_names.append(all_a_tag[<span class="number">1</span>].text)</span><br><span class="line">        urls_to_fetch.append(all_a_tag[<span class="number">1</span>][<span class="string">'href'</span>])</span><br><span class="line">        movie_dates.append(all_li_tag[<span class="number">0</span>].text)</span><br><span class="line"></span><br><span class="line">    tasks = [fetch_content(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls_to_fetch]</span><br><span class="line">    pages = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> movie_name, movie_date, page <span class="keyword">in</span> zip(movie_names, movie_dates, pages):</span><br><span class="line">        soup_item = BeautifulSoup(page, <span class="string">'lxml'</span>)</span><br><span class="line">        img_tag = soup_item.find(<span class="string">'img'</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'&#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(movie_name, movie_date, img_tag[<span class="string">'src'</span>]))</span><br><span class="line"></span><br><span class="line">%time asyncio.run(main())</span><br></pre></td></tr></table></figure>

<pre><code>六月的秘密 06月21日 https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2522497098.jpg
秘密访客 06月25日 https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2579398648.jpg
奇妙王国之魔法奇缘 07月11日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2577837112.jpg
我想静静 08月07日 https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2595969179.jpg
无名狂 09月25日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2574800433.jpg
海底小纵队：火焰之环 10月01日 https://img9.doubanio.com/view/photo/s_ratio_poster/public/p2605901616.jpg
Wall time: 1.24 s</code></pre><h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(num,<span class="string">'before---func1----'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"recv num %s"</span>%num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future)</span>:</span></span><br><span class="line">    print(future.result())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    begin = time.time()</span><br><span class="line"></span><br><span class="line">    coroutine1 = func1(<span class="number">1</span>)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task1=asyncio.ensure_future(coroutine1)</span><br><span class="line">    task1.add_done_callback(callback)</span><br><span class="line">    loop.run_until_complete(task1)</span><br><span class="line"><span class="comment">#     loop.close()</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(end-begin)</span><br></pre></td></tr></table></figure>

<pre><code>1 before---func1----
recv num 1
0.0009844303131103516</code></pre>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>asyncio</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中查找指定目录下的文件</title>
    <url>/2019/12/16/Python%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findConfigFile</span><span class="params">(dir, name)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> relpath, dirs, files <span class="keyword">in</span> os.walk(dir):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> files:</span><br><span class="line">            full_path = os.path.join(dir, relpath, name)</span><br><span class="line">            <span class="keyword">return</span> os.path.normpath(os.path.abspath(full_path))</span><br><span class="line"></span><br><span class="line">config = findConfigFile(<span class="string">'/dir/'</span>, <span class="string">'config.py'</span>)</span><br><span class="line">print(config)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c13/p09_find_files_by_name.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c13/p09_find_files_by_name.html</a></p>
<p>还有其它几种方式:</p>
<p>os.listdir(path)<br>查看指定path下的文件，一般结合os.path.isfile(path)(是否为文件)使用递归对目录进行遍历<br>使用介绍 <a href="http://www.runoob.com/python/os-listdir.html" target="_blank" rel="noopener">http://www.runoob.com/python/os-listdir.html</a></p>
<p>os.walk(top, topdown=True, οnerrοr=None, followlinks=False)<br>一般只传入第一个参数，即要遍历的路径，topdown指明遍历的顺序，该方法对于每个目录返回一个三元组，(dirpath, dirnames, filenames)。第一个是路径，第二个是路径下面的目录，第三个是路径下面的非目录（对于windows来说也就是文件）。通过for循环即可完成目录的递归了。<br>使用介绍 <a href="http://www.runoob.com/python/os-walk.html" target="_blank" rel="noopener">http://www.runoob.com/python/os-walk.html</a></p>
<p>glob.glob(path)<br>返回所有匹配的文件路径列表。它只有一个参数path，定义了文件路径匹配规则，这里可以是绝对路径，也可以是相对路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@test ~]<span class="comment"># python3</span></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">glob.glob(<span class="string">'./*.py'</span>)</span><br><span class="line">[<span class="string">'./1.py'</span>, <span class="string">'./3.py'</span>, <span class="string">'./2.py'</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python脚本任务用时</title>
    <url>/2019/10/27/Python%E8%84%9A%E6%9C%AC%E4%BB%BB%E5%8A%A1%E7%94%A8%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>很简单，别忘了导入time模块</p>
</blockquote>
<h5 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start = time.time()</span><br><span class="line">(要执行的代码...)</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'添加任务用时：'</span>, end - start)</span><br></pre></td></tr></table></figure>
<h5 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import time</span></span><br><span class="line"><span class="comment"># 函数运行时间装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># 定义嵌套函数，用来打印出装饰的函数的执行时间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 定义开始时间和结束时间，将func夹在中间执行，取得其返回值</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func_return = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="comment"># 打印方法名称和其执行时间</span></span><br><span class="line">        log.info(<span class="string">f'函数名:<span class="subst">&#123;func.__name__&#125;</span>() 执行时间: <span class="subst">&#123;end - start&#125;</span>s'</span>) <span class="comment">#日志输出</span></span><br><span class="line">        print(<span class="string">f'函数名:<span class="subst">&#123;func.__name__&#125;</span>() 执行时间: <span class="subst">&#123;end - start&#125;</span>s'</span>) <span class="comment">#打印输出</span></span><br><span class="line">        <span class="comment"># 返回func的返回值</span></span><br><span class="line">        <span class="keyword">return</span> func_return</span><br><span class="line">    <span class="comment"># 返回嵌套的函数</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python字符串的45个方法超级详解</title>
    <url>/2020/05/14/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%8445%E4%B8%AA%E6%96%B9%E6%B3%95%E8%B6%85%E7%BA%A7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Python中字符串对象提供了很多方法来操作字符串，功能相当丰富。必须进行全面的了解与学习，后面的代码处理才能更得心应手，编程水平走向新台阶的坚实基础。目前一共有45个方法，给大家分类整理，可以收藏查询使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取字所有的符串方法</span><br><span class="line">print(dir(str))</span><br><span class="line">[...,&#39;capitalize&#39;, &#39;casefold&#39;, &#39;center&#39;, &#39;count&#39;, &#39;encode&#39;, &#39;endswith&#39;,</span><br><span class="line">&#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;format_map&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, </span><br><span class="line">&#39;isascii&#39;, &#39;isdecimal&#39;, &#39;isdigit&#39;, &#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;, </span><br><span class="line">&#39;isprintable&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, </span><br><span class="line">&#39;lstrip&#39;, &#39;maketrans&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, </span><br><span class="line">&#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, </span><br><span class="line">&#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;]</span><br></pre></td></tr></table></figure>

<h2 id="一、大小写转换"><a href="#一、大小写转换" class="headerlink" title="一、大小写转换"></a>一、大小写转换</h2><h3 id="01、capitalize"><a href="#01、capitalize" class="headerlink" title="01、capitalize()"></a>01、capitalize()</h3><p><strong>描述：</strong>将字符串的第一个字母变成大写，其余字母变为小写。</p>
<p><strong>语法：</strong>str.capitalize()</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"i Love python"</span>.capitalize() </span><br><span class="line"><span class="string">'I love python'</span></span><br><span class="line"></span><br><span class="line"><span class="string">"i Love pYthoN"</span>.capitalize() </span><br><span class="line"><span class="string">'I love python'</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="02、title"><a href="#02、title" class="headerlink" title="02、title()"></a>02、title()</h3><p><strong>描述：</strong>返回一个满足<strong>标题格式</strong>的字符串。即所有英文单词首字母大写，其余英文字母小写。</p>
<p><strong>语法：</strong>str.title()</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"i am very love python"</span>.title()</span><br><span class="line"><span class="string">'I Am Very Love Python'</span></span><br></pre></td></tr></table></figure>



<h3 id="03、swapcase"><a href="#03、swapcase" class="headerlink" title="03、swapcase()"></a>03、swapcase()</h3><p><strong>描述：</strong>将字符串str中的大小写字母同时进行互换。即将字符串str中的大写字母转换为小写字母，将小写字母转换为大写字母。</p>
<p><strong>语法：</strong>str.swapcase()</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"I Am Love PYTHON"</span>.swapcase()</span><br><span class="line"><span class="string">'i aM lOVE python'</span></span><br><span class="line"></span><br><span class="line"><span class="string">"我爱pythoN Python pYTHON"</span>.swapcase()</span><br><span class="line"><span class="string">'我爱PYTHOn pYTHON Python'</span></span><br></pre></td></tr></table></figure>



<h3 id="04、lower"><a href="#04、lower" class="headerlink" title="04、lower()"></a>04、lower()</h3><p><strong>描述：</strong>将字符串中的所有大写字母转换为小写字母。</p>
<p><strong>语法：</strong>str.lower()</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"我爱pythoN Python!"</span>.lower()</span><br><span class="line"><span class="string">'我爱python python!'</span></span><br></pre></td></tr></table></figure>



<h3 id="05、upper"><a href="#05、upper" class="headerlink" title="05、upper()"></a>05、upper()</h3><p><strong>描述：</strong>将字符串中的所有小写字母转换为大写字母。</p>
<p><strong>语法：</strong> str.upper()</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"i am very love python"</span>.upper()</span><br><span class="line"><span class="string">'I AM VERY LOVE PYTHON'</span></span><br></pre></td></tr></table></figure>



<h3 id="06、casefold"><a href="#06、casefold" class="headerlink" title="06、casefold()"></a>06、casefold()</h3><p><strong>描述：</strong>将字符串中的所有大写字母转换为小写字母。也可以将非英文 语言中的大写转换为小写。</p>
<p>注意 ：lower()函数和casefold()函数的区别：lower() 方法只对ASCII编码，即‘A-Z’有效，对于其它语言中把大写转换为小写的情况无效，只能用 casefold() 函数。</p>
<p><strong>语法：</strong>str.casefold()</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="string">"Groß - α"</span>.casefold()<span class="comment">#德语 </span></span><br><span class="line"><span class="string">'gross - α'</span></span><br><span class="line"></span><br><span class="line"><span class="string">"I am verY love python"</span>.casefold()</span><br><span class="line"><span class="string">'i am very love python'</span></span><br></pre></td></tr></table></figure>



<h2 id="二、字符串填充"><a href="#二、字符串填充" class="headerlink" title="二、字符串填充"></a>二、字符串填充</h2><h3 id="07、center"><a href="#07、center" class="headerlink" title="07、center()"></a>07、center()</h3><p><strong>描述：</strong>返回一个长度为width,两边用fillchar(单字符)填充的字符串，即字符串str居中，两边用fillchar填充。若字符串的长度大于width,则直接返回字符串str。</p>
<p><strong>语法：</strong>str.center(width , “fillchar”)</p>
<ul>
<li>width —— 指定字符串长度。</li>
<li>fillchar —— 要填充的单字符，默认为空格。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'shuai'</span>.center(<span class="number">10</span>)</span><br><span class="line"><span class="string">'  shuai   '</span></span><br><span class="line"></span><br><span class="line"><span class="string">'shuai'</span>.center(<span class="number">10</span>,<span class="string">'*'</span>)</span><br><span class="line"><span class="string">'**shuai***'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#名字补齐</span></span><br><span class="line">L = [<span class="string">'Jack'</span>,<span class="string">'jenny'</span>,<span class="string">'joe'</span>]</span><br><span class="line">[name.center(<span class="number">10</span>,<span class="string">'#'</span>) <span class="keyword">for</span> name <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'###Jack###'</span>, <span class="string">'##jenny###'</span>, <span class="string">'###joe####'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> L:</span><br><span class="line">    print(name.center(<span class="number">10</span>,<span class="string">'#'</span>))</span><br><span class="line"><span class="comment">###Jack###</span></span><br><span class="line"><span class="comment">##jenny###</span></span><br><span class="line"><span class="comment">###joe####</span></span><br></pre></td></tr></table></figure>



<h3 id="08、ljust"><a href="#08、ljust" class="headerlink" title="08、ljust()"></a>08、ljust()</h3><p><strong>描述：</strong>返回一个原字符串左对齐,并使用fillchar填充(默认为空格)至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。</p>
<p><strong>语法：</strong> str.ljust(width, fillchar) -&gt; str 返回一个新的字符串</p>
<ul>
<li>width —— 指定字符串的输出长度。</li>
<li>fillchar—— 将要填充的单字符，默认为空格。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'shuai'</span>.ljust(<span class="number">10</span>)</span><br><span class="line"><span class="string">'shuai     '</span></span><br><span class="line"></span><br><span class="line"><span class="string">'shuai'</span>.ljust(<span class="number">10</span>,<span class="string">'*'</span>)</span><br><span class="line"><span class="string">'shuai*****'</span></span><br><span class="line"></span><br><span class="line">L = [<span class="string">'Jack'</span>,<span class="string">'jenny'</span>,<span class="string">'joe'</span>]</span><br><span class="line">[name.ljust(<span class="number">10</span>,<span class="string">'#'</span>) <span class="keyword">for</span> name <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'Jack######'</span>, <span class="string">'jenny#####'</span>, <span class="string">'joe#######'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> L:</span><br><span class="line">    print(name.ljust(<span class="number">10</span>,<span class="string">'#'</span>))</span><br><span class="line">Jack<span class="comment">######</span></span><br><span class="line">jenny<span class="comment">#####</span></span><br><span class="line">joe<span class="comment">######</span></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="09、rjust"><a href="#09、rjust" class="headerlink" title="09、rjust()"></a><strong>09、rjust()</strong></h3><p><strong>描述：</strong>返回一个原字符串右对齐,并使用fillchar填充(默认为空格)至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。</p>
<p><strong>语法：</strong> str.ljust(width, fillchar)</p>
<ul>
<li>width —— 指定字符串的输出长度。</li>
<li>fillchar—— 将要填充的单字符，默认为空格。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'shuai'</span>.rjust(<span class="number">10</span>)</span><br><span class="line"><span class="string">'     shuai'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'shuai'</span>.rjust(<span class="number">10</span>,<span class="string">'*'</span>)</span><br><span class="line"><span class="string">'*****shuai'</span></span><br><span class="line"></span><br><span class="line">L = [<span class="string">'Jack'</span>,<span class="string">'jenny'</span>,<span class="string">'joe'</span>]</span><br><span class="line">[name.rjust(<span class="number">10</span>,<span class="string">'#'</span>) <span class="keyword">for</span> name <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'######Jack'</span>, <span class="string">'#####jenny'</span>, <span class="string">'#######joe'</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> L:</span><br><span class="line">    print(name.rjust(<span class="number">10</span>,<span class="string">'*'</span>))</span><br><span class="line">******Jack</span><br><span class="line">*****jenny</span><br><span class="line">*******joe</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> L:</span><br><span class="line">    print(name.rjust(<span class="number">10</span>,<span class="string">'好'</span>))</span><br><span class="line">好好好好好好Jack</span><br><span class="line">好好好好好jenny</span><br><span class="line">好好好好好好好j</span><br></pre></td></tr></table></figure>



<h3 id="10、zfill"><a href="#10、zfill" class="headerlink" title="10、zfill()"></a>10、zfill()</h3><p><strong>描述：</strong>返回指定长度的字符串，使原字符串右对齐，前面用0填充到指定字符串长度。</p>
<p><strong>语法：</strong>str.zfill(width)</p>
<p>width —— 指定字符串的长度,但不能为空。若指定长度小于字符串长度，则直接输出原字符串。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'12'</span>.zfill(<span class="number">10</span>)</span><br><span class="line"><span class="string">'0000000012'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对用户ID进行填充</span></span><br><span class="line">L=[<span class="string">'56783'</span>,<span class="string">'34'</span>,<span class="string">'987766721'</span>,<span class="string">'326'</span>]  </span><br><span class="line">[id.zfill(<span class="number">10</span>) <span class="keyword">for</span> id <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'0000056783'</span>, <span class="string">'0000000034'</span>, <span class="string">'0987766721'</span>, <span class="string">'0000000326'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> id <span class="keyword">in</span> L:</span><br><span class="line">    print(id.zfill(<span class="number">10</span>))</span><br><span class="line"><span class="number">0000056783</span></span><br><span class="line"><span class="number">0000000034</span></span><br><span class="line"><span class="number">0987766721</span></span><br><span class="line"><span class="number">0000000326</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">#等价于用0填充的右对齐</span></span><br><span class="line">[id.rjust(<span class="number">10</span>,<span class="string">'0'</span>) <span class="keyword">for</span> id <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'0000056783'</span>, <span class="string">'0000000034'</span>, <span class="string">'0987766721'</span>, <span class="string">'0000000326</span></span><br></pre></td></tr></table></figure>



<h2 id="三、字符串编码"><a href="#三、字符串编码" class="headerlink" title="三、字符串编码"></a><strong>三、字符串编码</strong></h2><h3 id="11、encode"><a href="#11、encode" class="headerlink" title="11、encode()"></a>11、encode()</h3><p><strong>描述：</strong>以指定的编码格式编码字符串，默认编码为 ‘utf-8’。encode英文原意 编码。</p>
<p><strong>语法：</strong>str.encode(encoding=’utf-8’, errors=’strict’)</p>
<ul>
<li>encoding 参数可选，即要使用的编码，默认编码为 ‘utf-8’。字符串编码常用类型有：utf-8，gb2312，cp936，gbk等。</li>
<li>errors 参数可选，设置不同错误的处理方案。默认为 ‘strict’,意为编码错误引起一个UnicodeEncodeError。 其它可能值有 ‘ignore’, ‘replace’, ‘xmlcharrefreplace’以及通过 codecs.register_error() 注册其它的值。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"我爱祖国"</span>.encode(encoding=<span class="string">"utf8"</span>,errors=<span class="string">"strict"</span>)</span><br><span class="line"><span class="string">b'\\xe6\\x88\\x91\\xe7\\x88\\xb1\\xe7\\xa5\\x96\\xe5\\x9b\\xbd'</span></span><br><span class="line"></span><br><span class="line"><span class="string">"I love my country"</span>.encode(encoding=<span class="string">"utf8"</span>,errors=<span class="string">"strict"</span>)</span><br><span class="line"> <span class="string">b'I love my country'</span></span><br></pre></td></tr></table></figure>



<h3 id="12、decode"><a href="#12、decode" class="headerlink" title="12、decode()"></a>12、decode()</h3><p><strong>描述：</strong>以 encoding 指定的编码格式解码字符串，默认编码为字符串编码。decode英文意思是 解码，</p>
<p><strong>语法：</strong>str.decode(encoding=’utf-8’, errors=’strict’)</p>
<ul>
<li>encoding ——要使用的编码，如：utf-8,gb2312,cp936,gbk等。</li>
<li>errors ——设置不同解码错误的处理方案。默认为 ‘strict’,意为编码错误引起一个 UnicodeDecodeError。 其它可能得值有 ‘ignore’, ‘replace’以及通过 codecs.register_error() 注册的1其它值。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">"我爱学习"</span>.encode(encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">str1</span><br><span class="line"><span class="string">b'\\xe6\\x88\\x91\\xe7\\x88\\xb1\\xe5\\xad\\xa6\\xe4\\xb9\\xa0'</span></span><br><span class="line"></span><br><span class="line">str1.decode(encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="string">'我爱学习'</span></span><br></pre></td></tr></table></figure>



<h2 id="四、字符串查找"><a href="#四、字符串查找" class="headerlink" title="四、字符串查找"></a>四、字符串查找</h2><h3 id="13、find"><a href="#13、find" class="headerlink" title="13、find()"></a>13、find()</h3><p><strong>描述：</strong>查找字符串中指定的子字符串sub第一次出现的位置，可以规定字符串的索引查找范围。若无则返回 -1。</p>
<p><strong>语法：</strong>str.find(sub,start,end) -&gt; int 返回整数</p>
<p><strong>参数：</strong></p>
<ul>
<li>sub —要索引的子字符串。</li>
<li>start —索引的起始位置。默认值为0。</li>
<li>end —索引的结束位置。默认值为字符串长度len(str)。[start,end) 不包括end。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找子字符串"o"</span></span><br><span class="line"><span class="string">"I love python"</span>.find(<span class="string">'o'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#索引起始位置为4 索引范围为：ve python</span></span><br><span class="line"><span class="string">"I love python"</span>.find(<span class="string">'o'</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#索引起始位置为4,结束位置为12 索引范围为：ve pytho</span></span><br><span class="line"><span class="string">"I love python"</span>.find(<span class="string">'o'</span>,<span class="number">4</span>,<span class="number">12</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="string">"I love python"</span>.find(<span class="string">'o'</span>,<span class="number">4</span>,<span class="number">11</span>)<span class="comment">#不包括11位的'o',返回-1</span></span><br></pre></td></tr></table></figure>



<h3 id="14、rfind"><a href="#14、rfind" class="headerlink" title="14、rfind()"></a>14、rfind()</h3><p><strong>描述：</strong>查找字符串中指定的子字符串sub最后一次出现的位置，可以规定字符串的索引查找范围。若无则返回 -1。</p>
<p><strong>语法：</strong>str.rfind(sub,start,end) -&gt; int 返回整数</p>
<p><strong>参数：</strong></p>
<ul>
<li>sum —要索引的子字符串。</li>
<li>start —索引的起始位置。默认值为0。</li>
<li>end —索引的结束位置。默认值为字符串长度len(str)。[start,end) 不包括end。</li>
</ul>
<p>注：rfind()函数用法与find()函数相似，rfind()函数返回指定子字符串最后一次出现的位置，find()函数返回指定子字符串第一次出现的位置。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找子字符串"o"</span></span><br><span class="line"><span class="string">"I love python"</span>.find(<span class="string">'o'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#索引起始位置为4 索引范围为：ve python</span></span><br><span class="line"><span class="string">"I love python"</span>.find(<span class="string">'o'</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#索引起始位置为4,结束位置为12 索引范围为：ve pytho</span></span><br><span class="line"><span class="string">"I love python"</span>.find(<span class="string">'o'</span>,<span class="number">4</span>,<span class="number">12</span></span><br></pre></td></tr></table></figure>



<h3 id="15、index"><a href="#15、index" class="headerlink" title="15、index()"></a>15、index()</h3><p><strong>描述：</strong>查找字符串中第一次出现的子字符串的位置，可以规定字符串的索引查找范围[star,end)。若无则会报错。</p>
<p><strong>语法：</strong>str.index(sub, start, end) -&gt; int 返回整数</p>
<p><strong>参数：</strong></p>
<ul>
<li>sub —— 查找的子字符串。</li>
<li>start —— 索引的起始位置，默认为0。</li>
<li>end —— 索引的结束位置，默认为字符串的长度。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"I love python"</span>.index(<span class="string">"o"</span>) <span class="comment">#默认索引整个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="string">"I love python"</span>.index(<span class="string">"o"</span>,<span class="number">4</span>)  <span class="comment">#索引 ve python</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="string">"I love python"</span>.index(<span class="string">"o"</span>,<span class="number">4</span>,<span class="number">12</span>) <span class="comment">#索引 ve pytho</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="string">"I love python"</span>.index(<span class="string">"love"</span>)    <span class="comment">#索引多个字符</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="string">"I love python"</span>.index(<span class="string">"k"</span>)   <span class="comment">#索引字符串不存在，报错</span></span><br><span class="line">ValueError: substring <span class="keyword">not</span> fou</span><br></pre></td></tr></table></figure>



<h3 id="16、rindex"><a href="#16、rindex" class="headerlink" title="16、rindex()"></a>16、rindex()</h3><p><strong>描述：</strong> rindex() 方法返回子字符串最后一次出现在字符串中的索引位置，该方法与 rfind() 方法一样，可以规定字符串的索引查找范围[star,end)，只不过如果子字符串不在字符串中会报一个异常。</p>
<p><strong>语法：</strong>str.rindex(sub, start, end) -&gt; int 返回整数。</p>
<p><strong>参数：</strong></p>
<ul>
<li>sub —— 查找的子字符串。</li>
<li>start —— 索引的起始位置，默认为0。</li>
<li>end —— 索引的结束位置，默认为字符串的长度。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"I love python"</span>.rindex(<span class="string">'o'</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="string">"I love python"</span>.index(<span class="string">'o'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="string">"I love python"</span>.rindex(<span class="string">'k'</span>)</span><br><span class="line">ValueError: substring <span class="keyword">not</span> found</span><br><span class="line"></span><br><span class="line"><span class="string">"I love python"</span>.rfind(<span class="string">'k'</span></span><br></pre></td></tr></table></figure>



<h2 id="五、字符串格式化"><a href="#五、字符串格式化" class="headerlink" title="五、字符串格式化"></a>五、字符串格式化</h2><h3 id="17、format"><a href="#17、format" class="headerlink" title="17、format()"></a>17、format()</h3><p><strong>描述：</strong>Python2.6 开始，新增了一种格式化字符串的函数 <strong>str.format()</strong>，它增强了字符串格式化的功能。基本语法是通过 <strong>{}</strong> 和 <strong>:</strong> 来代替以前的 <strong>%</strong> 。使用format()来格式化字符串时，使用在字符串中使用{}作为占位符，占位符的内容将引用format()中的参数进行替换。可以是位置参数、命名参数或者兼而有之。</p>
<p>format 函数可以接受不限个参数，位置可以不按顺序。</p>
<p><strong>语法：</strong>format(value, format_spec)</p>
<p><strong>参数：</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 位置参数</span></span><br><span class="line"><span class="string">'&#123;&#125;:您&#123;&#125;购买的&#123;&#125;到了！请下楼取快递。'</span>.format(<span class="string">'快递小哥'</span>,<span class="string">'淘宝'</span>,<span class="string">'快递'</span>)</span><br><span class="line"><span class="string">'快递小哥:您淘宝购买的快递到了！请下楼取快递。'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#给批量客户发短息</span></span><br><span class="line">n_list=[<span class="string">'马云'</span>,<span class="string">'马化腾'</span>,<span class="string">'麻子'</span>,<span class="string">'小红'</span>,<span class="string">'李彦宏'</span>,<span class="string">'二狗子'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> n_list:</span><br><span class="line">    print(<span class="string">'&#123;0&#125;：您淘宝购买的快递到了！请下楼取快递！'</span>.format(name))</span><br><span class="line">马云：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line">马化腾：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line">麻子：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line">小红：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line">李彦宏：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line">二狗子：您淘宝购买的快递到了！请下楼取快递！  </span><br><span class="line">    </span><br><span class="line"><span class="comment">#名字进行填充    </span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> n_list:</span><br><span class="line">    print(<span class="string">'&#123;0&#125;：您淘宝购买的快递到了！请下楼取快递！'</span>.format(n.center(<span class="number">3</span>,<span class="string">'*'</span>)))</span><br><span class="line">    </span><br><span class="line">*马云：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line">马化腾：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line">*麻子：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line">*小红：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line">李彦宏：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line">二狗子：您淘宝购买的快递到了！请下楼取快递！</span><br><span class="line"></span><br><span class="line"><span class="string">'&#123;0&#125;, &#123;1&#125; and &#123;2&#125;'</span>.format(<span class="string">'gao'</span>,<span class="string">'fu'</span>,<span class="string">'shuai'</span>)</span><br><span class="line"><span class="string">'gao, fu and shuai'</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">3</span></span><br><span class="line">y=<span class="number">5</span></span><br><span class="line"><span class="string">'&#123;0&#125;+&#123;1&#125;=&#123;2&#125;'</span>.format(x,y,x+y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名参数</span></span><br><span class="line"><span class="string">'&#123;name1&#125;, &#123;name2&#125; and &#123;name3&#125;'</span>.format(name1=<span class="string">'gao'</span>, name2=<span class="string">'fu'</span>, name3=<span class="string">'shuai'</span>)</span><br><span class="line"><span class="string">'gao, fu and shuai'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 混合位置参数、命名参数</span></span><br><span class="line"><span class="string">'&#123;name1&#125;, &#123;0&#125; and &#123;name3&#125;'</span>.format(<span class="string">"shuai"</span>, name1=<span class="string">'fu'</span>, name3=<span class="string">'gao'</span>)</span><br><span class="line"><span class="string">'fu, shuai and gao'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#for循环进行批量处理</span></span><br><span class="line">[<span class="string">"vec_&#123;0&#125;"</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="string">'vec_0'</span>, <span class="string">'vec_1'</span>, <span class="string">'vec_2'</span>, <span class="string">'vec_3'</span>, <span class="string">'vec_4'</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">'f_&#123;&#125;'</span>.format(r) <span class="keyword">for</span> r <span class="keyword">in</span> list(<span class="string">'abcde'</span>)]</span><br><span class="line">[<span class="string">'f_a'</span>, <span class="string">'f_b'</span>, <span class="string">'f_c'</span></span><br></pre></td></tr></table></figure>



<h3 id="18、format-map"><a href="#18、format-map" class="headerlink" title="18、format_map()"></a>18、format_map()</h3><p><strong>描述：</strong>返回字符串的格式化版本。在Python3中使用format和format_map方法都可以进行字符串格式化，但format是一种所有情况都能使用的格式化方法，format_map仅使用于字符串格式中可变数据参数来源于字典等映射关系数据时才可以使用。</p>
<p><strong>语法：</strong>str.format_map(mapping) -&gt; str 返回字符串</p>
<p><strong>参数：</strong>mapping 是一个字典对象</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">People = &#123;<span class="string">"name"</span>: <span class="string">"john"</span>, <span class="string">"age"</span>: <span class="number">33</span>&#125;</span><br><span class="line"><span class="string">"My name is &#123;name&#125;,iam&#123;age&#125; old"</span>.format_map(People)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对比案例</span></span><br><span class="line">定义一个字典</span><br><span class="line">student = &#123;<span class="string">'name'</span>:<span class="string">'张三'</span>,<span class="string">'class'</span>:<span class="string">'20200504'</span>,<span class="string">'score'</span>:<span class="number">748</span>&#125;</span><br><span class="line"></span><br><span class="line">使用format输出相关信息：</span><br><span class="line"><span class="string">'&#123;st[class]&#125;班&#123;st[name]&#125;总分：&#123;st[score]&#125;'</span>.format(st=student)</span><br><span class="line"><span class="string">'20200504班张三总分：748'</span></span><br><span class="line"></span><br><span class="line">format_map方法后如下</span><br><span class="line"></span><br><span class="line"><span class="string">'&#123;class&#125;班&#123;name&#125;总分：&#123;score&#125;'</span>.format_map(student)</span><br><span class="line"><span class="string">'20200504班张三总分：7</span></span><br></pre></td></tr></table></figure>



<h2 id="六、解决判断问题"><a href="#六、解决判断问题" class="headerlink" title="六、解决判断问题"></a>六、解决判断问题</h2><h3 id="19、endswith"><a href="#19、endswith" class="headerlink" title="19、endswith()"></a>19、endswith()</h3><p><strong>描述：</strong>判断字符串是否以指定字符或子字符串结尾。</p>
<p><strong>语法：</strong>str.endswith(“suffix”, start, end) 或str[start,end].endswith(“suffix”) 用于判断字符串中某段字符串是否以指定字符或子字符串结尾。—&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：</strong></p>
<ul>
<li>suffix — 后缀，可以是单个字符，也可以是字符串，还可以是元组（”suffix”中的引号要省略，常用于判断文件类型）。</li>
<li>start —索引字符串的起始位置。</li>
<li>end — 索引字符串的结束位置。</li>
</ul>
<p>注意：空字符的情况。返回值通常为True</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"I love python"</span>.endswith(<span class="string">'n'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="string">"I love python"</span>.endswith(<span class="string">"python"</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="string">"I love python"</span>.endswith(<span class="string">"n"</span>,<span class="number">0</span>,<span class="number">6</span>)<span class="comment"># 索引 i love 是否以“n”结尾。</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="string">"I love python"</span>.endswith(<span class="string">""</span>) <span class="comment">#空字符</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="string">"I love python"</span>.endswith((<span class="string">"n"</span>,<span class="string">"z"</span>))<span class="comment">#遍历元组的元素，存在即返回True，否者返回False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="string">"I love python"</span>.endswith((<span class="string">"k"</span>,<span class="string">"m"</span>))</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#元组案例</span></span><br><span class="line">file = <span class="string">"python.txt"</span></span><br><span class="line"><span class="keyword">if</span> file.endswith(<span class="string">"txt"</span>):</span><br><span class="line">    print(<span class="string">"该文件是文本文件"</span>)</span><br><span class="line"><span class="keyword">elif</span> file.endswith((<span class="string">"AVI"</span>,<span class="string">"WMV"</span>,<span class="string">"RM"</span>)):</span><br><span class="line">    print(<span class="string">"该文件为视频文件"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"文件格式未知</span></span><br></pre></td></tr></table></figure>



<h3 id="20、startswith"><a href="#20、startswith" class="headerlink" title="20、startswith()"></a>20、startswith()</h3><p><strong>描述：</strong>判断字符串是否以指定字符或子字符串开头。</p>
<p><strong>语法：</strong>str.endswith(“suffix”, start, end) 或</p>
<p>str[start,end].endswith(“suffix”) 用于判断字符串中某段字符串是否以指定字符或子字符串结尾。</p>
<p>—&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：</strong></p>
<ul>
<li>suffix — 后缀，可以是单个字符，也可以是字符串，还可以是元组（”suffix”中的引号要省略）。</li>
<li>start —索引字符串的起始位置。</li>
<li>end — 索引字符串的结束位置。</li>
</ul>
<p>注意：空字符的情况。返回值通常也为True</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"hello,i love python"</span>.startswith(<span class="string">"h"</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello,i love python"</span>.startswith(<span class="string">"l"</span>,<span class="number">2</span>,<span class="number">10</span>)<span class="comment"># 索引 llo,i lo 是否以“l”开头。</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello,i love python"</span>.startswith(<span class="string">""</span>) <span class="comment">#空字符</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello,i love python"</span>[<span class="number">0</span>:<span class="number">6</span>].startswith(<span class="string">"h"</span>) <span class="comment"># 只索引  hello,</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello,i love python"</span>[<span class="number">0</span>:<span class="number">6</span>].startswith(<span class="string">"e"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello,i love python"</span>[<span class="number">0</span>:<span class="number">6</span>].startswith(<span class="string">""</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello,i love python"</span>.startswith((<span class="string">"h"</span>,<span class="string">"z"</span>))<span class="comment">#遍历元组的元素，存在即返回True，否者返回False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello,i love python"</span>.startswith((<span class="string">"k"</span>,<span class="string">"m"</span>))</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="21、isalnum"><a href="#21、isalnum" class="headerlink" title="21、isalnum()"></a>21、isalnum()</h3><p><strong>描述：</strong>检测字符串是否由字母和数字组成。str中至少有一个字符且所有字符都是字母或数字则返回 True,否则返回 False</p>
<p><strong>语法：</strong>str.isalnum() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"seven-11"</span>.isalnum()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"seven11"</span>.isalnum()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"seven"</span>.isalnum()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"11"</span>.isalnum()</span><br><span class="line">Tr</span><br></pre></td></tr></table></figure>



<h3 id="22、isalpha"><a href="#22、isalpha" class="headerlink" title="22、isalpha()"></a>22、isalpha()</h3><p><strong>描述：</strong>检测字符串是否只由字母组成。字符串中至少有一个字符且所有字符都是字母则返回 True,否则返回 False。</p>
<p><strong>语法：</strong>str.isalpha() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：无</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"I love python"</span>.isalpha()<span class="comment">#存在空格返回False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"Ilovepython"</span>.isalpha()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"Ilovepython123"</span>.isalpha()</span><br><span class="line">Fals</span><br></pre></td></tr></table></figure>



<h3 id="23、isdecimal"><a href="#23、isdecimal" class="headerlink" title="23、isdecimal()"></a>23、isdecimal()</h3><p><strong>描述：</strong>检查字符串是否只包含十进制字符。字符串中若只包含十进制字符返回True，否则返回False。该方法只存在于unicode对象中。注意:定义一个十进制字符串，只需要在字符串前添加前缀 ‘u’ 即可。</p>
<p><strong>语法：</strong> str.isdecimal() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：无</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"123456"</span>.isdecimal()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="string">u"123456"</span>.isdecimal()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"123456python"</span>.isdecimal()</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="24、isdigit"><a href="#24、isdigit" class="headerlink" title="24、isdigit()"></a>24、isdigit()</h3><p><strong>描述：</strong>检测字符串是否只由数字组成.字符串中至少有一个字符且所有字符都是数字则返回 True,否则返回 False。</p>
<p><strong>语法：</strong>str.isdigit() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：无</strong></p>
<p>注：能判断“①”，不能判断中文数字。但 isnumeric() 函数可以。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"python"</span>.isdigit() <span class="comment">#全为字母</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"123"</span>.isdigit()  <span class="comment">#全为数字</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"python666"</span>.isdigit()   <span class="comment">#字母和数字的组合</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"一二三四五六七"</span>.isdigit() <span class="comment">#中文数字输出False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"①"</span>.isdigit()  </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h3 id="25、isidentifier"><a href="#25、isidentifier" class="headerlink" title="25、isidentifier()"></a>25、isidentifier()</h3><p><strong>描述：</strong>判断str是否是有效的标识符。str为符合命名规则的变量，保留标识符则返回True,否者返回False。</p>
<p><strong>语法：</strong>str.isidentifier() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：</strong>无</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"123"</span>.isidentifier()  <span class="comment">#变量名为123</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"def"</span>.isidentifier()  <span class="comment">#变量名为保留字</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"_123"</span>.isidentifier()  <span class="comment">#变量名有下划线开头</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"student"</span>.isidentifier()<span class="comment">#变量名由字母开端</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h3 id="26、islower"><a href="#26、islower" class="headerlink" title="26、islower()"></a>26、islower()</h3><p><strong>描述：</strong>检测字符串中的字母是否全由小写字母组成。（字符串中可包含非字母字符）字符串中包含至少一个区分大小写的字符，且所有这些区分大小写的字符都是小写，则返回 True，否则返回 False。</p>
<p><strong>语法：</strong>str.islower() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：</strong>无</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串中的字母全为小写</span></span><br><span class="line"><span class="string">"i love python"</span>.islower()  </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#字符串中的字母全为小写，也存在非字母的字符</span></span><br><span class="line"><span class="string">"我爱python！"</span>.islower() </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#字符串中有大写字符</span></span><br><span class="line"><span class="string">"I love python"</span>.islower() </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="27、isupper"><a href="#27、isupper" class="headerlink" title="27、isupper()"></a>27、isupper()</h3><p><strong>描述：</strong>检测字符串中的字母是否全由大写字母组成。（字符串中可包含非字母字符）。字符串中包含至少一个区分大小写的字符，且所有这些区分大小写的字符都是大写，则返回 True，否则返回 False。</p>
<p><strong>语法：</strong>str.isupper() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：</strong>无</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"I LOVE PYTHON"</span>.isupper() <span class="comment">#全为大写字母</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"i LOVE PYTHON"</span>.isupper()  <span class="comment">#存在小写字母</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"我爱PYTHON"</span>.isupper()  <span class="comment">#存在非字母的字符</span></span><br><span class="line">Tru</span><br></pre></td></tr></table></figure>



<h3 id="28、inumeric"><a href="#28、inumeric" class="headerlink" title="28、inumeric()"></a>28、inumeric()</h3><p><strong>描述：</strong>测字符串是否只由数字组成。这种方法是只适用于unicode对象。字符串中只包含数字字符，则返回 True，否则返回 False。</p>
<p><strong>语法：</strong>str.isnumeric() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：</strong>无</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">u"123456"</span>.isnumeric()  <span class="comment">#全为数字</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"123456"</span>.isnumeric()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"python666"</span>.isnumeric()  <span class="comment">#字母数字组合</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"一二三四五六"</span>.isnumeric()  <span class="comment">#中文数字</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"①"</span>.isnumeric()</span><br><span class="line">Tr</span><br></pre></td></tr></table></figure>



<h3 id="29、isprintable"><a href="#29、isprintable" class="headerlink" title="29、isprintable()"></a>29、isprintable()</h3><p><strong>描述：</strong>判断字符串中是否有打印后不可见的内容。如：\n \t 等字符。若字符串中不存在\n \t 等不可见的内容，则返回True,否者返回False。</p>
<p><strong>语法：</strong> str.isprintable() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：</strong>无</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不存在用print()打印后不可见的内容</span></span><br><span class="line"><span class="string">"i love  python"</span>.isprintable()  </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#存在用print()打印后不可见的内容 \n</span></span><br><span class="line"><span class="string">"i love python \n"</span>.isprintable() </span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"i love \t python"</span>.isprintable()</span><br><span class="line">Fals</span><br></pre></td></tr></table></figure>



<h3 id="30、isspace"><a href="#30、isspace" class="headerlink" title="30、isspace()"></a>30、isspace()</h3><p><strong>描述：</strong> 检测字符串是否只由空格组成。若字符串中只包含空格，则返回 True，否则返回 False。</p>
<p><strong>语法：</strong>str.isspace() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：</strong>无</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">"   "</span><span class="comment">#空格</span></span><br><span class="line">str2 = <span class="string">"i love python"</span> </span><br><span class="line">print(str1.isspace())</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">print(str2.isspace())</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">print(str2[<span class="number">1</span>].isspace()) <span class="comment">#字符串str2 的第二个字符为空格</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h3 id="31、istitle"><a href="#31、istitle" class="headerlink" title="31、istitle()"></a>31、istitle()</h3><p><strong>描述：</strong>检测判断字符串中所有单词的首字母是否为大写，且其它字母是否为小写，字符串中可以存在其它非字母的字符。若字符串中所有单词的首字母为大写，且其它字母为小写，则返回 True，否则返回 False.</p>
<p><strong>语法：</strong>str.istitle() -&gt; bool 返回值为布尔类型（True,False）</p>
<p><strong>参数：</strong>无</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"I Love Python"</span>.istitle() <span class="comment">#各单词的首字母均为大写，其余字母为小写</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="string">"I love python"</span>.istitle() </span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"I LOVE PYTHON"</span>.istitle()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"我爱Python"</span>.istitle()  <span class="comment">#存在其它非字母字符，</span></span><br><span class="line">Tru</span><br></pre></td></tr></table></figure>



<h2 id="七、字符串修剪"><a href="#七、字符串修剪" class="headerlink" title="七、字符串修剪"></a><strong>七、字符串修剪</strong></h2><h3 id="32、strip"><a href="#32、strip" class="headerlink" title="32、strip()"></a>32、strip()</h3><p><strong>描述：</strong>该函数的作用是去除字符串开头和结尾处指定的字符，不会去除字符串中间对应的字符</p>
<p><strong>语法：</strong>str.strip(chars)</p>
<p><strong>参数：</strong>chars – 要去除的字符 默认为空格或换行符。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认参数，去除了空格，\n \t \r字符，且未除去字符串中间相应的字符</span></span><br><span class="line">a = <span class="string">' \n111 aaa  '</span></span><br><span class="line">print(a.strip())</span><br><span class="line"><span class="number">111</span> aaa</span><br><span class="line"></span><br><span class="line"><span class="comment">#去除两端的指定字符</span></span><br><span class="line">b=<span class="string">'.-.word:我很帅.-.'</span></span><br><span class="line">print(b.strip(<span class="string">'.-.'</span>))</span><br><span class="line">word:我很帅</span><br><span class="line"></span><br><span class="line">c=<span class="string">'参考：来自公众号AI入门学习'</span></span><br><span class="line">print(c.strip(<span class="string">'参考：'</span>))</span><br><span class="line">来自公众号AI入门学</span><br></pre></td></tr></table></figure>



<h3 id="33、lstrip"><a href="#33、lstrip" class="headerlink" title="33、lstrip()"></a>33、lstrip()</h3><p><strong>描述：</strong>lstrip() 方法用于截掉字符串左边的空格或指定字符。</p>
<p><strong>语法：</strong>str.lstrip(chars)</p>
<p><strong>参数：</strong>chars–要去除的字符 默认为空格或换行符。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#去除左边指定字符</span></span><br><span class="line">a = <span class="string">'--我爱Python--'</span></span><br><span class="line">a.lstrip(<span class="string">'--'</span>)</span><br><span class="line"><span class="string">'我爱Python--'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重复的值只需要写一个</span></span><br><span class="line">a.lstrip(<span class="string">'-'</span>)</span><br><span class="line"><span class="string">'我爱Python--'</span></span><br></pre></td></tr></table></figure>



<h3 id="34、-rstrip"><a href="#34、-rstrip" class="headerlink" title="34、 rstrip()"></a>34、 rstrip()</h3><p><strong>描述：</strong> 删除 str 字符串末尾的指定字符（默认为空格）</p>
<p><strong>语法：</strong>str.rstrip(chars)</p>
<p><strong>参数：</strong>chars –要去除的字符 默认为空格或换行符。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#去除左边指定字符</span></span><br><span class="line">a = <span class="string">'6234412134445533-456'</span></span><br><span class="line">a.rstrip(<span class="string">'-456'</span>)</span><br><span class="line"><span class="string">'6234412134445533'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对一个列表所有的字符串进行去除</span></span><br><span class="line">ls = [<span class="string">'34667777777-456'</span>,<span class="string">'62344121344433-456'</span>,<span class="string">'28993333455-456'</span>]</span><br><span class="line">[i.rstrip(<span class="string">'-456'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> ls]</span><br><span class="line">[<span class="string">'34667777777'</span>, <span class="string">'62344121344433'</span>, <span class="string">'28993333'</span>]</span><br></pre></td></tr></table></figure>



<h2 id="八、字符串加密解密"><a href="#八、字符串加密解密" class="headerlink" title="八、字符串加密解密"></a><strong>八、字符串加密解密</strong></h2><h3 id="35、maketrans"><a href="#35、maketrans" class="headerlink" title="35、maketrans()"></a>35、maketrans()</h3><p><strong>描述：</strong>制作翻译表，删除表，常与translate()函数连用。 即：返回用于str.translate方法翻译的转换表。</p>
<p><strong>语法：</strong>str.maketrans(intab, outtab，delchars)</p>
<p><strong>参数：</strong></p>
<ul>
<li>intab – 字符串中要替代的字符组成的字符串。</li>
<li>outtab – 相应的映射字符的字符串。</li>
<li>delchars – 可选参数，表示要删除的字符组成的字符串。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str.maketrans() 生成一个字符一对一映射的table，然后使用 translate(table) 对字符串S中的每个字符进行映射。</span><br><span class="line">例如，现在想要对<span class="string">"I love fairy"</span>做一个简单的加密，将里面部分字符都替换为数字，这样别人就不知道转换后的这句话是什么意思。</span><br><span class="line">in_str  = <span class="string">'afcxyo'</span></span><br><span class="line">out_str = <span class="string">'123456'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># maketrans()生成映射表</span></span><br><span class="line">map_table=str.maketrans(in_str,out_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用translate()进行映射</span></span><br><span class="line">my_love=<span class="string">'I love fairy'</span></span><br><span class="line">my_love.translate(map_table)</span><br><span class="line"><span class="string">'I l6ve 21ir5'</span></span><br><span class="line"></span><br><span class="line">注意maketrans(x, y, z]) 中的x和y都是字符串，且长度必须相等。</span><br><span class="line">如果maketrans(x, y, z]) 给定了第三个参数z，这这个参数字符串中的每个字符都会被映射为<span class="literal">None</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">#'yo'都会被隐藏了</span></span><br><span class="line">map_table=str.maketrans(in_str,out_str,<span class="string">'yo'</span>)</span><br><span class="line">my_love=<span class="string">'I love fairy'</span></span><br><span class="line">my_love.translate(map_table)</span><br><span class="line"><span class="string">'I lve 21</span></span><br></pre></td></tr></table></figure>

<h3 id="36、translate"><a href="#36、translate" class="headerlink" title="36、translate()"></a>36、translate()</h3><p><strong>描述：</strong>过滤(删除)，翻译字符串。即根据maketrans()函数给出的字符映射转换表来转换字符串中的字符。</p>
<p>注：translate()函数是先过滤(删除)，再根据maketrans()函数返回的转换表来翻译。</p>
<p><strong>语法：</strong>str.translate(table)</p>
<p><strong>参数：</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">见上述案例</span><br></pre></td></tr></table></figure>



<h2 id="九、分割字符串"><a href="#九、分割字符串" class="headerlink" title="九、分割字符串"></a>九、分割字符串</h2><h3 id="37、partition"><a href="#37、partition" class="headerlink" title="37、partition()"></a>37、partition()</h3><p><strong>描述：</strong>根据指定的分隔符(sep)将字符串进行分割。从字符串左边开始索引分隔符sep,索引到则停止索引。</p>
<p><strong>语法：</strong> str.partition(sep)</p>
<p><strong>参数：</strong>sep —— 指定的分隔符。</p>
<p><strong>返回值：</strong>(head, sep, tail) 返回一个三元元组，head:分隔符sep前的字符串，sep:分隔符本身，tail:分隔符sep后的字符串。如果字符串包含指定的分隔符sep，则返回一个三元元组，第一个为分隔符sep左边的子字符串，第二个为分隔符sep本身，第三个为分隔符sep右边的子字符串。如果字符串不包含指定的分隔符sep,仍然返回一个三元元组，第一个元素为字符串本身，第二第三个元素为空字符串</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">'https://www.google.com.hk/'</span></span><br><span class="line"></span><br><span class="line">string.partition(<span class="string">"://"</span>) <span class="comment">#字符串str中存在sep"://"</span></span><br><span class="line">(<span class="string">'https'</span>, <span class="string">'://'</span>, <span class="string">'www.google.com.hk/'</span>)</span><br><span class="line"></span><br><span class="line">string.partition(<span class="string">","</span>)  <span class="comment">#字符串str中不存在sep",",返回了两个空字符串。</span></span><br><span class="line">(<span class="string">'https://www.google.com.hk/'</span>, <span class="string">''</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">string.partition(<span class="string">"."</span>)  <span class="comment">#字符串str中存在两个"." 但索引到www后的"."  停止索引。</span></span><br><span class="line">(<span class="string">'https://www'</span>, <span class="string">'.'</span>, <span class="string">'google.com.hk/'</span>)</span><br><span class="line"></span><br><span class="line">type(string.partition(<span class="string">"://"</span>)) <span class="comment">#返回的是tuple类型</span></span><br><span class="line">tup</span><br></pre></td></tr></table></figure>



<h3 id="38、rpartition"><a href="#38、rpartition" class="headerlink" title="38、rpartition()"></a>38、rpartition()</h3><p><strong>描述：</strong>根据指定的分隔符(sep)将字符串进行分割。从字符串右边(末尾)开始索引分隔符sep,索引到则停止索引。</p>
<p><strong>语法：</strong> str.rpartition(sep)</p>
<p><strong>参数：</strong>sep —— 指定的分隔符。</p>
<p><strong>返回值：</strong> (head, sep, tail) 返回一个三元元组，head:分隔符sep前的字符串，sep:分隔符本身，tail:分隔符sep后的字符串。如果字符串包含指定的分隔符sep，则返回一个三元元组，第一个为分隔符sep左边的子字符串，第二个为分隔符sep本身，第三个为分隔符sep右边的子字符串。如果字符串不包含指定的分隔符sep,仍然返回一个三元元组，第一个元素为字符串本身，第二第三个元素为空字符串。</p>
<p>注：rpartition()函数与partition()函数用法相似，rpartition()函数从右边(末尾)开始索引，partition()函数从左边开始索引。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">'https://www.google.com.hk/'</span></span><br><span class="line"></span><br><span class="line">string.rpartition(<span class="string">"."</span>)  <span class="comment">#字符串str中不存在sep",",返回了两个空字符串。</span></span><br><span class="line"> (<span class="string">'https://www.google.com'</span>, <span class="string">'.'</span>, <span class="string">'hk/'</span>)</span><br><span class="line">string.partition(<span class="string">"."</span>)  <span class="comment">#字符串str中不存在sep",",返回了两个空字符串。</span></span><br><span class="line">(<span class="string">'https://www'</span>, <span class="string">'.'</span>, <span class="string">'google.com.hk/'</span>)</span><br></pre></td></tr></table></figure>



<h3 id="39、split"><a href="#39、split" class="headerlink" title="39、split()"></a>39、split()</h3><p><strong>描述：</strong>拆分字符串。通过指定分隔符sep对字符串进行分割，并返回分割后的字符串列表。</p>
<p><strong>语法：</strong> str.split(sep=None, maxsplit=-1) [n]</p>
<ul>
<li>sep —— 分隔符，默认为空格,但不能为空即(“)。</li>
<li>maxsplit —— 最大分割参数，默认参数为-1。</li>
<li>[n] —— 返回列表中下标为n的元素。列表索引的用法。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认空格分割</span></span><br><span class="line">str1 = <span class="string">"I love python"</span></span><br><span class="line">str1.split()</span><br><span class="line">[<span class="string">'I'</span>, <span class="string">'love'</span>, <span class="string">'python'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#取第三位</span></span><br><span class="line">str1.split()[<span class="number">2</span>]</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以"."为分隔符,maxsplit默认为-1</span></span><br><span class="line">str2 = <span class="string">'列夫·尼古拉耶维奇·托尔斯泰'</span></span><br><span class="line">str2.split(<span class="string">'·'</span>)</span><br><span class="line">[<span class="string">'列夫'</span>, <span class="string">'尼古拉耶维奇'</span>, <span class="string">'托尔斯泰'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#以"."为分隔符,只分割一次。</span></span><br><span class="line">str2.split(<span class="string">'·'</span>,<span class="number">1</span>)</span><br><span class="line"> [<span class="string">'列夫'</span>, <span class="string">'尼古拉耶维奇·托尔斯泰</span></span><br></pre></td></tr></table></figure>



<h3 id="40、rsplit"><a href="#40、rsplit" class="headerlink" title="40、rsplit()"></a><strong>40、rsplit()</strong></h3><p><strong>描述：</strong>拆分字符串。通过指定分隔符sep对字符串进行分割，并返回分割后的字符串列表,类似于split()函数，只不过 rsplit()函数是从字符串右边(末尾)开始分割。</p>
<p><strong>语法：</strong>str.rsplit(sep=None, maxsplit=-1) -&gt; list of strings 返回 字符串列表 或str.rsplit(sep=None, maxsplit=-1)[n]</p>
<p><strong>参数：</strong></p>
<ul>
<li>sep —— 分隔符，默认为空格,但不能为空即(“)。</li>
<li>maxsplit —— 最大分割参数，默认参数为-1。</li>
<li>[n] —— 返回列表中下标为n的元素。列表索引的用法。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 只搜索到一个sep时，两者结果相同</span></span><br><span class="line"><span class="string">'abcxyzopq'</span>.partition(<span class="string">'xy'</span>)</span><br><span class="line">(<span class="string">'abc'</span>, <span class="string">'xy'</span>, <span class="string">'zopq'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'abcxyzopq'</span>.rpartition(<span class="string">'xy'</span>)</span><br><span class="line">(<span class="string">'abc'</span>, <span class="string">'xy'</span>, <span class="string">'zopq'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索到多个sep时，分别从左第一个、右第一个sep分割</span></span><br><span class="line"><span class="string">'abcxyzopxyq'</span>.partition(<span class="string">'xy'</span>)</span><br><span class="line">(<span class="string">'abc'</span>, <span class="string">'xy'</span>, <span class="string">'zopxyq'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'abcxyzopxyq'</span>.rpartition(<span class="string">'xy'</span>)</span><br><span class="line">(<span class="string">'abcxyzop'</span>, <span class="string">'xy'</span>, <span class="string">'q</span></span><br></pre></td></tr></table></figure>



<h3 id="41、splitlines"><a href="#41、splitlines" class="headerlink" title="41、splitlines()"></a>41、splitlines()</h3><p><strong>描述：</strong>按照(‘\n’, ‘\r’, \r\n’等)分隔，返回一个包含各行作为元素的列表，默认不包含换行符。\n 换行符 \r 回车符 \r\n 回车+换行</p>
<p><strong>语法：</strong>S.splitlines([keepends=False])</p>
<p><strong>参数：</strong>keepends – 在输出结果里是否去掉行界符(‘\r’, ‘\r\n’, \n’等)，默认为 False，不包含行界符，如果为 True，则保留行界符。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串以换行符为分隔符拆分，去掉换行符</span></span><br><span class="line"><span class="string">'HOW\nSOFT\nWORKS'</span>.splitlines()</span><br><span class="line">[<span class="string">'HOW'</span>, <span class="string">'SOFT'</span>, <span class="string">'WORKS'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果keepends为True，保留换行符</span></span><br><span class="line"><span class="string">'HOW\nSOFT\nWORKS'</span>.splitlines(<span class="literal">True</span>)</span><br><span class="line">[<span class="string">'HOW\n'</span>, <span class="string">'SOFT\n'</span>, <span class="string">'WORKS'</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">"123\n456\r789\r\nabc"</span>.splitlines()</span><br><span class="line">[<span class="string">'123'</span>, <span class="string">'456'</span>, <span class="string">'789'</span>, <span class="string">'abc'</span></span><br></pre></td></tr></table></figure>



<h3 id="42、join"><a href="#42、join" class="headerlink" title="42、join()"></a>42、join()</h3><p><strong>描述：</strong>将iterable变量的每一个元素后增加一个str字符串。</p>
<p><strong>语法：</strong> sep.join(iterable)</p>
<ul>
<li>sep——分隔符。可以为空。</li>
<li>iterable—— 要连接的变量 ，可以是 字符串，元组，字典，列表等。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python中经常看到join，特别是在自然语言处理的时候，分词什么的，但是很多初学者不理解其中的意思，这里进行详细的介绍，希望对大家能有帮助。</span><br><span class="line">将可迭代对象(iterable)中的字符串使用string连接起来。注意，iterable中必须全部是字符串类型，否则报错。如果你还是python的初学者，还不知道iterable是什么，却想来看看join的具体语法，那么你可以暂时将它理解为：字符串string、列表list、元组tuple、字典dict、集合set。当然还有生成器generator等也可以用该方法。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）字符串</span><br><span class="line">L=<span class="string">'python'</span></span><br><span class="line"><span class="string">'_'</span>.join(L)</span><br><span class="line"><span class="string">'p_y_t_h_o_n'</span></span><br><span class="line"><span class="string">'_uu_'</span>.join(L)</span><br><span class="line"><span class="string">'p_uu_y_uu_t_uu_h_uu_o_uu_n'</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）元组</span><br><span class="line">L1=(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>)</span><br><span class="line"><span class="string">'_'</span>.join(L1)</span><br><span class="line"><span class="string">'1_2_3'</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）集合。注意，集合无序。</span><br><span class="line">L2=&#123;<span class="string">'p'</span>,<span class="string">'y'</span>,<span class="string">'t'</span>,<span class="string">'h'</span>,<span class="string">'o'</span>,<span class="string">'n'</span>&#125;</span><br><span class="line"><span class="string">'_'</span>.join(L2)</span><br><span class="line"><span class="string">'t_n_o_h_y_p'</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）列表</span><br><span class="line">L2=[<span class="string">'py'</span>,<span class="string">'th'</span>,<span class="string">'o'</span>,<span class="string">'n'</span>]</span><br><span class="line"><span class="string">'_'</span>.join(L2)</span><br><span class="line"><span class="string">'py_th_o_n'</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）字典</span><br><span class="line">L3=&#123;<span class="string">'name'</span>:<span class="string">"malongshuai"</span>,<span class="string">'gender'</span>:<span class="string">'male'</span>,<span class="string">'from'</span>:<span class="string">'China'</span>,<span class="string">'age'</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="string">'_'</span>.join(L3)</span><br><span class="line"><span class="string">'name_gender_from_age'</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）iterable参与迭代的部分必须是字符串类型，不能包含数字或其他类型。</span><br><span class="line">L1=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="string">'_'</span>.join(L1)</span><br><span class="line">TypeError: sequence item <span class="number">0</span>: expected str instance, int found</span><br><span class="line"></span><br><span class="line">以下两种也不能join。</span><br><span class="line">L1=(<span class="string">'ab'</span>,<span class="number">2</span>)</span><br><span class="line">L2=(<span class="string">'AB'</span>,&#123;<span class="string">'a'</span>,<span class="string">'</span></span><br></pre></td></tr></table></figure>



<h2 id="九、字符串替换"><a href="#九、字符串替换" class="headerlink" title="九、字符串替换"></a>九、字符串替换</h2><h3 id="43、replace-函数"><a href="#43、replace-函数" class="headerlink" title="43、replace()函数"></a>43、replace()函数</h3><p><strong>描述：把</strong>str.中的 old 替换成 new,如果 count 指定，则替换不超过 count次.。</p>
<p><strong>语法：</strong>str.replace(old, new, count)</p>
<p><strong>参数：</strong></p>
<ul>
<li>old —— 将被替换的子字符串。</li>
<li>new —— 新子字符串，用于替换old子字符串。</li>
<li>count —— 替换的次数，默认全部替换。</li>
</ul>
<p><strong>案例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"我的小伙伴张三"</span></span><br><span class="line">s.replace(<span class="string">"张三"</span>,<span class="string">"马云"</span>)</span><br><span class="line"><span class="string">'我的小伙伴马云'</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">"I love python"</span></span><br><span class="line"><span class="comment">#默认字符串中的全部"o" 全部替换为"w"</span></span><br><span class="line">s.replace(<span class="string">"o"</span>,<span class="string">"w"</span>) </span><br><span class="line"><span class="string">'I lwve pythwn'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#只替换一个"o" </span></span><br><span class="line">s.replace(<span class="string">"o"</span>,<span class="string">"w"</span>,<span class="number">1</span>)</span><br><span class="line"><span class="string">'I lwve python'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#子字符串可以是多个字符。</span></span><br><span class="line">s.replace(<span class="string">"python"</span>,<span class="string">"java"</span>)</span><br><span class="line"><span class="string">'I love jav</span></span><br></pre></td></tr></table></figure>



<h3 id="44、expandtabs"><a href="#44、expandtabs" class="headerlink" title="44、expandtabs()"></a><strong>44、expandtabs()</strong></h3><p>描述：将字符串S中的 \t 替换为一定数量的空格。默认N=8。</p>
<p>语法： str.expandtabs(tabsize=8)</p>
<p>tabsize 的默认值为8。tabsize值为0到7等效于tabsize=8。tabsize每增加1，原字符串中“\t”的空间会多加一个空格。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'01\t012\t0123\t01234'</span>.expandtabs(<span class="number">4</span>)</span><br><span class="line"><span class="string">'01  012 0123    01234'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'01\t012\t0123\t01234'</span>.expandtabs(<span class="number">8</span>)</span><br><span class="line"><span class="string">'01      012     0123    01234'</span></span><br></pre></td></tr></table></figure>



<h2 id="十、统计字符次数"><a href="#十、统计字符次数" class="headerlink" title="十、统计字符次数"></a><strong>十、统计字符次数</strong></h2><h3 id="45、count"><a href="#45、count" class="headerlink" title="45、count()"></a>45、count()</h3><p><strong>描述：</strong>统计字符串里某个字符出现的次数。可以选择字符串索引的起始位置和结束位置。</p>
<p><strong>语法：</strong>str.count(“char”, start,end) 或 str.count(“char”)</p>
<ul>
<li>str —— 为要统计的字符(可以是单字符，也可以是多字符)。</li>
<li>star —— 为索引字符串的起始位置，默认参数为0。</li>
<li>end —— 为索引字符串的结束位置，默认参数为字符串长度即len(str)。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'abc--qo-ab'</span>.count(<span class="string">'ab'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment">#从第二位开始查找</span></span><br><span class="line"><span class="string">'abc--qo-ab'</span>.count(<span class="string">'ab'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">#不包括边界</span></span><br><span class="line"><span class="string">'abc--qo-ab'</span>.count(<span class="string">'ab'</span>,<span class="number">1</span>,<span class="number">9</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis中批量删除Key</title>
    <url>/2019/11/20/Redis%E4%B8%AD%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4Key/</url>
    <content><![CDATA[<p>最近在自己的阿里云服务器上跑一个Redis容器，不小心监听了宿主机器的0.0.0.0地址，而且Redis server裸奔没密码，被嗅探到并植入了一堆辣鸡Key，网卡流量跑了接近1TB。还好是docker跑的，因为容器的隔离，宿主机器没被植入啥后门。修复的措施也比较简单，直接rm了docker容器，重新跑了一个redis，把端口修改为只监听127.0.0.1的本机地址，问题解决。</p>
<p>等等，容器的安全搞定了，那一堆Redis的Key怎么清理掉呢？搜索了一下，Redis本身并没有提供批量删除Key的功能。但是，我们可以用一些骚操作来实现批量Key的删除。</p>
<a id="more"></a>

<p>大致使用到的骚操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli --scan --pattern users:* | xargs redis-cli del</span><br></pre></td></tr></table></figure>

<p>如果你使用的Redis版本为4.0或者更高，还可以使用<a href="https://redis.io/commands/unlink" target="_blank" rel="noopener"><code>unlink</code></a>命令来替代<code>del</code>命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli --scan --pattern users:* | xargs redis-cli unlink</span><br></pre></td></tr></table></figure>

<h3 id="所以，这个脚本到底实现了啥？"><a href="#所以，这个脚本到底实现了啥？" class="headerlink" title="所以，这个脚本到底实现了啥？"></a>所以，这个脚本到底实现了啥？</h3><ul>
<li>首先，我们使用<code>redis-cli --scan --pattern</code>模糊匹配出了所有以<code>users:</code>打头的Redis Key，每个Key会输出为一行。</li>
<li>然后，这样的输出结果，通过管道操作交给了<code>xargs</code>命令来处理，<code>xargs</code>命令负责把多行的输出合并为一行，并传递给<code>redis-cli del</code>命令。所以最终执行的效果类似于<code>redis-cli del   ...</code></li>
<li>如果有几千个Key符合这样的匹配，都会通过<code>xargs</code>命令，传递给<code>redis-cli del</code>一并删除。</li>
</ul>
<p>转载自： <a href="https://xiaozhou.net/redis-batch-delete-2019-06-07.html" target="_blank" rel="noopener">https://xiaozhou.net/redis-batch-delete-2019-06-07.html</a>  喜欢的话去打赏作者吧</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell/Python 字符串分割为数组</title>
    <url>/2020/01/04/Shell-Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%BA%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>Shell中要将字符串列表转变为数组，只需要在前面加()，所以关键是将分隔符转变为空格分隔，常用有下面几种方法</p>
<h3 id="Shell分割字符串为数组"><a href="#Shell分割字符串为数组" class="headerlink" title="Shell分割字符串为数组"></a>Shell分割字符串为数组</h3><h5 id="方法一-借助于-str-来处理"><a href="#方法一-借助于-str-来处理" class="headerlink" title="方法一: 借助于{str//,/}来处理"></a>方法一: 借助于{str//,/}来处理</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># str="ONE,TWO,THREE,FOUR"</span></span><br><span class="line"><span class="comment"># arr=($&#123;str//,/&#125;)</span></span><br><span class="line"><span class="comment"># echo $&#123;arr[@]&#125;</span></span><br><span class="line">ONE TWO THREE FOUR</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h5 id="方法二-借助于tr命令来处理"><a href="#方法二-借助于tr命令来处理" class="headerlink" title="方法二: 借助于tr命令来处理"></a>方法二: 借助于tr命令来处理</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># str="ONE,TWO,THREE,FOUR"</span></span><br><span class="line"><span class="comment"># arr=(`echo $str | tr ',' ' '`) </span></span><br><span class="line"><span class="comment"># echo $&#123;arr[@]&#125;</span></span><br><span class="line">ONE TWO THREE FOUR</span><br></pre></td></tr></table></figure>

<h5 id="方法三-借助于awk命令来处理"><a href="#方法三-借助于awk命令来处理" class="headerlink" title="方法三: 借助于awk命令来处理"></a>方法三: 借助于awk命令来处理</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># str="ONE,TWO,THREE,FOUR"</span></span><br><span class="line"><span class="comment"># arr=($(echo $str | awk 'BEGIN&#123;FS=",";OFS=" "&#125; &#123;print $1,$2,$3,$4&#125;'))</span></span><br><span class="line"><span class="comment"># echo $&#123;str[*]&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="方法四-借助于IFS来处理分隔符"><a href="#方法四-借助于IFS来处理分隔符" class="headerlink" title="方法四: 借助于IFS来处理分隔符"></a>方法四: 借助于IFS来处理分隔符</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># str="ONE,TWO,THREE,FOUR"</span></span><br><span class="line"><span class="comment"># IFS=","</span></span><br><span class="line"><span class="comment"># arr=(str)</span></span><br><span class="line"><span class="comment"># echo $&#123;str[@]&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="方法五：使用AWK分割无分隔符的文本"><a href="#方法五：使用AWK分割无分隔符的文本" class="headerlink" title="方法五：使用AWK分割无分隔符的文本"></a>方法五：使用AWK分割无分隔符的文本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># text="abcdefghijklmnopqrstuvwxyz"</span></span><br><span class="line"><span class="comment"># echo $text | awk 'BEGIN &#123; FS=OFS="" &#125; &#123; for( i=1; i&lt;=NF; i++ ) &#123; if( i%4==0 &amp;&amp; i!=NF ) &#123; printf $i" " &#125; else &#123; printf $i &#125;&#125; print "" &#125;'</span></span><br></pre></td></tr></table></figure>



<h3 id="Python分隔字符串为数组"><a href="#Python分隔字符串为数组" class="headerlink" title="Python分隔字符串为数组"></a>Python分隔字符串为数组</h3><h5 id="re"><a href="#re" class="headerlink" title="re"></a>re</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.findall(<span class="string">'..'</span>,<span class="string">'1234567890'</span>)</span><br><span class="line">[<span class="string">'12'</span>, <span class="string">'34'</span>, <span class="string">'56'</span>, <span class="string">'78'</span>, <span class="string">'90'</span>]</span><br></pre></td></tr></table></figure>

<p>也可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.findall(<span class="string">'..?'</span>, <span class="string">'123456789'</span>)</span><br><span class="line">[<span class="string">'12'</span>, <span class="string">'34'</span>, <span class="string">'56'</span>, <span class="string">'78'</span>, <span class="string">'9'</span>]</span><br></pre></td></tr></table></figure>

<p>您还可以执行以下操作，以简化较长块的正则表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.findall(<span class="string">'.&#123;1,2&#125;'</span>, <span class="string">'123456789'</span>)</span><br><span class="line">[<span class="string">'12'</span>, <span class="string">'34'</span>, <span class="string">'56'</span>, <span class="string">'78'</span>, <span class="string">'9'</span>]</span><br></pre></td></tr></table></figure>

<h5 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">split_string = <span class="keyword">lambda</span> x, n: [x[i:i+n] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(x), n)]</span><br><span class="line">s = <span class="string">'1234567890'</span></span><br><span class="line">split_string(s,<span class="number">2</span>)</span><br><span class="line">[<span class="string">'12'</span>, <span class="string">'34'</span>, <span class="string">'56'</span>, <span class="string">'78'</span>, <span class="string">'90'</span>]</span><br></pre></td></tr></table></figure>

<h5 id="other"><a href="#other" class="headerlink" title="other"></a>other</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'1234567890'</span></span><br><span class="line">o = []</span><br><span class="line"><span class="keyword">while</span> s:</span><br><span class="line">    o.append(s[:<span class="number">2</span>])</span><br><span class="line">    s = s[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">'1234567890'</span></span><br><span class="line">print([s[idx:idx+<span class="number">2</span>] <span class="keyword">for</span> idx,val <span class="keyword">in</span> enumerate(s) <span class="keyword">if</span> idx%<span class="number">2</span> == <span class="number">0</span>])</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>shell</tag>
        <tag>字符串</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell/Python中创建随机密码</title>
    <url>/2019/12/16/Shell-Python%E4%B8%AD%E5%88%9B%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>生成16位数字+字母大小写密码</p>
</blockquote>
<h5 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head -c 160 /dev/urandom | tr -dc a-z0-9A-Z |head -c 16</span><br><span class="line">cat /dev/urandom | tr -dc <span class="string">'a-zA-Z0-9'</span> | fold -w 16 | sed 1q</span><br></pre></td></tr></table></figure>

<h5 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h5><blockquote>
<p>python3中为string.ascii_letters,而python2下则可以使用string.letters和string.ascii_letters</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPassword</span><span class="params">(length=<span class="number">8</span>, chars=string.ascii_letters + string.digits)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([choice(chars) <span class="keyword">for</span> i <span class="keyword">in</span> range(length)])</span><br><span class="line"></span><br><span class="line">print(getPassword(<span class="number">16</span>))</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab 几个特殊字符的含义</title>
    <url>/2019/11/22/crontab-%E5%87%A0%E4%B8%AA%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>*</code></td>
<td align="left">全部。意思是在该时间的任意点都应当执行</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">不指定，任意。仅用于 日(月)和日(周)。<code>0 0 5 * ?</code> 代表每个月的第5天零点，不论星期几。</td>
</tr>
<tr>
<td align="left"><code>0</code></td>
<td align="left"><code>0 ? * 1</code> 代表每周一，不论是当月的哪天。</td>
</tr>
<tr>
<td align="left"><code>,</code></td>
<td align="left">多个值的分隔符，例如<code>1,5,10</code> - 代表连续值，例如<code>1-20</code></td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left">步长。例如 <code>5/15</code>，代表从5开始，以15为步长。因此，当<code>5/15</code>位于分钟的位置时，表示小时内的第5、20、35和50分钟</td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left">最后一天。可以是每月最后一天或者每周最后一天。如果用在 天(周)字段，并且前面加数字，则表示最后一个周N。例如<code>5L</code>，表示最后一个周五（5表示周五，L表示最后）。</td>
</tr>
<tr>
<td align="left"><code>W</code></td>
<td align="left">工作日，指周一到周五的任意一天</td>
</tr>
<tr>
<td align="left"><code>#</code></td>
<td align="left">表示第几个的意思，例如 <code>6#3</code>，表示当月第3个星期六（6表示周六，3表示第3个）</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 0 9 5L 最后一个周五早上9点* 0 9 6#3 当月第3个星期六</span><br></pre></td></tr></table></figure>



<p>转载自： <a href="https://hdj.me/the-meaning-of-several-special-characters-for-crontab/" target="_blank" rel="noopener">https://hdj.me/the-meaning-of-several-special-characters-for-crontab/</a> </p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 10 WSL2 安装使用及Docker安装</title>
    <url>/2020/06/05/Windows-10-WSL2-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E5%8F%8ADocker%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-WSL2-子系统安装使用"><a href="#1-WSL2-子系统安装使用" class="headerlink" title="1. WSL2 子系统安装使用"></a>1. WSL2 子系统安装使用</h2><blockquote>
<p>WLS2 需要 Windows 10 Version 2004 Build 19041 或更高版本，使用 Windows Update 自动更新到2004版本。如果没有检测到更新，可以去微软官网下载<a href="https://software-download.microsoft.com/download/pr/MediaCreationTool2004.exe" target="_blank" rel="noopener"> 易升 </a>工具并安装运行。工具会检测到更新并安装。</p>
<p>如果需要使用 Docker for Windows，需要下载<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi" target="_blank" rel="noopener"> WLS Updata </a>补丁并安装。</p>
</blockquote>
<h4 id="1-1-启用Linux子系统"><a href="#1-1-启用Linux子系统" class="headerlink" title="1.1 启用Linux子系统"></a>1.1 启用Linux子系统</h4><p>打开 <code>控制面板</code> -&gt; <code>程序</code> -&gt; <code>启用或关闭Windows功能</code>。找到 <code>适用于Linux的Windows子系统</code> 和 <code>虚拟机平台</code>，勾选这两项之后确定，并重新启动计算机。</p>
<p>也可以通过命令行启用，以<code>管理员身份</code>打开 PowerShell，输入如下命令，并 <code>重启电脑</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启 虚拟机平台 可选组件</span><br><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform</span><br><span class="line"># 开启 适用于Linux的Windows子系统 可选组件</span><br><span class="line">dism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:Microsoft-Windows-Subsystem-Linux &#x2F;all &#x2F;norestart</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="1-2-安装Ubuntu-20-04"><a href="#1-2-安装Ubuntu-20-04" class="headerlink" title="1.2 安装Ubuntu 20.04"></a>1.2 安装Ubuntu 20.04</h4><p>打开 <code>Microsoft Store</code>搜索  <code>Linux</code>，选择 <code>Ubuntu 20.04</code> 并点击 <code>安装</code>：</p>
<p>安装过程中，请设置用户名及密码，如果需要使用root用户，则需要执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> passwd root</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure>

<!--more-->

<p>为了更方便的使用子系统，推荐安装 Terminal </p>
<h4 id="1-3-安装Windows-Terminal"><a href="#1-3-安装Windows-Terminal" class="headerlink" title="1.3 安装Windows Terminal"></a>1.3 安装Windows Terminal</h4><p>打开 <code>Microsoft Store</code>， 搜索 <code>Windows Terminal</code>，选择 <code>安装</code>.</p>
<h4 id="1-4-WSL常用命令"><a href="#1-4-WSL常用命令" class="headerlink" title="1.4 WSL常用命令"></a>1.4 WSL常用命令</h4><h5 id="1-4-1-查看现有的WSL"><a href="#1-4-1-查看现有的WSL" class="headerlink" title="1.4.1 查看现有的WSL"></a>1.4.1 查看现有的WSL</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -l -v <span class="comment"># 或 wsl --list --verbose </span></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  NAME                   STATE           VERSION</span><br><span class="line">* docker-desktop         Stopped         2</span><br><span class="line">  Ubuntu-20.04           Stopped         2</span><br></pre></td></tr></table></figure>

<h5 id="1-4-2-WSL1转化为WSL2"><a href="#1-4-2-WSL1转化为WSL2" class="headerlink" title="1.4.2 WSL1转化为WSL2"></a>1.4.2 WSL1转化为WSL2</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">set</span>-version $已经使用的WSL的名字 2</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">正在进行转换，这可能需要几分钟时间...</span><br><span class="line">有关与 WSL 2 的主要区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line">转换完成。</span><br></pre></td></tr></table></figure>

<h5 id="1-4-3-将WSL2设置为默认"><a href="#1-4-3-将WSL2设置为默认" class="headerlink" title="1.4.3 将WSL2设置为默认"></a>1.4.3 将WSL2设置为默认</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">set</span>-default-version 2</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">有关与 WSL 2 的主要区别的信息，请访问 https://aka.ms/wsl2</span><br></pre></td></tr></table></figure>

<h5 id="1-4-4-立即终止所有正在运行的发行版和WSL2虚拟机"><a href="#1-4-4-立即终止所有正在运行的发行版和WSL2虚拟机" class="headerlink" title="1.4.4 立即终止所有正在运行的发行版和WSL2虚拟机"></a>1.4.4 立即终止所有正在运行的发行版和WSL2虚拟机</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>

<h5 id="1-4-5-获取宿主Windows的IP"><a href="#1-4-5-获取宿主Windows的IP" class="headerlink" title="1.4.5 获取宿主Windows的IP"></a>1.4.5 获取宿主Windows的IP</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># WSL2使用的是虚拟机技术和WSL第一版本不一样，和宿主windows不在同一个网络内</span></span><br><span class="line"><span class="comment"># 获取宿主windows的ip</span></span><br><span class="line"><span class="built_in">export</span> windows_host=`ipconfig.exe | grep -n4 WSL  | tail -n 1 | awk -F<span class="string">":"</span> <span class="string">'&#123; print $2 &#125;'</span>  | sed <span class="string">'s/^[ \r\n\t]*//;s/[ \r\n\t]*$//'</span>`</span><br></pre></td></tr></table></figure>

<h5 id="1-4-6-全面设置WSL内的代理"><a href="#1-4-6-全面设置WSL内的代理" class="headerlink" title="1.4.6 全面设置WSL内的代理"></a>1.4.6 全面设置WSL内的代理</h5><p>假设你的宿主Windows代理端口是1080</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ALL_PROXY=socks5://<span class="variable">$windows_host</span>:1080</span><br><span class="line"><span class="built_in">export</span> HTTP_PROXY=<span class="variable">$ALL_PROXY</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="variable">$ALL_PROXY</span></span><br><span class="line"><span class="built_in">export</span> HTTPS_PROXY=<span class="variable">$ALL_PROXY</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="variable">$ALL_PROXY</span></span><br></pre></td></tr></table></figure>

<h5 id="1-4-7-设置git的代理"><a href="#1-4-7-设置git的代理" class="headerlink" title="1.4.7 设置git的代理"></a>1.4.7 设置git的代理</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"`git config --global --get proxy.https`"</span> != <span class="string">"socks5://<span class="variable">$windows_host</span>:1080"</span> ]; <span class="keyword">then</span></span><br><span class="line">    git config --global proxy.https socks5://<span class="variable">$windows_host</span>:1080</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h5 id="1-4-8-设置docker内的代理"><a href="#1-4-8-设置docker内的代理" class="headerlink" title="1.4.8 设置docker内的代理"></a>1.4.8 设置docker内的代理</h5><p>在/etc/default/docker有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">"socks5://[windows_host]:1080"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">"socks5://[windows_host]:1080"</span></span><br><span class="line">sudo sed -i -E <span class="string">"s#socks5.*?1080#socks5://<span class="variable">$windows_host</span>:1080#"</span> /etc/default/docker</span><br></pre></td></tr></table></figure>

<h5 id="1-4-9-设置WSL内的DNS-默认是系统自己创建的"><a href="#1-4-9-设置WSL内的DNS-默认是系统自己创建的" class="headerlink" title="1.4.9 设置WSL内的DNS, 默认是系统自己创建的"></a>1.4.9 设置WSL内的DNS, 默认是系统自己创建的</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bash -c <span class="string">'echo -e "nameserver 114.114.114.114\nnameserver 8.8.8.8\nnameserver 8.8.4.4" &gt; /etc/resolv.conf'</span></span><br></pre></td></tr></table></figure>

<h5 id="1-4-10-打通Window与Ubuntu网络"><a href="#1-4-10-打通Window与Ubuntu网络" class="headerlink" title="1.4.10 打通Window与Ubuntu网络"></a>1.4.10 打通Window与Ubuntu网络</h5><p>以 <code>管理员身份</code> 打开 PowerShell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x.x.x.x 为 Ubuntu IP，请替换</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenport=80 listenaddress=0.0.0.0 connectport=80 connectaddress=x.x.x.x</span><br></pre></td></tr></table></figure>

<h5 id="1-4-11-WSL、WSL2-导出迁移"><a href="#1-4-11-WSL、WSL2-导出迁移" class="headerlink" title="1.4.11 WSL、WSL2 导出迁移"></a>1.4.11 WSL、WSL2 导出迁移</h5><p>WSL2虚拟机长时间使用占用空间过大导致C盘爆满，把他迁移到E盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># EXPORT 导出</span><br><span class="line">wsl --export Alpine .&#x2F;Alpine.tar</span><br><span class="line"># IMPORT 导入</span><br><span class="line">mkdir e:\newAlpine</span><br><span class="line">wsl --import Alpine e:\newAlpine Alpine.tar</span><br><span class="line">explorer.exe e:\newAlpine</span><br></pre></td></tr></table></figure>







<h2 id="2-Docker-安装"><a href="#2-Docker-安装" class="headerlink" title="2. Docker 安装"></a>2. Docker 安装</h2><h4 id="2-1-更新操作系统"><a href="#2-1-更新操作系统" class="headerlink" title="2.1 更新操作系统"></a>2.1 更新操作系统</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade -y</span><br><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure>

<h4 id="2-2-安装常用软件"><a href="#2-2-安装常用软件" class="headerlink" title="2.2 安装常用软件"></a>2.2 安装常用软件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install git curl wget unzip lrzsz net-tools</span><br></pre></td></tr></table></figure>

<h4 id="2-2-安装Docker前准备"><a href="#2-2-安装Docker前准备" class="headerlink" title="2.2 安装Docker前准备"></a>2.2 安装Docker前准备</h4><h5 id="2-2-1-卸载旧版本"><a href="#2-2-1-卸载旧版本" class="headerlink" title="2.2.1 卸载旧版本"></a>2.2.1 卸载旧版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-安装依赖使apt能够使用基于https的仓库"><a href="#2-2-2-安装依赖使apt能够使用基于https的仓库" class="headerlink" title="2.2.2 安装依赖使apt能够使用基于https的仓库"></a>2.2.2 安装依赖使apt能够使用基于https的仓库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common -y</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-添加docker的离线-gpg-key"><a href="#2-2-3-添加docker的离线-gpg-key" class="headerlink" title="2.2.3 添加docker的离线 gpg key"></a>2.2.3 添加docker的离线 gpg key</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-验证key的信息"><a href="#2-2-4-验证key的信息" class="headerlink" title="2.2.4 验证key的信息"></a>2.2.4 验证key的信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">    </span><br><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid   [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure>

<h5 id="2-2-5-设置docker各版本的安装源（此处是-stable-版本）"><a href="#2-2-5-设置docker各版本的安装源（此处是-stable-版本）" class="headerlink" title="2.2.5 设置docker各版本的安装源（此处是 stable 版本）"></a>2.2.5 设置docker各版本的安装源（此处是 stable 版本）</h5><p>To add the <strong>nightly</strong> or <strong>test</strong> repository, add the word <code>nightly</code> or <code>test</code> (or both) after the word <code>stable</code> in the commands below.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-开始安装-docker"><a href="#2-3-开始安装-docker" class="headerlink" title="2.3 开始安装 docker"></a>2.3 开始安装 docker</h4><h5 id="2-3-1-更新软件目录"><a href="#2-3-1-更新软件目录" class="headerlink" title="2.3.1 更新软件目录"></a>2.3.1 更新软件目录</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-安装最新版本的-docker"><a href="#2-3-2-安装最新版本的-docker" class="headerlink" title="2.3.2 安装最新版本的 docker"></a>2.3.2 安装最新版本的 docker</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io -y</span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-启动测试"><a href="#2-3-3-启动测试" class="headerlink" title="2.3.3 启动测试"></a>2.3.3 启动测试</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 docker 守护进程</span></span><br><span class="line">sudo service docker start</span><br><span class="line"><span class="comment"># 运行测试</span></span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<h4 id="2-4-免sudo使用docker命令"><a href="#2-4-免sudo使用docker命令" class="headerlink" title="2.4 免sudo使用docker命令"></a>2.4 免sudo使用docker命令</h4><p>如果在一台新机器上面安装docker时候发现在安装完成之后爆出类似于下面的错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Got permission denied <span class="keyword">while</span> trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.26/images/json: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure>

<p>报错显示权限不够、那么如何解决这个问题呢？</p>
<p>官方文档给出了解决方案，那就是将你的用户添加到 <code>docker</code> 这个用户组里面即可</p>
<h5 id="2-4-1-添加docker-group组"><a href="#2-4-1-添加docker-group组" class="headerlink" title="2.4.1 添加docker group组"></a>2.4.1 添加docker group组</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>

<p>#####　2.4.2 将用户加入该group内</p>
<p>退出并重新登录就生效啦。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br></pre></td></tr></table></figure>

<h5 id="2-4-3-重启docker服务"><a href="#2-4-3-重启docker服务" class="headerlink" title="2.4.3 重启docker服务"></a>2.4.3 重启docker服务</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>

<h5 id="2-4-4-切换当前会话到新group或者重启会话"><a href="#2-4-4-切换当前会话到新group或者重启会话" class="headerlink" title="2.4.4 切换当前会话到新group或者重启会话"></a>2.4.4 切换当前会话到新group或者重启会话</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">newgrp - docker</span><br></pre></td></tr></table></figure>

<p>现在配置就完成了、可以免 sudo 使用，docker 命令了。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>wls</tag>
      </tags>
  </entry>
  <entry>
    <title>docker entrypoint入口文件详解</title>
    <url>/2020/01/13/docker-entrypoint%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>在编写Dockerfile的时候，包含一个entrypoint配置，该配置的作用是在容器启动之前做一些初始化配置，或者一些自定义的配置等。通常是一个脚本，然后在脚本里配置相关预定义项。这篇文档就详细说一说entrypoint入口文件的编写技巧。</p>
<p>下面以mysql官方镜像中的entrypoint文件docker-entrypoint.sh为例，文件地址为：<br><a href="https://raw.githubusercontent.com/docker-library/mysql/607b2a65aa76adf495730b9f7e6f28f146a9f95f/5.7/docker-entrypoint.sh" target="_blank" rel="noopener">docker-entrypoint.sh</a></p>
<h2 id="set-e"><a href="#set-e" class="headerlink" title="set -e"></a>set -e</h2><p>你写的每个脚本都应该在文件开头加上<code>set -e</code>, 这句语句告诉bash如果任何语句的执行结果不是true则应该退出. 这样的好处是防止错误像滚雪球般变大导致一个致命的错误, 而这些错误本应该在之前就被处理掉. 如果要增加可读性, 可以使用<code>set -o errexit</code>, 它的作用与<code>set -e</code>相同</p>
<a id="more"></a>

<h2 id="set-o-pipefail"><a href="#set-o-pipefail" class="headerlink" title="set -o pipefail"></a>set -o pipefail</h2><p>设计用途同上, 就是希望在执行错误之后立即退出, 不要再向下执行了. 而 -o pipefail 的作用域是管道, 也就是说在 Linux 脚本中的管道, 如果前面的命令执行出了问题, 应该立即退出</p>
<h2 id="shopt-s-nullglob"><a href="#shopt-s-nullglob" class="headerlink" title="shopt -s nullglob"></a>shopt -s nullglob</h2><p>在使用 Linux 中的通配符时 <code>* ?</code>等 如果没有匹配到任何文件, 不会报 No such file or directory 而是将命令后面的参数去掉执行</p>
<h2 id="if-“-1-0-1-”-‘-‘-then…"><a href="#if-“-1-0-1-”-‘-‘-then…" class="headerlink" title="if [ “${1:0:1}” = ‘-‘ ]; then…"></a>if [ “${1:0:1}” = ‘-‘ ]; then…</h2><p>这是一个判断语句, 在官方文件中, 上一行已经给出了注释: <code>if command starts with an option, prepend mysqld</code></p>
<p>这个判断语句是 <code>${1:0:1}</code> 意思是判断 <code>$1</code>(调用该脚本的第一个参数), 偏移量0(不偏移), 取一个字符(取字符串的长度)</p>
<p>如果判断出来调用这个脚本后面所跟的参数第一个字符是-中横线的话, 就认为后面的所有字符串都是 mysqld 的启动参数</p>
<p>上面的这个操作类似于 Python 的字符串切片</p>
<h1 id="set-–-mysqld-“-”"><a href="#set-–-mysqld-“-”" class="headerlink" title="set – mysqld “$@”"></a>set – mysqld “$@”</h1><p>在上面判断完第一个参数是-开头之后, 紧接着就执行了 set – mysqld “$@” 这个命令. 使用了 set – 的用法. set –会将他后面所有以空格区分的字符串, 按顺序分别存储到$1, $2, $3 变量中, 其中新的$@为set –后面的全部内容</p>
<p>举例来说: <code>bash docker-entrypoint.sh -f xxx.conf</code></p>
<p>在这种情况下, <code>set -- mysqld &quot;$@&quot;</code> 中的 $@ 的值为 <code>-f xxx.conf</code></p>
<p>当执行完 <code>set -- mysqld &quot;$@&quot;</code> 这条命令后:</p>
<ul>
<li><code>$1=mysqld</code></li>
<li><code>$2=-f</code></li>
<li><code>$3=xxx.conf</code></li>
<li><code>$@=mysqld -f xxx.conf</code></li>
</ul>
<p>可以看到, 当执行 docker-entrypoint.sh脚本的时候后面加了 -x形式的参数之后, $@的值发生的改变, 在原有$@值的基础之上, 在前面又预添加了 mysqld 命令</p>
<h2 id="exec-“-”"><a href="#exec-“-”" class="headerlink" title="exec “$@”"></a>exec “$@”</h2><p>几乎在每个<code>docker-entrypoint.sh</code>脚本的最后一行, 执行的都是 <code>exec &quot;$@&quot;</code>命令</p>
<p>这个命令的意义在于你已经为你的镜像预想到了应该有的调用情况, 当实际使用镜像的人执行了你没有预料到的可执行命令时, 将会走到脚本的这最后一行, 去执行用户新的可执行命令</p>
<h2 id="情况判断"><a href="#情况判断" class="headerlink" title="情况判断"></a>情况判断</h2><p>上面直接说了脚本的最后一行, 在之前的脚本中, 需要充分的去考虑你自己的脚本可能会被调用的情况. 还是拿 MySQL 官方的 dockerfile 来说, 他判断以下情况:</p>
<ul>
<li>开头是 <code>-</code> , 认为是参数的情况</li>
<li>开头是 mysqld, 且用户 id 为0 (root 用户) 的情况</li>
<li>开头是 mysqld 的情况</li>
<li>判断完自己应用的所有调用形态之后, 最后应该加上<code>exec &quot;$@&quot;</code> 命令兜底</li>
</ul>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="${mysql[@]}"></a>${mysql[@]}</h2><p>Shell 中的数组, 直接执行 <code>${mysql[@]}</code> 会把这个数组当做可执行程序来执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&#x3D;( mysql --protocol&#x3D;socket -uroot -hlocalhost --socket&#x3D;&quot;$&#123;SOCKET&#125;&quot; )</span><br><span class="line">echo $&#123;mysql[1]&#125;</span><br><span class="line">-- output: mysql</span><br><span class="line">echo $&#123;mysql[2]&#125;</span><br><span class="line">--output: --protocol&#x3D;socket</span><br><span class="line">echo $&#123;mysql[3]&#125;</span><br><span class="line">--output: -uroot</span><br><span class="line">echo $&#123;mysql[4]&#125;</span><br><span class="line">--output: -hlocalhost</span><br><span class="line">echo $&#123;mysql[@]&#125;</span><br><span class="line">--output: mysql --protocol&#x3D;socket -uroot -hlocalhost --socket&#x3D;</span><br></pre></td></tr></table></figure>

<h2 id="exec-gosu-mysql-“-BASH-SOURCE”-“-”"><a href="#exec-gosu-mysql-“-BASH-SOURCE”-“-”" class="headerlink" title="exec gosu mysql “$BASH_SOURCE” “$@”"></a>exec gosu mysql “$BASH_SOURCE” “$@”</h2><p>这里的 gosu 命令, 是 Linux 中 sudo 命令的轻量级”替代品”</p>
<p>gosu 是一个 golang 语言开发的工具, 用来取代 shell 中的 sudo 命令. su 和 sudo 命令有一些缺陷, 主要是会引起不确定的 TTY, 对信号量的转发也存在问题. 如果仅仅为了使用特定的用户运行程序, 使用 su 或 sudo 显得太重了, 为此 gosu 应运而生.</p>
<p>gosu 直接借用了 libcontainer 在容器中启动应用程序的原理, 使用 /etc/passwd 处理应用程序. gosu 首先找出指定的用户或用户组, 然后切换到该用户或用户组. 接下来, 使用 exec 启动应用程序. 到此为止, gosu 完成了它的工作, 不会参与到应用程序后面的声明周期中. 使用这种方式避免了 gosu 处理 TTY 和转发信号量的问题, 把这两个工作直接交给了应用程序去完成</p>
<p>引用自：<a href="https://www.cnblogs.com/breezey/p/8812197.html" target="_blank" rel="noopener">https://www.cnblogs.com/breezey/p/8812197.html</a></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>docker entrypoint</tag>
      </tags>
  </entry>
  <entry>
    <title> docker容器添加自定义hosts</title>
    <url>/2021/07/01/docker%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89hosts/</url>
    <content><![CDATA[<h2 id="docker容器添加自定义hosts"><a href="#docker容器添加自定义hosts" class="headerlink" title="docker容器添加自定义hosts"></a>docker容器添加自定义hosts</h2><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>启动时增加hosts，参考自<a href="https://docs.docker.com/edge/engine/reference/commandline/run/#description" target="_blank" rel="noopener">docker docs</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name test1 \</span><br><span class="line">    --add-host test1.a:1.2.3.4 \</span><br><span class="line">    <span class="built_in">local</span>/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>docker-compose.yml文件指定，参考自<a href="https://stackoverflow.com/questions/29076194/using-add-host-or-extra-hosts-with-docker-compose?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa" target="_blank" rel="noopener">stackoverflow</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">test2:</span></span><br><span class="line"><span class="attr">  build:</span> <span class="string">local/test</span></span><br><span class="line"><span class="attr">  extra_hosts:</span></span><br><span class="line">    <span class="string">test1.a:</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line">    <span class="string">test1.b:</span> <span class="number">4.3</span><span class="number">.2</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>构建镜像时增加，参考自<a href="https://docs.docker.com/edge/engine/reference/commandline/build/#add-entries-to-container-hosts-file---add-host" target="_blank" rel="noopener">docker docs</a>，这个本人测试失败，不可用。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build \</span><br><span class="line">    --add-host test.abc:1.2.3.4 \</span><br><span class="line">    -t <span class="built_in">local</span>/<span class="built_in">test</span> \</span><br><span class="line">    .</span><br></pre></td></tr></table></figure>

<h4 id="错误示例一"><a href="#错误示例一" class="headerlink" title="错误示例一"></a>错误示例一</h4><p>Dockerfile修改hosts文件，类似如下操作</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">RUN</span> <span class="string">echo</span> <span class="string">'1.2.3.4   test.a'</span> <span class="string">&gt;&gt;</span> <span class="string">/etc/hosts</span></span><br></pre></td></tr></table></figure>

<h4 id="错误示例二"><a href="#错误示例二" class="headerlink" title="错误示例二"></a>错误示例二</h4><p>容器启动后修改/etc/hosts，仅本次启动有效，重启就还原</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git 删除错误提交的commit</title>
    <url>/2020/01/13/git-%E5%88%A0%E9%99%A4%E9%94%99%E8%AF%AF%E6%8F%90%E4%BA%A4%E7%9A%84commit/</url>
    <content><![CDATA[<h3 id="git-删除错误提交的commit"><a href="#git-删除错误提交的commit" class="headerlink" title="git 删除错误提交的commit"></a>git 删除错误提交的commit</h3><p>方法: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard  [commit_id]</span><br><span class="line"></span><br><span class="line">git push origin HEAD --force</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<p>根据–soft –mixed –hard，会对working tree和index和HEAD进行重置:</p>
<ul>
<li><p>git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息</p>
</li>
<li><p>git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可</p>
</li>
<li><p>git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容</p>
<p>HEAD 最近一个提交<br>HEAD^ 上一次<br>[commit_id]  每次commit的SHA1值. 可以用<code>git log</code> 看到,也可以在页面上commit标签页里找到.</p>
</li>
</ul>
<a id="more"></a>

<h3 id="commit合并"><a href="#commit合并" class="headerlink" title="commit合并"></a>commit合并</h3><p>引用自：<a href="https://www.douban.com/note/318248317/" target="_blank" rel="noopener">http://www.douban.com/note/318248317/</a></p>
<p>有时commit太多，而且可能一个commit只是提交一个小bug，那么合并commit势在必行。<br>有两种方法：<br>一是在提交最后一个修改的commit使用参数，这时之前的一个commit将会合并到这个即将提交的commit中来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -a --amend -m &quot;my message here&quot;如果之前有一个提交，并且信息为:</span><br><span class="line"></span><br><span class="line">git commit -a -m &quot;my last commit message&quot;</span><br></pre></td></tr></table></figure>

<p>则这个commit message将不存在。但该commit的信息已经合并到”my message here”中了。</p>
<p>第二个是，如果你提交了最后的修改，这时可用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD^ #或HEAD^意为取消最后commit</span><br><span class="line"></span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>这将会把最后一个commit合并到前一个提交中去，例如（由上往下读）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add b.text</span><br><span class="line"></span><br><span class="line">git commit -a -m &quot;my message here&quot;</span><br><span class="line"></span><br><span class="line">git add a.text</span><br><span class="line"></span><br><span class="line">git commit -a -m &quot;my last commit message&quot;</span><br></pre></td></tr></table></figure>

<p>那么最后存在的将是”my last commit message”。也可后退n个，合并到前面第n+1个commit中去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD~n #后退到第n，我也不清楚具体含义。</span><br><span class="line"></span><br><span class="line">git commit --amend [-m &quot;new message&quot;]</span><br></pre></td></tr></table></figure>

<p>我觉得最方面的是调用reflog查看操作历史，找到具体的commit id，然后直接git reset –hard [commit_id]就回到你要的版本！</p>
<h3 id="如何撤回GIT已提交的代码？"><a href="#如何撤回GIT已提交的代码？" class="headerlink" title="如何撤回GIT已提交的代码？"></a>如何撤回GIT已提交的代码？</h3><h4 id="如何操作？"><a href="#如何操作？" class="headerlink" title="如何操作？"></a>如何操作？</h4><p>这种情况属于已push后发现提交错误。</p>
<p>我们可以使用下面这行命令来回到上一个版本：</p>
<p>git reset –soft HEAD~1</p>
<p>来解释一下参数：</p>
<p><strong>–soft</strong></p>
<p>撤销commit，不撤销add。</p>
<p><strong>–mixed</strong></p>
<p>撤销commit ，撤销add，但不删除工作空间改动代码。</p>
<p><strong>–hard</strong></p>
<p>撤销commit，撤销add，且删除工作空间改动代码。</p>
<p><strong>HEAD~N</strong></p>
<p>N替换成想要回退几个版本。如HEAD~2表示回退两个版本。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>在reset后重新推送代码时，需要用</p>
<p>git push –force来强制更新远端分支。</p>
<p><strong>演示如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br><span class="line">(这里改动内容...)</span><br><span class="line">git commit -m &quot;update&quot;</span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常用命令整理</title>
    <url>/2020/01/14/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="初始化版本库，并提交到远程服务器端"><a href="#初始化版本库，并提交到远程服务器端" class="headerlink" title="初始化版本库，并提交到远程服务器端"></a>初始化版本库，并提交到远程服务器端</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir git_project</span><br><span class="line">cd git_project</span><br><span class="line">git init #本地初始化</span><br><span class="line">touch README</span><br><span class="line">git add README #添加文件</span><br><span class="line">git commit -m &#39;first commit&#39;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<h4 id="1、常用的Git命令"><a href="#1、常用的Git命令" class="headerlink" title="1、常用的Git命令"></a>1、常用的Git命令</h4><p><code>git add–interactive</code>交互式添加<br><code>git apply</code>应用补丁<br><code>git am</code>应用邮件格式补丁<br><code>git annotate</code>同义词，等同于 <code>git blame</code></p>
<a id="more"></a>

<p><code>git archive</code>文件归档打包<br><code>git bisect</code>二分查找<br><code>git blame</code>文件逐行追溯<br><code>git branch</code>分支管理<br><code>git cat-file</code>版本库对象研究工具<br><code>git checkout</code>检出到工作区、切换或创建分支<br><code>git cherry-pick</code>提交拣选<br><code>git citool</code>图形化提交，相当于 <code>git gui</code> 命令<br><code>git clean</code>清除工作区未跟踪文件<br><code>git clone</code>克隆版本库<br><code>git commit</code>提交<br><code>git config</code>查询和修改配置<br><code>git describe</code>通过里程碑直观地显示提交ID<br><code>git diff</code>差异比较<br><code>git difftool</code>调用图形化差异比较工具<br><code>git fetch</code>获取远程版本库的提交<br><code>git format-patch</code>创建邮件格式的补丁文件。参见 <code>git am</code> 命令<br><code>git grep</code>文件内容搜索定位工具<br><code>git gui</code>基于Tcl/Tk的图形化工具，侧重提交等操作<br><code>git help</code>帮助<br><code>git init</code>版本库初始化<br><code>git init-db</code>同义词，等同于<code>git init</code><br><code>git log</code>显示提交日志<br><code>git merge</code>分支合并<br><code>git mergetool</code>图形化冲突解决<br><code>git mv</code>重命名<br><code>git pull</code>拉回远程版本库的提交<br><code>git push</code>推送至远程版本库<br><code>git rebase</code>分支变基<br><code>git rebase–interactive</code>交互式分支变基<br><code>git reflog</code>分支等引用变更记录管理<br><code>git remote</code>远程版本库管理<br><code>git repo-config</code>同义词，等同于 <code>git config</code><br><code>git reset</code>重置改变分支“游标”指向<br><code>git rev-parse</code>将各种引用表示法转换为哈希值等<br><code>git revert</code>反转提交<br><code>git rm</code>删除文件<br><code>git show</code>显示各种类型的对象<br><code>git stage</code>同义词，等同于 <code>git add</code><br><code>git stash</code>保存和恢复进度<br><code>git status</code>显示工作区文件状态<br><code>git tag</code>里程碑管理</p>
<h4 id="2、对象库操作相关命令"><a href="#2、对象库操作相关命令" class="headerlink" title="2、对象库操作相关命令"></a>2、对象库操作相关命令</h4><p><strong>命令</strong> <strong>简要说明</strong><br><code>git commit-tree</code>从树对象创建提交<br><code>git hash-object</code>从标准输入或文件计算哈希值或创建对象<br><code>git ls-files</code>显示工作区和暂存区文件<br><code>git ls-tree</code>显示树对象包含的文件<br><code>git mktag</code>读取标准输入创建一个里程碑对象<br><code>git mktree</code>读取标准输入创建一个树对象<br><code>git read-tree</code>读取树对象到暂存区<br><code>git update-index</code>工作区内容注册到暂存区及暂存区管理<br><code>git unpack-file</code>创建临时文件包含指定 blob 的内容<br><code>git write-tree</code>从暂存区创建一个树对象</p>
<h4 id="3、引用操作相关命令"><a href="#3、引用操作相关命令" class="headerlink" title="3、引用操作相关命令"></a>3、引用操作相关命令</h4><p><strong>命令</strong> <strong>简要说明</strong><br><code>git check-ref-format</code>检查引用名称是否符合规范<br><code>git for-each-ref</code>引用迭代器，用于shell编程<br><code>git ls-remote</code>显示远程版本库的引用<br><code>git name-rev</code>将提交ID显示为友好名称<br><code>git peek-remote</code>过时命令，请使用 <code>git ls-remote</code><br><code>git rev-list</code>显示版本范围<br><code>git show-branch</code>显示分支列表及拓扑关系<br><code>git show-ref</code>显示本地引用<br><code>git symbolic-ref</code>显示或者设置符号引用<br><code>git update-ref</code>更新引用的指向<br><code>git verify-tag</code>校验 GPG 签名的Tag</p>
<h4 id="4、版本库管理相关命令"><a href="#4、版本库管理相关命令" class="headerlink" title="4、版本库管理相关命令"></a>4、版本库管理相关命令</h4><p><strong>命令</strong> <strong>简要说明</strong><br><code>git count-objects</code>显示松散对象的数量和磁盘占用<br><code>git filter-branch</code>版本库重构<br><code>git fsck</code>对象库完整性检查<br><code>git fsck-objects</code>同义词，等同于 <code>git fsck</code><br><code>git gc</code>版本库存储优化<br><code>git index-pack</code>从打包文件创建对应的索引文件<br><code>git lost-found</code>过时，请使用 <code>git fsck –lost-found</code>命令<br><code>git pack-objects</code>从标准输入读入对象ID，打包到文件<br><code>git pack-redundant</code>查找多余的 <code>pack</code> 文件<br><code>git pack-refs</code>将引用打包到 .<code>git/packed-refs</code> 文件中<br><code>git prune</code>从对象库删除过期对象<br><code>git prune-packed</code>将已经打包的松散对象删除<br><code>git relink</code>为本地版本库中相同的对象建立硬连接<br><code>git repac</code>k将版本库未打包的松散对象打包<br><code>git show-index</code>读取包的索引文件，显示打包文件中的内容<br><code>git unpack-objects</code>从打包文件释放文件<br><code>git verify-pack</code>校验对象库打包文件</p>
<h4 id="5、数据传输相关命令"><a href="#5、数据传输相关命令" class="headerlink" title="5、数据传输相关命令"></a>5、数据传输相关命令</h4><p><strong>命令</strong> <strong>简要说明</strong><br><code>git fetch-pack</code>执行 <code>git fetch 或 git pull</code>命令时在本地执行此命令，用于从其他版本库获取缺失的对象<br><code>git receive-pack</code>执行 <code>git push</code> 命令时在远程执行的命令，用于接受推送的数据<br><code>git send-pack</code>执行 <code>git push</code> 命令时在本地执行的命令，用于向其他版本库推送数据<br><code>git upload-archive</code>执行 <code>git archive –remote</code>命令基于远程版本库创建归档时，远程版本库执行此命令传送归档<br><code>git upload-pack</code>执行 <code>git fetch 或 git pull</code> 命令时在远程执行此命令，将对象打包、上传</p>
<h4 id="6、邮件相关命令"><a href="#6、邮件相关命令" class="headerlink" title="6、邮件相关命令"></a>6、邮件相关命令</h4><p><strong>命令</strong> <strong>简要说明</strong><br><code>git imap-send</code>将补丁通过 IMAP 发送<br><code>git mailinfo</code>从邮件导出提交说明和补丁<br><code>git mailsplit</code>将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件<br><code>git request-pull</code>创建包含提交间差异和执行PULL操作地址的信息<br><code>git send-email</code>发送邮件</p>
<h4 id="7、协议相关命令"><a href="#7、协议相关命令" class="headerlink" title="7、协议相关命令"></a>7、协议相关命令</h4><p><strong>命令</strong> <strong>简要说明</strong><br><code>git daemon实现</code>git协议<br><code>git http-backend</code>实现HTTP协议的CGI程序，支持智能HTTP协议<br><code>git instaweb</code>即时启动浏览器通过 <code>gitweb 浏览当前版本库</code><br><code>git shell</code>受限制的shell，提供仅执行git命令的SSH访问<br><code>git update-server-info</code>更新哑协议需要的辅助文件<br><code>git http-fetch</code>通过HTTP协议获取版本库<br><code>git http-push</code>通过HTTP/DAV协议推送<br><code>git remote-ext</code>由git命令调用，通过外部命令提供扩展协议支持<br><code>git remote-fd</code>由git命令调用，使用文件描述符作为协议接口<br><code>git remote-ftp</code>由git命令调用，提供对FTP协议的支持<br><code>git remote-ftps</code>由git命令调用，提供对FTPS协议的支持<br><code>git remote-http</code>由git命令调用，提供对HTTP协议的支持<br><code>git remote-https</code>由git命令调用，提供对HTTPS协议的支持<br><code>git remote-test</code>git协议扩展示例脚本</p>
<h4 id="8、版本库转换和交互相关命令"><a href="#8、版本库转换和交互相关命令" class="headerlink" title="8、版本库转换和交互相关命令"></a>8、版本库转换和交互相关命令</h4><p><strong>命令</strong> <strong>简要说明</strong><br><code>git archimport</code>导入Arch版本库到git<br><code>git bundle</code>提交打包和解包，以便在不同版本库间传递<br><code>git cvsexportcommit</code>将git的一个提交作为一个CVS检出<br><code>git cvsimport</code>导入CVS版本库到git。或者使用 cvs2git<br><code>git cvsserver</code>git的CVS协议模拟器，可供CVS命令访问git版本库<br><code>git fast-export</code>将提交导出为<code>git-fast-import</code> 格式<br><code>git fast-import</code>其他版本库迁移至git的通用工具<br><code>git svn</code>git 作为前端操作 Subversion</p>
<h4 id="9、合并相关的辅助命令"><a href="#9、合并相关的辅助命令" class="headerlink" title="9、合并相关的辅助命令"></a>9、合并相关的辅助命令</h4><p><strong>命令</strong> <strong>简要说明</strong><br><code>git merge-base</code>供其他脚本调用，找到两个或多个提交最近的共同祖先<br><code>git merge-file</code>针对文件的两个不同版本执行三向文件合并<br><code>git merge-index</code>对index中的冲突文件调用指定的冲突解决工具<br><code>git merge-octopus</code>合并两个以上分支。参见 <code>git merge 的octopus</code>合并策略<br><code>git merge-one-file</code>由 <code>git merge-index</code> 调用的标准辅助程序<br><code>git merge-ours</code>合并使用本地版本，抛弃他人版本。参见 <code>git merge 的ours</code>合并策略<br><code>git merge-recursive</code>针对两个分支的三向合并。参见 <code>git merge 的recursive</code>合并策略<br><code>git merge-resolve</code>针对两个分支的三向合并。参见 <code>git merge 的resolve</code>合并策略<br><code>git merge-subtree</code>子树合并。参见 <code>git merge 的 subtree</code>合并策略<br><code>git merge-tree</code>显式三向合并结果，不改变暂存区<br><code>git fmt-merge-msg</code>供执行合并操作的脚本调用，用于创建一个合并提交说明<br><code>git rerere</code>重用所记录的冲突解决方案</p>
<h4 id="10、-杂项"><a href="#10、-杂项" class="headerlink" title="10、 杂项"></a>10、 杂项</h4><p><strong>命令</strong> <strong>简要说明</strong><br><code>git bisect–helper</code>由 <code>git bisect</code>命令调用，确认二分查找进度<br><code>git check-attr</code>显示某个文件是否设置了某个属性<br><code>git checkout-index</code>从暂存区拷贝文件至工作区<br><code>git cherry</code>查找没有合并到上游的提交<br><code>git diff-files</code>比较暂存区和工作区，相当于 <code>git diff –raw</code><br><code>git diff-index</code>比较暂存区和版本库，相当于 <code>git diff –cached –raw</code><br><code>git diff-tree</code>比较两个树对象，相当于 <code>git diff –raw A B</code><br><code>git difftool–helper</code>由 <code>git difftool</code>命令调用，默认要使用的差异比较工具<br><code>git get-tar-commit-id</code>从 <code>git archive</code>创建的 tar 包中提取提交ID<br><code>git gui–askpass</code>命令 <code>git gui</code>的获取用户口令输入界面<br><code>git notes</code>提交评论管理<br><code>git patch-id</code>补丁过滤行号和空白字符后生成补丁唯一ID<br><code>git quiltimport</code>将Quilt补丁列表应用到当前分支<br><code>git replace</code>提交替换<br><code>git shortlog</code>对 <code>git log</code> 的汇总输出，适合于产品发布说明<br><code>git stripspace</code>删除空行，供其他脚本调用<br><code>git submodule</code>子模组管理<br><code>git tar-tree</code>过时命令，请使用 <code>git archive</code><br><code>git var</code>显示 git 环境变量<br><code>git web–browse</code>启动浏览器以查看目录或文件<br><code>git whatchanged</code>显示提交历史及每次提交的改动<br><code>git-mergetool–lib</code>包含于其他脚本中，提供合并/差异比较工具的选择和执行<br><code>git-parse-remote</code>包含于其他脚本中，提供操作远程版本库的函数<br><code>git-sh-setup</code>包含于其他脚本中，提供 shell 编程的函数库</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 放弃本地修改，强制拉取更新</title>
    <url>/2020/01/07/git-%E6%94%BE%E5%BC%83%E6%9C%AC%E5%9C%B0%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%BC%BA%E5%88%B6%E6%8B%89%E5%8F%96%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>开发时，对于本地的项目中修改不做保存操作，可以用到git pull的强制覆盖，具体代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br><span class="line">git pull //可以省略</span><br></pre></td></tr></table></figure>
<p>git fetch 指令是下载远程仓库最新内容，不做合并<br>git reset 指令把HEAD指向master最新版本</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab-ci报500问题修复</title>
    <url>/2020/01/07/gitlab-ci%E6%8A%A5500%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="gitlab-ci报500问题修复"><a href="#gitlab-ci报500问题修复" class="headerlink" title="gitlab-ci报500问题修复"></a>gitlab-ci报500问题修复</h1><p>Enter the DB console:<br>For Omnibus GitLab packages:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-rails dbconsole</span><br></pre></td></tr></table></figure>
<h3 id="Reset-CI-CD-variables"><a href="#Reset-CI-CD-variables" class="headerlink" title="Reset CI/CD variables"></a>Reset CI/CD variables</h3><p>Drop the table:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE FROM ci_group_variables;</span><br><span class="line">DELETE FROM ci_variables;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="Reset-Runner-registration-tokens"><a href="#Reset-Runner-registration-tokens" class="headerlink" title="Reset Runner registration tokens"></a>Reset Runner registration tokens</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- Clear project tokens</span><br><span class="line">UPDATE projects SET runners_token = null, runners_token_encrypted = null;</span><br><span class="line">-- Clear group tokens</span><br><span class="line">UPDATE namespaces SET runners_token = null, runners_token_encrypted = null;</span><br><span class="line">-- Clear instance tokens</span><br><span class="line">UPDATE application_settings SET runners_registration_token_encrypted = null;</span><br><span class="line">-- Clear runner tokens</span><br><span class="line">UPDATE ci_runners SET token = null, token_encrypted = null;</span><br></pre></td></tr></table></figure>
<h3 id="Reset-pending-pipeline-jobs"><a href="#Reset-pending-pipeline-jobs" class="headerlink" title="Reset pending pipeline jobs"></a>Reset pending pipeline jobs</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- Clear build tokens</span><br><span class="line">UPDATE ci_builds SET token = null, token_encrypted = null;</span><br></pre></td></tr></table></figure>
<h3 id="Update-configuration"><a href="#Update-configuration" class="headerlink" title="Update configuration"></a>Update configuration</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>ci/cd</tag>
        <tag>500</tag>
      </tags>
  </entry>
  <entry>
    <title>git修改文件权限方式</title>
    <url>/2020/01/13/git%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="查看文件权限"><a href="#查看文件权限" class="headerlink" title="查看文件权限"></a>查看文件权限</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git ls-tree HEAD</span><br><span class="line">100644 blob ce71d57cfdcddcf2f8aa19fecc46ba05c85aaed1    install.sh</span><br></pre></td></tr></table></figure>

<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git update-index --chmod=+x install.sh</span><br></pre></td></tr></table></figure>

<h3 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">"修改install.sh文件权限"</span></span><br><span class="line">[master c26ebb5] 修改install.sh文件权限</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> mode change 100644 =&gt; 100755 install.sh</span><br><span class="line"> </span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git清除所有历史记录</title>
    <url>/2019/10/31/git%E6%B8%85%E9%99%A4%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>一起来清理掉git上所有的历史记录吧</p>
</blockquote>
<h5 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@code.aliyun.com:user/project.git</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h5 id="检出新分支"><a href="#检出新分支" class="headerlink" title="检出新分支"></a>检出新分支</h5><blockquote>
<p>使用 git checkout –orphan new_branch ,基于当前分支创建一个独立的分支new_branch； </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd project  </span><br><span class="line">git checkout --orphan new_branch</span><br></pre></td></tr></table></figure>
<h5 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure>
<h5 id="添加提交记录"><a href="#添加提交记录" class="headerlink" title="添加提交记录"></a>添加提交记录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -am &quot;Initial commit.&quot;</span><br></pre></td></tr></table></figure>
<h5 id="删除当前分支"><a href="#删除当前分支" class="headerlink" title="删除当前分支"></a>删除当前分支</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -D master</span><br></pre></td></tr></table></figure>
<h5 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -m master</span><br></pre></td></tr></table></figure>
<h5 id="强制推送至远程分支"><a href="#强制推送至远程分支" class="headerlink" title="强制推送至远程分支"></a>强制推送至远程分支</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure>

<h5 id="关联本地-master-到远程-master"><a href="#关联本地-master-到远程-master" class="headerlink" title="关联本地 master 到远程 master"></a>关联本地 master 到远程 master</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;master</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>.git目录过大的解决方法</title>
    <url>/2019/10/29/git%E7%9B%AE%E5%BD%95%E8%BF%87%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>最近在生产环境中发现.git目录特别大，导致clone项目要等很久，严重影响工作效率，分析发现是项目目录下.git文件夹有1.4G之大，上网学习后总结如下：</p>
</blockquote>
<a id="more"></a>

<h3 id="查看问题"><a href="#查看问题" class="headerlink" title="查看问题"></a>查看问题</h3><p>首先查看一下项目目录的大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -d 1 -h</span><br><span class="line">or</span><br><span class="line">du -sh</span><br></pre></td></tr></table></figure>

<p>会发现其中最大的是 .git/objects/pack 文件夹，这里面保存了所有的历史提交。比如你传了一个很大的视频文件提交后，当你删除这个文件再次提交的时候，这个文件在项目中并没有删除，只是删除了他的索引（可能因为多了一次提交反而会更大了一点）</p>
<blockquote>
<p> git会记录你的每一次操作，这个是使用git中的很重要的概念 </p>
</blockquote>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>解决这个问题有两种方法</p>
<ul>
<li>使用git自带的<code>git rev-list</code> <code>git filter-branch</code> 命令查找并删除大文件</li>
<li>使用bfg工具（效率工具，强烈推荐，本文采用此种方式）</li>
</ul>
<h4 id="使用git命令方式"><a href="#使用git命令方式" class="headerlink" title="使用git命令方式"></a>使用git命令方式</h4><p>这种方式操作比较麻烦，建议有一些经验的朋友采用。但就一个字<code>慢</code>，在生产环境中我删除一个文件需要2个多小时，真是不能忍。如果想这样操作，推荐看看下面两位的文章：</p>
<p><a href="https://harttle.land/2016/03/22/purge-large-files-in-gitrepo.html" target="_blank" rel="noopener">寻找并删除Git记录中的大文件</a></p>
<p><a href="https://juejin.im/post/5ce5043c518825240245beb7" target="_blank" rel="noopener">解决github项目体积过大的问题</a></p>
<h4 id="使用bfg工具"><a href="#使用bfg工具" class="headerlink" title="使用bfg工具"></a>使用bfg工具</h4><h5 id="首先安装java环境并下载bfq工具"><a href="#首先安装java环境并下载bfq工具" class="headerlink" title="首先安装java环境并下载bfq工具"></a>首先安装java环境并下载bfq工具</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载java环境包</span><br><span class="line">https:&#x2F;&#x2F;www.java.com&#x2F;zh_CN&#x2F;</span><br><span class="line"># 下载bfq工具</span><br><span class="line">https:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;com&#x2F;madgag&#x2F;bfg&#x2F;1.13.0&#x2F;bfg-1.13.0.jar</span><br></pre></td></tr></table></figure>
<h5 id="然后使用-mirror标记克隆git库副本"><a href="#然后使用-mirror标记克隆git库副本" class="headerlink" title="然后使用--mirror标记克隆git库副本"></a>然后使用<code>--mirror</code>标记克隆git库副本</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --mirror git:&#x2F;&#x2F;example.com&#x2F;some-big-repo.git</span><br></pre></td></tr></table></figure>
<h5 id="在确保已备份后，使用下面的命令清理git库中大于10M的文件"><a href="#在确保已备份后，使用下面的命令清理git库中大于10M的文件" class="headerlink" title="在确保已备份后，使用下面的命令清理git库中大于10M的文件"></a>在确保已备份后，使用下面的命令清理git库中大于10M的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar bfg-1.13.0.jar --strip-blobs-bigger-than 10M some-big-repo.git</span><br></pre></td></tr></table></figure>
<h5 id="或者删除某些敏感文件，比如秘钥之类"><a href="#或者删除某些敏感文件，比如秘钥之类" class="headerlink" title="或者删除某些敏感文件，比如秘钥之类"></a>或者删除某些敏感文件，比如秘钥之类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar bfg-1.13.0.jar --delete-files id_&#123;dsa,rsa&#125;  my-repo.git</span><br><span class="line">java -jar bfg-1.13.0.jar --replace-text passwords.txt  my-repo.git</span><br></pre></td></tr></table></figure>
<p>执行完命令后，会提示所有符合清理条件的文件</p>
<h5 id="按提示进行最后一步，推送"><a href="#按提示进行最后一步，推送" class="headerlink" title="按提示进行最后一步，推送"></a>按提示进行最后一步，推送</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd some-big-repo.git</span><br><span class="line">git reflog expire --expire&#x3D;now --all &amp;&amp; git gc --prune&#x3D;now --aggressive</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>其间给了一个提示，有点意思</p>
<p><img src="https://images.codeflag.cn/let.png" alt=""></p>
<blockquote>
<p>附作者的github地址： <a href="https://github.com/rtyley/bfg-repo-cleaner" target="_blank" rel="noopener">https://github.com/rtyley/bfg-repo-cleaner</a> </p>
</blockquote>
<h4 id="使用git自带命令"><a href="#使用git自带命令" class="headerlink" title="使用git自带命令"></a>使用git自带命令</h4><p>首先，我们需要通过命令找出我们Git提交记录中的大文件。<br>我们需要删除的视频文件，确定是最大的文件，所以我们只需找出排名前 1 的 pack 记录即可，不过这里我们为了演示取排名前3的，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git verify-pack -v .git&#x2F;objects&#x2F;pack&#x2F;pack-*.idx | sort -k 3 -g | tail -3</span><br></pre></td></tr></table></figure>
<p>上面的命令执行后出现如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16779d71545f8b76faf02afffe554aac... blob   1102745 1102346 8459682</span><br><span class="line">68f450adbce465995f52796f05956f29... blob   2081189 2081811 5111192</span><br><span class="line">d0781e7d125599010f4885fa9518cd44... blob   278367052 278045657 10601748</span><br></pre></td></tr></table></figure>
<p>最后一条就是最大的一条记录，<code>d0781e7d125599010f4885fa9518cd44...</code>是它的 id。<br>找出该记录对应的文件，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rev-list --objects --all | grep d0781e7d125599010f4885fa95802a1d7018cd44</span><br></pre></td></tr></table></figure>
<p>上面的命令执行后出现如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d0781e7d125599010f4885fa95802a1d7018cd44  app&#x2F;src&#x2F;assets&#x2F;img&#x2F;FS.mp4</span><br></pre></td></tr></table></figure>
<p>这个文件就是我们不小心提交上去的视频文件，它占了有 200 多 M 的空间。</p>
<p>既然文件找到了，那么得将该文件从历史记录中删除，执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --pretty&#x3D;oneline --branches --  app&#x2F;src&#x2F;assets&#x2F;img&#x2F;FS.mp4</span><br></pre></td></tr></table></figure>
<p>上面的命令执行后只是从历史记录中移除，还没有完全删除它，我们需要重写所有 commit，将该文件从 Git 历史中完全删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git filter-branch --index-filter &#39;git rm --cached --ignore-unmatch  app&#x2F;src&#x2F;assets&#x2F;img&#x2F;FS.mp4 -- --all</span><br></pre></td></tr></table></figure>
<p>上面的命令执行后，此时历史记录中已经没有该文件了，此时是真正删除了它。<br>不过我们运行 filter-branch 产生的日志还是会对该文件有引用，所以我们还需要运行以下几条命令，把该文件的引用完全删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -Rf .git&#x2F;refs&#x2F;original</span><br><span class="line">rm -Rf .git&#x2F;logs&#x2F;</span><br><span class="line">git gc</span><br><span class="line">git prune</span><br></pre></td></tr></table></figure>
<p>现在我们再看 .git 文件的大小明显变小了，少了那个大文件，说明我们之前误提交的大文件已经删除了。<br>最后一步就是 push 代码了，不过就是需要强制 push：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push --force</span><br></pre></td></tr></table></figure>
<p>大功告成，以上就是删除 Git 历史记录（已提交）中大文件的步骤。</p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_45115705/article/details/90604963" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45115705/article/details/90604963</a></p>
<h4 id="命令示例："><a href="#命令示例：" class="headerlink" title="命令示例："></a>命令示例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 找到最大的前10个文件</span><br><span class="line">git rev-list --all | xargs -rL1 git ls-tree -r --long | sort -uk3 | sort -rnk4 | head -10</span><br><span class="line"></span><br><span class="line">git filter-branch --tree-filter &quot;rm -f docker&#x2F;docker-images.tar&quot; -- --all</span><br><span class="line">git log --pretty&#x3D;oneline --branches -- docker&#x2F;docker-images.tar</span><br><span class="line">git filter-branch --index-filter &#39;git rm --cached --ignore-unmatch docker&#x2F;docker-images.tar&#39;  -- --all</span><br><span class="line">rm -Rf .git&#x2F;refs&#x2F;original</span><br><span class="line">rm -Rf .git&#x2F;logs&#x2F;</span><br><span class="line">git gc</span><br><span class="line">git prune</span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>pip/pip3切换国内源</title>
    <url>/2019/10/26/pip-pip3%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<blockquote>
<p>大家知道，pip是Python中非常方便易用的安装包管理器，但是在实际下载安装包的时候经常会连接不上或者下载速度特别慢，将pip更换为国内源，可以大大的提高安装成功率和速度。</p>
</blockquote>
<a id="more"></a>

<p><strong>创建并编辑pip配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/.pip &amp;&amp; vim ~/.pip/pip.conf</span><br></pre></td></tr></table></figure>
<p><strong>然后将下面这两行复制进去就好了</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>国内其他pip源</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">清华:</span><br><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple </span><br><span class="line"></span><br><span class="line">中国科技大学:</span><br><span class="line">https://pypi.mirrors.ustc.edu.cn/simple/ </span><br><span class="line"></span><br><span class="line">华中理工大学:</span><br><span class="line">http://pypi.hustunique.com/ </span><br><span class="line"></span><br><span class="line">山东理工大学:</span><br><span class="line">http://pypi.sdutlinux.org/ </span><br><span class="line"></span><br><span class="line">豆瓣:</span><br><span class="line">http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>linux环境下安装selenium（python3）</title>
    <url>/2021/07/01/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85selenium%EF%BC%88python3%EF%BC%89/</url>
    <content><![CDATA[<h2 id="linux环境下安装selenium（python3）"><a href="#linux环境下安装selenium（python3）" class="headerlink" title="linux环境下安装selenium（python3）"></a>linux环境下安装selenium（python3）</h2><h2 id="说点废话"><a href="#说点废话" class="headerlink" title="说点废话"></a>说点废话</h2><ul>
<li>当我们正常在界面系统使用selenium时，会感觉很爽，因为能清楚的看到我们代码的实现的过程，当遇到报错，也能相对来说缩小错误范围，一般都能很快的找到问题所在；</li>
<li>倘若我们想在Linux环境（无界面）中使用selenium，虽然在官网可以下载到linux环境下的chromedriver驱动文件，但是如何配置才能成功运行，话不多说了，上配置流程吧！</li>
</ul>
<a id="more"></a>

<h2 id="来点实货"><a href="#来点实货" class="headerlink" title="来点实货"></a>来点实货</h2><h4 id="1、安装chrome"><a href="#1、安装chrome" class="headerlink" title="1、安装chrome"></a>1、安装chrome</h4><p>用下面的命令安装Google Chrome<br>yum install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdl.google.com%2Flinux%2Fdirect%2Fgoogle-chrome-stable_current_x86_64.rpm" target="_blank" rel="noopener">https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm</a><br>也可以先下载至本地，然后安装<br>wget <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdl.google.com%2Flinux%2Fdirect%2Fgoogle-chrome-stable_current_x86_64.rpm" target="_blank" rel="noopener">https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm</a><br>yum install ./google-chrome-stable_current_x86_64.rpm -y</p>
<p>安装必要的库<br>yum install mesa-libOSMesa-devel gnu-free-sans-fonts wqy-zenhei-fonts -y</p>
<p>还有一个地址也可以下载：<br>找的chrome资源地址 ：<a href="https://pkgs.org/search/?q=google-chrome" target="_blank" rel="noopener">https://pkgs.org/search/?q=google-chrome</a><br>wget xxx具体需要什么版本</p>
<h4 id="2、安装-chromedriver（末尾附chrome和chromedriver的对应版本）"><a href="#2、安装-chromedriver（末尾附chrome和chromedriver的对应版本）" class="headerlink" title="2、安装 chromedriver（末尾附chrome和chromedriver的对应版本）"></a>2、安装 chromedriver（末尾附chrome和chromedriver的对应版本）</h4><p>chrome官网<br>wget <a href="http://chromedriver.storage.googleapis.com/83.0.4103.39/chromedriver_linux64.zip" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/83.0.4103.39/chromedriver_linux64.zip</a><br>淘宝源（推荐）<br>wget <a href="http://npm.taobao.org/mirrors/chromedriver/83.0.4103.39/chromedriver_linux64.zip" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/83.0.4103.39/chromedriver_linux64.zip</a></p>
<p>将下载的文件解压，放在如下位置<br>unzip chromedriver_linux64.zip<br>mv chromedriver /usr/bin/<br>给予执行权限<br>chmod +x /usr/bin/chromedriver</p>
<h4 id="3、运行代码，查看是否成功（python下）"><a href="#3、运行代码，查看是否成功（python下）" class="headerlink" title="3、运行代码，查看是否成功（python下）"></a>3、运行代码，查看是否成功（python下）</h4><p>from selenium import webdriver<br>driver = webdriver.Chrome()</p>
<hr>
<p>chromedriver下载链接：<br><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fchromedriver.storage.googleapis.com%2Findex.html" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html</a></p>
<p>————2019年兼容版本对照表———–<br>具体的可看安装情况调整游览器和驱动的版本<br>ChromeDriver 78.0.3904.11 (2019-09-12)———Supports Chrome version 78<br>ChromeDriver 77.0.3865.40 (2019-08-20)———Supports Chrome version 77<br>ChromeDriver 76.0.3809.12 (2019-06-07)———Supports Chrome version 76<br>ChromeDriver 75.0.3770.8 (2019-04-29)———Supports Chrome version 75<br>ChromeDriver v74.0.3729.6 (2019-03-14)——–Supports Chrome v74<br>ChromeDriver v2.46 (2019-02-01)———-Supports Chrome v71-73</p>
<h2 id="送点东西"><a href="#送点东西" class="headerlink" title="送点东西"></a>送点东西</h2><h4 id="selenium模式"><a href="#selenium模式" class="headerlink" title="selenium模式"></a>selenium模式</h4><ul>
<li>chrome_options.add_argument(‘–headless’) # 无头模式，可不启用界面显示运行</li>
<li>chrome_options.add_argument(‘–disable-gpu’) # 禁用GPU加速</li>
<li>chrome_options.add_argument(‘–start-maximized’)#浏览器最大化</li>
<li>chrome_options.add_argument(‘–window-size=1280x1024’) # 设置浏览器分辨率（窗口大小）</li>
<li>chrome_options.add_argument(‘log-level=3’)</li>
<li>chrome_options.add_argument(‘–user-agent=””‘) # 设置请求头的User-Agent</li>
<li>chrome_options.add_argument(‘–disable-infobars’) # 禁用浏览器正在被自动化程序控制的提示</li>
<li>chrome_options.add_argument(‘–incognito’) # 隐身模式（无痕模式）</li>
<li>chrome_options.add_argument(‘–hide-scrollbars’) # 隐藏滚动条, 应对一些特殊页面</li>
<li>chrome_options.add_argument(‘–disable-javascript’) # 禁用javascript</li>
<li>chrome_options.add_argument(‘–blink-settings=imagesEnabled=false’) # 不加载图片, 提升速度</li>
<li>chrome_options.add_argument(‘–ignore-certificate-errors’) # 禁用扩展插件并实现窗口最大化</li>
<li>chrome_options.add_argument(‘–disable-software-rasterizer’)</li>
<li>chrome_options.add_argument(‘–disable-extensions’)</li>
<li>chrome_options.add_argument(‘–no-sandbox’)　　#以最高权限运行</li>
<li>chrome_options.add_argument(‘–disable-dev-shm-usage’)</li>
</ul>
<h4 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ch_options = webdriver.ChromeOptions()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不加载图片,加快访问速度</span></span><br><span class="line">ch_options.add_experimental_option(<span class="string">"prefs"</span>, &#123;<span class="string">"profile.mamaged_default_content_settings.images"</span>: 2&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此步骤很重要，设置为开发者模式，防止被各大网站识别出来使用了Selenium</span></span><br><span class="line">ch_options.add_experimental_option(<span class="string">'excludeSwitches'</span>, [<span class="string">'enable-automation'</span>])</span><br><span class="line"><span class="comment"># ch_options.add_experimental_option("debuggerAddress", "127.0.0.1:9999")</span></span><br><span class="line">ch_options.add_argument(<span class="string">'--proxy--server=127.0.0.1:8080'</span>)</span><br><span class="line">ch_options.add_argument(<span class="string">'--disable-infobars'</span>)  <span class="comment"># 禁用浏览器正在被自动化程序控制的提示</span></span><br><span class="line">ch_options.add_argument(<span class="string">'--incognito'</span>)</span><br><span class="line">browser = webdriver.Chrome(options=ch_options)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>python</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>python路径操作新标准：pathlib 模块</title>
    <url>/2021/05/25/python%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C%E6%96%B0%E6%A0%87%E5%87%86%EF%BC%9Apathlib-%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="python路径操作新标准：pathlib-模块"><a href="#python路径操作新标准：pathlib-模块" class="headerlink" title="python路径操作新标准：pathlib 模块"></a>python路径操作新标准：pathlib 模块</h3><p>之前如果要使用 python 操作文件路径，我总是会条件反射导入 os.path。 而现在，我会更加喜欢用新式的 pathlib, 虽然用得还是没有 os.path 熟练，但是以后会坚持使用。</p>
<p>pathlib 库从 python3.4 开始，到 python3.6 已经比较成熟。如果你的新项目可以直接用 3.6 以上，建议用 pathlib。相比于老式的 os.path 有几个优势：</p>
<ol>
<li>老的路径操作函数管理比较混乱，有的是导入 os, 有的又是在 os.path 当中，而新的用法统一可以用 pathlib 管理。</li>
<li>老用法在处理不同操作系统 win，mac 以及 linux 之间很吃力。换了操作系统常常要改代码，还经常需要进行一些额外操作。</li>
<li>老用法主要是函数形式，返回的数据类型通常是字符串。但是路径和字符串并不等价，所以在使用 os 操作路径的时候常常还要引入其他类库协助操作。新用法是面向对象，处理起来更灵活方便。</li>
<li>pathlib 简化了很多操作，用起来更轻松。</li>
</ol>
<a id="more"></a>

<p>举个例子， 把所有的 txt 文本全部移动到 archive 目录当中（archive 目录必须存在)。</p>
<p><img src="https://i.loli.net/2020/05/09/yxBn1KPYm7AJU3O.png" alt="image.png">image.png</p>
<p>使用原来的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import glob</span><br><span class="line">import os</span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line"># 获取运行目录下所有的 txt 文件。注意：不是这个文件目录下</span><br><span class="line">print(glob.glob(&#39;*.txt&#39;))</span><br><span class="line"></span><br><span class="line">for file_name in glob.glob(&#39;*.txt&#39;):</span><br><span class="line">    new_path &#x3D; os.path.join(&#39;archive&#39;, file_name)</span><br><span class="line">    shutil.move(file_name, new_path)</span><br></pre></td></tr></table></figure>

<p>新的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pathlib import Path</span><br><span class="line"></span><br><span class="line">Path(&quot;demo.txt&quot;).replace(&#39;archive&#x2F;demo.txt&#39;)</span><br></pre></td></tr></table></figure>

<p>这篇文章列举了 pathlib 的主要用法，细节知识有点多，我只会介绍 pathlib 的用法，不会每个都列举和 os 的区别。但是我会在文章最后放上主要操作使用 pathlib 和 os 的对比图。</p>
<p>最主要的路径操作，你可以参考国外一位大神总结的图：</p>
<p><img src="https://i.loli.net/2020/05/11/Uwqg4IrtELPD8ak.png" alt="pathlib_cheatsheet.png">pathlib_cheatsheet.png</p>
<h3 id="1-路径获取"><a href="#1-路径获取" class="headerlink" title="1 路径获取"></a><strong>1 路径获取</strong></h3><ul>
<li>获取当前工作目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import pathlib</span><br><span class="line">&gt;&gt;&gt; pathlib.Path.cwd()</span><br><span class="line">C:\Users\me\study</span><br><span class="line"># WindowsPath(&#39;C:\Users\me\study&#39;)</span><br></pre></td></tr></table></figure>

<p>虽然在这里打印出来的很像一个字符串，但实际上得到的是一个 <code>WindowsPath(&#39;C:\Users\me\study&#39;)</code>对象。显示内容由 Path 类的 <code>__repr__</code> 定义。</p>
<blockquote>
<p>注意</p>
<p>工作目录是在哪个目录下运行你的程序，不是项目目录。</p>
</blockquote>
<p>如果你只想得到字符串表示，不想要 WindowsPath 对象，可以用 str() 转化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; str(pathlib.Path.cwd())</span><br><span class="line">C:\Users\me\study</span><br></pre></td></tr></table></figure>

<ul>
<li>获取用户 home 目录。</li>
</ul>
<p>下面的例子因为基本都是使用 pathlib 下面的 Path 类，所以可以换一种导入方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pathlib import Path</span><br><span class="line">&gt;&gt;&gt; Path.home()</span><br><span class="line">c:\Users\me</span><br></pre></td></tr></table></figure>

<ul>
<li>获取当前文件路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Path(__file__)</span><br><span class="line">demo_01.py</span><br></pre></td></tr></table></figure>

<p>在 pycharm 中右击运行和在 cmd 运行的结果会不同。pycharm 会显示全路径，cmd 运行只会显示工作目录下的相对路径。如果想统一，可以添加后缀 <code>.resolve()</code> 转化成绝对路径，这个在后面还会提到。</p>
<p><img src="https://i.loli.net/2020/05/11/HnRC8rKk4dupi1L.png" alt="image.png">image.png</p>
<ul>
<li>获取任意字符串路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Path(&#39;subdir&#x2F;demo_02.py&#39;)</span><br><span class="line">subdir\demo_02.py</span><br><span class="line">&gt;&gt;&gt; Path(&#39;c:d:y&#x2F;rad.txt&#39;)</span><br><span class="line">c:d:y\rad.txt</span><br></pre></td></tr></table></figure>

<p>这里需要注意 2 点：</p>
<ol>
<li>不管字符串使用的是正斜杠 <code>/</code> 还是反斜杠 <code>\</code>， 在 windows 系统里，得到的路径都是反斜杠<code>\</code>, pathlib 会根据操作系统智能处理。</li>
<li>第二个例子中字符串会被 <code>/</code> 分割，<code>c:d:y</code> 会被当做一个目录名字，pathlib 不会去判断这个文件真的存在哦。</li>
</ol>
<ul>
<li>获取绝对路径</li>
</ul>
<p>只需要在任意路径对象后添加方法 <code>.resolve()</code> 就能获取路径的绝对路径。如果填入的路径是相对路径（windows 下没有盘符，linux 没有 / 开头)，则会在当前工作目录后添加路径。如果是已经是绝对路径，则只会根据操作系统优化表达。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)</span><br><span class="line">&gt;&gt;&gt; file</span><br><span class="line">archive\demo.txt</span><br><span class="line">&gt;&gt;&gt; file.resolve()</span><br><span class="line">C:\Users\me\study\archive\demo.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>获取文件属性</li>
</ul>
<p>文件属性比如文件大小，创建时间，修改时间等等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)print(file.stat())print(file.stat().st_size)print(file.stat().st_atime)print(file.stat().st_ctime)print(file.stat().st_mtime)</span><br></pre></td></tr></table></figure>

<p>找出最后修改的文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; path &#x3D; Path.cwd()&gt;&gt;&gt; max(        [(f.stat().st_mtime, f)          for f in path.iterdir()          if f.is_file()]    )1589171135.860173 C:\Users\me\study\demo_03.py</span><br></pre></td></tr></table></figure>

<h3 id="2-路径组成部分"><a href="#2-路径组成部分" class="headerlink" title="2 路径组成部分"></a><strong>2 路径组成部分</strong></h3><p>获取路径的组成部分非常方便：</p>
<ul>
<li>.name 文件名，包含后缀名，如果是目录则获取目录名。</li>
<li>.stem 文件名，不包含后缀。</li>
<li>.suffix 后缀，比如 <code>.txt</code>, <code>.png</code>。</li>
<li>.parent 父级目录，相当于 <code>cd ..</code></li>
<li>.anchor 锚，目录前面的部分 <code>C:\</code> 或者 <code>/</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)&gt;&gt;&gt; file.namedemo.txt&gt;&gt;&gt; file.stemdemo&gt;&gt;&gt; file.suffix.txt&gt;&gt;&gt; file.parentC:\Users\me\study\archive&gt;&gt;&gt; file.anchor&#39;C:\&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取上一级目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)&gt;&gt;&gt; file.parentarchive</span><br></pre></td></tr></table></figure>

<p>获取上 2 级 和 3 级目录会有点问题。因为传入的是一个相对路径，上 3 级已经无法往上了，所以还是会停留在工作目录。所以你需要确保你的路径有这么多层级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file.parent.parent.&gt;&gt;&gt; file.parent.parent.parent.</span><br></pre></td></tr></table></figure>

<ul>
<li>获取所有的上级目录：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file.parents&lt;WindowsPath.parents&gt;&gt;&gt;&gt; list(file.parents)[WindowsPath(&#39;archive&#39;), WindowsPath(&#39;.&#39;)]</span><br></pre></td></tr></table></figure>

<ul>
<li>父级目录的另一种表示方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file.parents[0]archive</span><br></pre></td></tr></table></figure>

<p>如果路径是在当前工作目录下的子目录，最好转化成绝对路径再获取上层目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file.resolve().parents[4]C:\Users# 不能使用负数</span><br></pre></td></tr></table></figure>

<p>在 os 模块中获取上 3 级目录简直令人奔溃，需要重复使用 dirname 函数，使用 pathlib 的 parent 可以极大简单化操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import os&gt;&gt;&gt; os.path.dirname(file)</span><br></pre></td></tr></table></figure>

<ul>
<li>相对其他某个路径的结果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file.relative_to(&#39;archive&#39;)dmeo.txt</span><br></pre></td></tr></table></figure>

<h3 id="3-子路径扫描"><a href="#3-子路径扫描" class="headerlink" title="3 子路径扫描"></a><strong>3 子路径扫描</strong></h3><ul>
<li>dir_path.iterdir() 可以扫描某个目录下的所有路径（文件和子目录)， 打印的会是处理过的绝对路径。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; cwd &#x3D; Path.cwd()&gt;&gt;&gt; [path for path in cwd.iterdir() if cwd.is_dir()][    WindowsPath(&#39;C:&#x2F;Users&#x2F;me&#x2F;study&#x2F;archive&#39;),     WindowsPath(&#39;C:&#x2F;Users&#x2F;me&#x2F;study&#x2F;demo_01.py&#39;),     WindowsPath(&#39;C:&#x2F;Users&#x2F;me&#x2F;study&#x2F;new_archive&#39;)]</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 iterdir() 可以统计目录下的不同文件类型：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; path &#x3D; Path.cwd()&gt;&gt;&gt; files &#x3D; [f.suffix for f in path.iterdir() if f.is_file()]&gt;&gt;&gt; collections.Counter(files)Counter(&#123;&#39;.py&#39;: 3, &#39;.txt&#39;: 1&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>查找目录下的指定文件 glob 。</li>
</ul>
<p>使用模式匹配（正则表达式）匹配指定的路径。正则表达式不熟练的可以查看 <a href="https://mp.weixin.qq.com/s?src=11&timestamp=1589010579&ver=2327&signature=J84Vp3En0*OyHZ5OJEkl4xjhX3gXUDTEn2jxYy*heATYN*IOB66Vnvj8R9Cu9D6BVB*QcAP4NtxQne2WVDOxb0e9lUFISXOtzT-8dhAqbUvHVZ69*yGAvJJ2vzWhJMfA&new=1" target="_blank" rel="noopener">这个教程，真的让我学会了正则表达式</a>。glob 只会匹配当前目录下， rglob 会递归所有子目录。下面这个例子，demo.txt 在 archive 子目录下。所以用 glob 找到的是空列表，rglob 可以找到。glob 得到的是一个生成器，可以通过 list() 转化成列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; cwd &#x3D; Path.cwd()&gt;&gt;&gt; list(cwd.glob(&#39;*.txt&#39;))[]&gt;&gt;&gt; list(cwd.rglob(&#39;*.txt&#39;))[WindowsPath(&#39;C:&#x2F;Users&#x2F;me&#x2F;study&#x2F;archive&#x2F;demo.txt&#39;)]</span><br></pre></td></tr></table></figure>

<ul>
<li>检查路径是否符合规则 match</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file &#x3D; Path(&#39;&#x2F;archive&#x2F;demo.txt&#39;)&gt;&gt;&gt; file.match(&#39;*.txt&#39;)True</span><br></pre></td></tr></table></figure>

<h3 id="4-路径拼接"><a href="#4-路径拼接" class="headerlink" title="4 路径拼接"></a><strong>4 路径拼接</strong></h3><p>pathlib 支持用 <code>/</code> 拼接路径。熟悉魔术方法的同学应该很容易理解其中的原理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Path.home() &#x2F; &#39;dir&#39; &#x2F; &#39;file.txt&#39;C:\Users\me\dir\file.txt</span><br></pre></td></tr></table></figure>

<p>如果用不惯 <code>/</code> ，也可以用类似 os.path.join 的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Path.home().joinpath(&#39;dir&#39;, &#39;file.txt&#39;)C:\Users\me\dir\file.txt</span><br></pre></td></tr></table></figure>

<h3 id="5-路径测试（判断）"><a href="#5-路径测试（判断）" class="headerlink" title="5 路径测试（判断）"></a><strong>5 路径测试（判断）</strong></h3><ul>
<li>是否为文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Path(&quot;archive&#x2F;demo.txt&quot;).is_file()True&gt;&gt;&gt; Path(&quot;archive&#x2F;demo.txt&quot;).parent.is_file()False</span><br></pre></td></tr></table></figure>

<ul>
<li>是否为文件夹 (目录)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Path(&quot;archive&#x2F;demo.txt&quot;).is_dir()False&gt;&gt;&gt; Path(&quot;archive&#x2F;demo.txt&quot;).parent.is_dir()True</span><br></pre></td></tr></table></figure>

<ul>
<li>是否存在</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Path(&quot;archive&#x2F;demo.txt&quot;).existsTrue&gt;&gt;&gt; Path(&quot;archive&#x2F;dem.txt&quot;).existsFalse</span><br></pre></td></tr></table></figure>

<h3 id="6-文件操作"><a href="#6-文件操作" class="headerlink" title="6 文件操作"></a><strong>6 文件操作</strong></h3><ul>
<li>创建文件 touch</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file &#x3D; Path(&#39;hello.txt&#39;)&gt;&gt;&gt; file.touch(exist_ok&#x3D;True)None&gt;&gt;&gt; file.touch(exist_ok&#x3D;False)FileExistsError: [Errno 17] File exists: &#39;hello.txt&#39;</span><br></pre></td></tr></table></figure>

<p>exist_ok 表示当文件已经存在时，程序的反应。如果为 True，文件存在时，不进行任何操作。如果为 False, 则会报 <code>FileExistsError</code> 错误。</p>
<ul>
<li>创建目录 path.mkdir</li>
</ul>
<p>用 os 创建目录分为 2 个函数 ： <code>mkdir()</code> 和 <code>makedirs()</code>。 <code>mkdir()</code> 一次只能创建一级目录， <code>makedirs()</code> 可以同时创建多级目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.mkdir(&#39;dir&#x2F;subdir&#x2F;3dir&#39;)FileNotFoundError: [WinError 3] 系统找不到指定的路径。: &#39;dir&#x2F;subdir&#x2F;3dir&#39;&gt;&gt;&gt; os.makedirs(&#39;dir&#x2F;subdir&#x2F;3dir&#39;)None</span><br></pre></td></tr></table></figure>

<p>使用 pathlib 只需要用 path.mkdir() 函数就可以。它提供了 parents 参数，设置为 True 可以创建多级目录；不设置则只能创建 一层：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; path &#x3D; Path(&#39;&#x2F;dir&#x2F;subdir&#x2F;3dir&#39;)&gt;&gt;&gt; path.mkdir()FileNotFoundError: [WinError 3] 系统找不到指定的路径。: &#39;dir&#x2F;subdir&#x2F;3dir&#39;&gt;&gt;&gt; path.mkdir(parents&#x3D;True)None</span><br></pre></td></tr></table></figure>

<ul>
<li>删除目录 path.rmdir()</li>
</ul>
<p>删除目录非常危险，并且没有提示，一定要谨慎操作。一次只删除一级目录，且当前目录必须为空。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; path &#x3D; Path(&#39;dir&#x2F;subdir&#x2F;3dir&#39;)&gt;&gt;&gt; path.rmdir()None</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件 path.unlink, 危险操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; path &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)&gt;&gt;&gt; path.unlink()</span><br></pre></td></tr></table></figure>

<ul>
<li>打开文件</li>
</ul>
<p>使用 open() 函数打开文件时，如果需要传入文件路径。可以用字符串作为参数传入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;archive&#x2F;demo.txt&#39;) as f:    print(f.read())</span><br></pre></td></tr></table></figure>

<p>也可以传入 Path 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_path &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)with open(file_path) as f:    print(f.read())</span><br></pre></td></tr></table></figure>

<p>如果经常使用 pathlib，可以在获取到 Path 路径以后直接调用 path.open() 方法。至于到底用哪一个，其实不必太在意，因为 path.open() 也是调用内置函数 open()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)with file.open() as f:    print(f.read())</span><br></pre></td></tr></table></figure>

<p>不过 pathlib 对读取和写入进行了简单的封装，不再需要重复去打开文件和管理文件的关闭了。</p>
<ul>
<li>.read_text() 读取文本</li>
<li>.read_bytes() 读取 bytes</li>
<li>.write_text() 写入文本</li>
<li>.write_bytes() 写入 tytes</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; file_path &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)&gt;&gt;&gt; file_path.read_text()   # 读取文本&#39;text in the demo.txt&#39;&gt;&gt;&gt; file_path.read_bytes()  # 读取 bytesb&#39;text in the demo.txt&#39;&gt;&gt;&gt; file.write_text(&#39;new words&#39;)  # 写入文本9&gt;&gt;&gt; file.write_bytes(b&#39;new words&#39;) # 写入 bytes9</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>file.write 操作使用的是 w 模式，如果之前已经有文件内容，将会被覆盖。</p>
</blockquote>
<ul>
<li>移动文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt_path &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)res &#x3D; txt_path.replace(&#39;new_demo.txt&#39;)print(res)</span><br></pre></td></tr></table></figure>

<p>这个操作会把 archive 目录下的 demo.txt 文件移动到当前工作目录，并重命名为 new_demo.txt。</p>
<p>移动操作支持的功能很受限。比如当前工作目录如果已经有一个 new_demo.txt 的文件，则里面的内容都会被覆盖。还有，如果需要移动到其他目录下，则该目录必须要存在，否则会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># new_archive 目录必须存在，否则会报错txt_path &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)res &#x3D; txt_path.replace(&#39;new_archive&#x2F;new_demo.txt&#39;)print(res)</span><br></pre></td></tr></table></figure>

<p>为了避免出现同名文件里的内容被覆盖，通常需要进行额外处理。比如判断同名文件不能存在，但是父级目录必须存在；或者判断父级目录不存在时，创建该目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dest &#x3D; Path(&#39;new_demo.txt&#39;)if (not dest.exists()) and dest.parent.exists(): txt_path.replace(dest)</span><br></pre></td></tr></table></figure>

<ul>
<li>重命名文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt_path &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)new_file &#x3D; txt_path.with_name(&#39;new.txt&#39;)txt_path.replace(new_file)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改后缀名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt_path &#x3D; Path(&#39;archive&#x2F;demo.txt&#39;)new_file &#x3D; txt_path.with_suffix(&#39;.json&#39;)txt_path.replace(new_file)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>不管是移动文件还是删除文件，都不会给任何提示。所以在进行此类操作的时候要特别小心。</p>
<p>对文件进行操作最好还是用 shutil 模块。</p>
</blockquote>
<h3 id="7-附件：常用的-pathlib-和-os-对比图"><a href="#7-附件：常用的-pathlib-和-os-对比图" class="headerlink" title="7 附件：常用的 pathlib 和 os 对比图"></a><strong>7 附件：常用的 pathlib 和 os 对比图</strong></h3><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="left">os and os.path</th>
<th align="left">pathlib</th>
</tr>
</thead>
<tbody><tr>
<td align="center">绝对路径</td>
<td align="left"><code>os.path.abspath</code></td>
<td align="left"><code>Path.resolve</code></td>
</tr>
<tr>
<td align="center">修改权限</td>
<td align="left"><code>os.chmod</code></td>
<td align="left"><code>Path.chmod</code></td>
</tr>
<tr>
<td align="center">创建目录</td>
<td align="left"><code>os.mkdir</code></td>
<td align="left"><code>Path.mkdir</code></td>
</tr>
<tr>
<td align="center">重命名</td>
<td align="left"><code>os.rename</code></td>
<td align="left"><code>Path.rename</code></td>
</tr>
<tr>
<td align="center">移动</td>
<td align="left"><code>os.replace</code></td>
<td align="left"><code>Path.replace</code></td>
</tr>
<tr>
<td align="center">删除目录</td>
<td align="left"><code>os.rmdir</code></td>
<td align="left"><code>Path.rmdir</code></td>
</tr>
<tr>
<td align="center">删除文件</td>
<td align="left"><code>os.remove</code>, <code>os.unlink</code></td>
<td align="left"><code>Path.unlink</code></td>
</tr>
<tr>
<td align="center">工作目录</td>
<td align="left"><code>os.getcwd</code></td>
<td align="left"><code>Path.cwd</code></td>
</tr>
<tr>
<td align="center">是否存在</td>
<td align="left"><code>os.path.exists</code></td>
<td align="left"><code>Path.exists</code></td>
</tr>
<tr>
<td align="center">用户目录</td>
<td align="left"><code>os.path.expanduser</code></td>
<td align="left"><code>Path.expanduser</code> and <code>Path.home</code></td>
</tr>
<tr>
<td align="center">是否为目录</td>
<td align="left"><code>os.path.isdir</code></td>
<td align="left"><code>Path.is_dir</code></td>
</tr>
<tr>
<td align="center">是否为文件</td>
<td align="left"><code>os.path.isfile</code></td>
<td align="left"><code>Path.is_file</code></td>
</tr>
<tr>
<td align="center">是否为连接</td>
<td align="left"><code>os.path.islink</code></td>
<td align="left"><code>Path.is_symlink</code></td>
</tr>
<tr>
<td align="center">文件属性</td>
<td align="left"><code>os.stat</code></td>
<td align="left"><code>Path.stat</code>, <code>Path.owner</code>, <code>Path.group</code></td>
</tr>
<tr>
<td align="center">是否为绝对路径</td>
<td align="left"><code>os.path.isabs</code></td>
<td align="left"><code>PurePath.is_absolute</code></td>
</tr>
<tr>
<td align="center">路径拼接</td>
<td align="left"><code>os.path.join</code></td>
<td align="left"><code>PurePath.joinpath</code></td>
</tr>
<tr>
<td align="center">文件名</td>
<td align="left"><code>os.path.basename</code></td>
<td align="left"><code>PurePath.name</code></td>
</tr>
<tr>
<td align="center">上级目录</td>
<td align="left"><code>os.path.dirname</code></td>
<td align="left"><code>PurePath.parent</code></td>
</tr>
<tr>
<td align="center">同名文件</td>
<td align="left"><code>os.path.samefile</code></td>
<td align="left"><code>Path.samefile</code></td>
</tr>
<tr>
<td align="center">后缀</td>
<td align="left"><code>os.path.splitext</code></td>
<td align="left"><code>PurePath.suffix</code></td>
</tr>
</tbody></table>
<p>参考文献</p>
<ul>
<li><a href="https://realpython.com/python-pathlib/" target="_blank" rel="noopener">Python 3’s pathlib Module</a></li>
<li><a href="https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/" target="_blank" rel="noopener">Why you should be using pathlib</a></li>
<li><a href="https://xin053.github.io/2016/07/03/pathlib路径库使用详解/" target="_blank" rel="noopener">pathlib路径库使用详解</a></li>
<li><a href="https://www.dongwm.com/post/use-pathlib/" target="_blank" rel="noopener">你应该使用pathlib替代os.path</a></li>
<li><a href="https://cuiqingcai.com/6598.html" target="_blank" rel="noopener"><a href="https://cuiqingcai.com/6598.html" target="_blank" rel="noopener">Python3 中使用 Pathlib 模块进行文件操作</a></a></li>
<li><a href="http://www.ityouknow.com/python/2019/10/19/python-pathlib-035.html" target="_blank" rel="noopener">pathlib 模块</a></li>
</ul>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python print array时array中间是省略号没有输出全部的解决方法</title>
    <url>/2020/03/25/python-print-array%E6%97%B6array%E4%B8%AD%E9%97%B4%E6%98%AF%E7%9C%81%E7%95%A5%E5%8F%B7%E6%B2%A1%E6%9C%89%E8%BE%93%E5%87%BA%E5%85%A8%E9%83%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>解决方法如下，在开头加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">np.set_printoptions(threshold&#x3D;np.inf)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh及oh-my-zsh安装使用备忘</title>
    <url>/2019/11/07/zsh%E5%8F%8Aoh-my-zsh%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<blockquote>
<p>记录下日常使用的zsh配置及插件</p>
</blockquote>
<h4 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install zsh git</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="切换-shell"><a href="#切换-shell" class="headerlink" title="切换 shell"></a>切换 shell</h4><p>chsh 命令如果不存在则需 <code>$ yum install -y util-linux-user</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
<h4 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br><span class="line">$ sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sh -c <span class="string">"<span class="variable">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -Lo install.sh https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh</span><br><span class="line">$ sh install.sh</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">$ cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>

<h4 id="安装自动补全-incr-两种可以二选一，各有特色"><a href="#安装自动补全-incr-两种可以二选一，各有特色" class="headerlink" title="安装自动补全 incr (两种可以二选一，各有特色)"></a>安装自动补全 incr (两种可以二选一，各有特色)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget -P ~/.oh-my-zsh/plugins/incr/ http://mimosa-pudica.net/src/incr-0.2.zsh </span><br><span class="line">$ chmod 777 ~/.oh-my-zsh/plugins/incr/incr-0.2.zsh  </span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"source ~/.oh-my-zsh/plugins/incr/incr-0.2.zsh"</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<h4 id="安装自动补全命令zsh-autosuggestions"><a href="#安装自动补全命令zsh-autosuggestions" class="headerlink" title="安装自动补全命令zsh-autosuggestions"></a>安装自动补全命令zsh-autosuggestions</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>
<h4 id="安装自动跳转-autojump"><a href="#安装自动跳转-autojump" class="headerlink" title="安装自动跳转 autojump"></a>安装自动跳转 autojump</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/joelthelion/autojump.git <span class="built_in">cd</span> autojump &amp;&amp; ./install.py   </span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"[[ -s /root/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /root/.autojump/etc/profile.d/autojump.sh"</span> &gt;&gt; ~/.zshrc </span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"autoload -U compinit &amp;&amp; compinit -u"</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
<h4 id="安装命令行高亮显示-zsh-syntax-highlighting"><a href="#安装命令行高亮显示-zsh-syntax-highlighting" class="headerlink" title="安装命令行高亮显示 zsh-syntax-highlighting"></a>安装命令行高亮显示 zsh-syntax-highlighting</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<h4 id="修改主题-theme"><a href="#修改主题-theme" class="headerlink" title="修改主题 theme"></a>修改主题 theme</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">'s/ZSH_THEME="robbyrussell"/ZSH_THEME="ys"/'</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<h4 id="添加插件支持-plugins"><a href="#添加插件支持-plugins" class="headerlink" title="添加插件支持 plugins"></a>添加插件支持 plugins</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">'s/(git)$/(git extract zsh-autosuggestions zsh-syntax-highlighting)/'</span> ~/.zshrc </span><br><span class="line">$ sed -i <span class="string">'s/(git)$/(git extract autojump zsh-autosuggestions zsh-syntax-highlighting)/'</span> ~/.zshrc </span><br><span class="line"><span class="comment"># 实际上是修改配置文件plugins字段，添加需要使用的插件</span></span><br><span class="line">plugins=(git wd web-search <span class="built_in">history</span> <span class="built_in">history</span>-substring-search)</span><br></pre></td></tr></table></figure>
<h4 id="关闭自动更新"><a href="#关闭自动更新" class="headerlink" title="关闭自动更新"></a>关闭自动更新</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">'s/# DISABLE_AUTO_UPDATE="true"/DISABLE_AUTO_UPDATE="true"/g'</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<h4 id="加载-zshrc"><a href="#加载-zshrc" class="headerlink" title="加载 zshrc"></a>加载 zshrc</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>一些需要禁用的PHP危险函数(disable_functions)说明</title>
    <url>/2019/11/14/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E7%A6%81%E7%94%A8%E7%9A%84PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0-disable-functions-%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<blockquote>
<p>禁用方法如下：<br>打开php.ini文件，如：/usr/local/php/etc/php.ini<br>查找到 disable_functions ，添加需禁用的函数名，如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable_functions &#x3D; exec,scandir,shell_exec,phpinfo,eval,passthru,system,chroot,chgrp,chown,</span><br><span class="line">        proc_open,proc_get_status,ini_alter,ini_restore,dl,openlog,syslog,readlink,</span><br><span class="line">        symlink,popepassthru,stream_socket_server,fsocket</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p><strong>phpinfo()</strong><br>功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。<br>危险等级：中</p>
<p><strong>exec()</strong><br>功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。<br>危险等级：高</p>
<p><strong>passthru()</strong><br>功能描述：允许执行一个外部程序并回显输出，类似于 exec()。<br>危险等级：高</p>
<p><strong>system()</strong><br>功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。<br>危险等级：高</p>
<p><strong>chroot()</strong><br>功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式<br>PHP 时才能工作，且该函数不适用于 Windows 系统。<br>危险等级：高</p>
<p><strong>scandir()</strong><br>功能描述：列出指定路径中的文件和目录。<br>危险等级：中</p>
<p><strong>chgrp()</strong><br>功能描述：改变文件或目录所属的用户组。<br>危险等级：高</p>
<p><strong>chown()</strong><br>功能描述：改变文件或目录的所有者。<br>危险等级：高</p>
<p><strong>shell_exec()</strong><br>功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。<br>危险等级：高</p>
<p><strong>proc_open()</strong><br>功能描述：执行一个命令并打开文件指针用于读取以及写入。<br>危险等级：高</p>
<p><strong>proc_get_status()</strong><br>功能描述：获取使用 proc_open() 所打开进程的信息。<br>危险等级：高</p>
<p><strong>error_log()</strong><br>功能描述：将错误信息发送到指定位置（文件）。<br>安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode，<br>执行任意命令。<br>危险等级：低</p>
<p><strong>ini_alter()</strong><br>功能描述：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。<br>具体参见 ini_set()。<br>危险等级：高</p>
<p><strong>ini_set()</strong><br>功能描述：可用于修改、设置 PHP 环境配置参数。<br>危险等级：高</p>
<p><strong>ini_restore()</strong><br>功能描述：可用于恢复 PHP 环境配置参数到其初始值。<br>危险等级：高</p>
<p><strong>dl()</strong><br>功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。<br>危险等级：高</p>
<p><strong>pfsockopen()</strong><br>功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。<br>危险等级：高</p>
<p><strong>syslog()</strong><br>功能描述：可调用 UNIX 系统的系统层 syslog() 函数。<br>危险等级：中</p>
<p><strong>readlink()</strong><br>功能描述：返回符号连接指向的目标文件内容。<br>危险等级：中</p>
<p><strong>symlink()</strong><br>功能描述：在 UNIX 系统中建立一个符号链接。<br>危险等级：高</p>
<p><strong>popen()</strong><br>功能描述：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。<br>危险等级：高</p>
<p><strong>stream_socket_server()</strong><br>功能描述：建立一个 Internet 或 UNIX 服务器连接。<br>危险等级：中</p>
<p><strong>putenv()</strong><br>功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数<br>修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。<br>危险等级：高</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>你需要知道的那些go语言json技巧</title>
    <url>/2021/07/01/%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9Bgo%E8%AF%AD%E8%A8%80json%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="你需要知道的那些go语言json技巧"><a href="#你需要知道的那些go语言json技巧" class="headerlink" title="你需要知道的那些go语言json技巧"></a>你需要知道的那些go语言json技巧</h3><p>本文总结了我平时在项目中遇到的那些关于go语言JSON数据与结构体之间相互转换的问题及解决办法。</p>
<h4 id="基本的序列化"><a href="#基本的序列化" class="headerlink" title="基本的序列化"></a>基本的序列化</h4><p>首先我们来看一下Go语言中<code>json.Marshal()</code>（系列化）与<code>json.Unmarshal</code>（反序列化）的基本用法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Age    <span class="keyword">int64</span></span><br><span class="line">	Weight <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;</span><br><span class="line">		Name:   <span class="string">"七米"</span>,</span><br><span class="line">		Age:    <span class="number">18</span>,</span><br><span class="line">		Weight: <span class="number">71.5</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// struct -&gt; json string</span></span><br><span class="line">	b, err := json.Marshal(p1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Marshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%s\n"</span>, b)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// json string -&gt; struct</span></span><br><span class="line">	<span class="keyword">var</span> p2 Person</span><br><span class="line">	err = json.Unmarshal(b, &amp;p2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Unmarshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"p2:%#v\n"</span>, p2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str:&#123;&quot;Name&quot;:&quot;七米&quot;,&quot;Age&quot;:18,&quot;Weight&quot;:71.5&#125;</span><br><span class="line">p2:main.Person&#123;Name:&quot;七米&quot;, Age:18, Weight:71.5&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="结构体tag介绍"><a href="#结构体tag介绍" class="headerlink" title="结构体tag介绍"></a>结构体tag介绍</h4><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;key1:&quot;value1&quot; key2:&quot;value2&quot;&#96;</span><br></pre></td></tr></table></figure>

<p>结构体tag由一个或多个键值对组成。键与值使用<strong>冒号</strong>分隔，值用<strong>双引号</strong>括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用<strong>空格</strong>分隔。</p>
<h4 id="使用json-tag指定字段名"><a href="#使用json-tag指定字段名" class="headerlink" title="使用json tag指定字段名"></a>使用json tag指定字段名</h4><p>序列化与反序列化默认情况下使用结构体的字段名，我们可以通过给结构体字段添加tag来指定json序列化生成的字段名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用json tag指定序列化与反序列化时的行为</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span> <span class="string">`json:"name"`</span> <span class="comment">// 指定json序列化/反序列化时使用小写name</span></span><br><span class="line">	Age    <span class="keyword">int64</span></span><br><span class="line">	Weight <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="忽略某个字段"><a href="#忽略某个字段" class="headerlink" title="忽略某个字段"></a>忽略某个字段</h4><p>如果你想在json序列化/反序列化的时候忽略掉结构体中的某个字段，可以按如下方式在tag中添加<code>-</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用json tag指定json序列化与反序列化时的行为</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span> <span class="string">`json:"name"`</span> <span class="comment">// 指定json序列化/反序列化时使用小写name</span></span><br><span class="line">	Age    <span class="keyword">int64</span></span><br><span class="line">	Weight <span class="keyword">float64</span> <span class="string">`json:"-"`</span> <span class="comment">// 指定json序列化/反序列化时忽略此字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="忽略空值字段"><a href="#忽略空值字段" class="headerlink" title="忽略空值字段"></a>忽略空值字段</h4><p>当 struct 中的字段没有值时， <code>json.Marshal()</code> 序列化的时候不会忽略这些字段，而是默认输出字段的类型零值（例如<code>int</code>和<code>float</code>类型零值是 0，<code>string</code>类型零值是<code>&quot;&quot;</code>，对象类型零值是 nil）。如果想要在序列序列化时忽略这些没有值的字段时，可以在对应字段添加<code>omitempty</code> tag。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span>   <span class="string">`json:"name"`</span></span><br><span class="line">	Email <span class="keyword">string</span>   <span class="string">`json:"email"`</span></span><br><span class="line">	Hobby []<span class="keyword">string</span> <span class="string">`json:"hobby"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">omitemptyDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u1 := User&#123;</span><br><span class="line">		Name: <span class="string">"七米"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// struct -&gt; json string</span></span><br><span class="line">	b, err := json.Marshal(u1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Marshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%s\n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str:&#123;<span class="string">"name"</span>:<span class="string">"七米"</span>,<span class="string">"email"</span>:<span class="string">""</span>,<span class="string">"hobby"</span>:null&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要在最终的序列化结果中去掉空值字段，可以像下面这样定义结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在tag中添加omitempty忽略空值</span></span><br><span class="line"><span class="comment">// 注意这里 hobby,omitempty 合起来是json tag值，中间用英文逗号分隔</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span>   <span class="string">`json:"name"`</span></span><br><span class="line">	Email <span class="keyword">string</span>   <span class="string">`json:"email,omitempty"`</span></span><br><span class="line">	Hobby []<span class="keyword">string</span> <span class="string">`json:"hobby,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，再执行上述的<code>omitemptyDemo</code>，输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str:&#123;<span class="string">"name"</span>:<span class="string">"七米"</span>&#125; <span class="comment">// 序列化结果中没有email和hobby字段</span></span><br></pre></td></tr></table></figure>

<h4 id="忽略嵌套结构体空值字段"><a href="#忽略嵌套结构体空值字段" class="headerlink" title="忽略嵌套结构体空值字段"></a>忽略嵌套结构体空值字段</h4><p>首先来看几种结构体嵌套的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span>   <span class="string">`json:"name"`</span></span><br><span class="line">	Email <span class="keyword">string</span>   <span class="string">`json:"email,omitempty"`</span></span><br><span class="line">	Hobby []<span class="keyword">string</span> <span class="string">`json:"hobby,omitempty"`</span></span><br><span class="line">	Profile</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">	Website <span class="keyword">string</span> <span class="string">`json:"site"`</span></span><br><span class="line">	Slogan  <span class="keyword">string</span> <span class="string">`json:"slogan"`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nestedStructDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u1 := User&#123;</span><br><span class="line">		Name:  <span class="string">"七米"</span>,</span><br><span class="line">		Hobby: []<span class="keyword">string</span>&#123;<span class="string">"足球"</span>, <span class="string">"双色球"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	b, err := json.Marshal(u1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Marshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%s\n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名嵌套<code>Profile</code>时序列化后的json串为单层的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str:&#123;<span class="string">"name"</span>:<span class="string">"七米"</span>,<span class="string">"hobby"</span>:[<span class="string">"足球"</span>,<span class="string">"双色球"</span>],<span class="string">"site"</span>:<span class="string">""</span>,<span class="string">"slogan"</span>:<span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure>

<p>想要变成嵌套的json串，需要改为具名嵌套或定义字段tag：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span>   <span class="string">`json:"name"`</span></span><br><span class="line">	Email   <span class="keyword">string</span>   <span class="string">`json:"email,omitempty"`</span></span><br><span class="line">	Hobby   []<span class="keyword">string</span> <span class="string">`json:"hobby,omitempty"`</span></span><br><span class="line">	Profile <span class="string">`json:"profile"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// str:&#123;"name":"七米","hobby":["足球","双色球"],"profile":&#123;"site":"","slogan":""&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>想要在嵌套的结构体为空值时，忽略该字段，仅添加<code>omitempty</code>是不够的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="keyword">string</span>   <span class="string">`json:"name"`</span></span><br><span class="line">	Email    <span class="keyword">string</span>   <span class="string">`json:"email,omitempty"`</span></span><br><span class="line">	Hobby    []<span class="keyword">string</span> <span class="string">`json:"hobby,omitempty"`</span></span><br><span class="line">	Profile <span class="string">`json:"profile,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// str:&#123;"name":"七米","hobby":["足球","双色球"],"profile":&#123;"site":"","slogan":""&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>还需要使用嵌套的结构体指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="keyword">string</span>   <span class="string">`json:"name"`</span></span><br><span class="line">	Email    <span class="keyword">string</span>   <span class="string">`json:"email,omitempty"`</span></span><br><span class="line">	Hobby    []<span class="keyword">string</span> <span class="string">`json:"hobby,omitempty"`</span></span><br><span class="line">	*Profile <span class="string">`json:"profile,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// str:&#123;"name":"七米","hobby":["足球","双色球"]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="不修改原结构体忽略空值字段"><a href="#不修改原结构体忽略空值字段" class="headerlink" title="不修改原结构体忽略空值字段"></a>不修改原结构体忽略空值字段</h4><p>我们需要json序列化<code>User</code>，但是不想把密码也序列化，又不想修改<code>User</code>结构体，这个时候我们就可以使用创建另外一个结构体<code>PublicUser</code>匿名嵌套原<code>User</code>，同时指定<code>Password</code>字段为匿名结构体指针类型，并添加<code>omitempty</code>tag，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">	Password <span class="keyword">string</span> <span class="string">`json:"password"`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> PublicUser <span class="keyword">struct</span> &#123;</span><br><span class="line">	*User             <span class="comment">// 匿名嵌套</span></span><br><span class="line">	Password *<span class="keyword">struct</span>&#123;&#125; <span class="string">`json:"password,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">omitPasswordDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u1 := User&#123;</span><br><span class="line">		Name:     <span class="string">"七米"</span>,</span><br><span class="line">		Password: <span class="string">"123456"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	b, err := json.Marshal(PublicUser&#123;User: &amp;u1&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Marshal u1 failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%s\n"</span>, b)      <span class="comment">// str:&#123;"name":"七米"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优雅处理字符串格式的数字"><a href="#优雅处理字符串格式的数字" class="headerlink" title="优雅处理字符串格式的数字"></a>优雅处理字符串格式的数字</h4><p>有时候，前端在传递来的json数据中可能会使用字符串类型的数字，这个时候可以在结构体tag中添加<code>string</code>来告诉json包从字符串中解析相应字段的数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Card <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID    <span class="keyword">int64</span>   <span class="string">`json:"id,string"`</span>    <span class="comment">// 添加string tag</span></span><br><span class="line">	Score <span class="keyword">float64</span> <span class="string">`json:"score,string"`</span> <span class="comment">// 添加string tag</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intAndStringDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	jsonStr1 := <span class="string">`&#123;"id": "1234567","score": "88.50"&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> c1 Card</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(jsonStr1), &amp;c1); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Unmarsha jsonStr1 failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"c1:%#v\n"</span>, c1)   <span class="comment">// c1:main.Card&#123;ID:1234567, Score:88.5&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="整数变浮点数"><a href="#整数变浮点数" class="headerlink" title="整数变浮点数"></a>整数变浮点数</h4><p>在 JSON 协议中是没有整型和浮点型之分的，它们统称为number。json字符串中的数字经过Go语言中的json包反序列化之后都会成为<code>float64</code>类型。下面的代码便演示了这个问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// map[string]interface&#123;&#125; -&gt; json string</span></span><br><span class="line">	<span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	m[<span class="string">"count"</span>] = <span class="number">1</span> <span class="comment">// int</span></span><br><span class="line">	b, err := json.Marshal(m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"marshal failed, err:%v\n"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%#v\n"</span>, <span class="keyword">string</span>(b))</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// json string -&gt; map[string]interface&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err = json.Unmarshal(b, &amp;m2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"unmarshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"value:%v\n"</span>, m2[<span class="string">"count"</span>]) <span class="comment">// 1</span></span><br><span class="line">	fmt.Printf(<span class="string">"type:%T\n"</span>, m2[<span class="string">"count"</span>])  <span class="comment">// float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种场景下如果想更合理的处理数字就需要使用<code>decoder</code>去反序列化，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decoderDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// map[string]interface&#123;&#125; -&gt; json string</span></span><br><span class="line">	<span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	m[<span class="string">"count"</span>] = <span class="number">1</span> <span class="comment">// int</span></span><br><span class="line">	b, err := json.Marshal(m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"marshal failed, err:%v\n"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%#v\n"</span>, <span class="keyword">string</span>(b))</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// json string -&gt; map[string]interface&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 使用decoder方式反序列化，指定使用number类型</span></span><br><span class="line">	decoder := json.NewDecoder(bytes.NewReader(b))</span><br><span class="line">	decoder.UseNumber()</span><br><span class="line">	err = decoder.Decode(&amp;m2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"unmarshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"value:%v\n"</span>, m2[<span class="string">"count"</span>]) <span class="comment">// 1</span></span><br><span class="line">	fmt.Printf(<span class="string">"type:%T\n"</span>, m2[<span class="string">"count"</span>])  <span class="comment">// json.Number</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 将m2["count"]转为json.Number之后调用Int64()方法获得int64类型的值</span></span><br><span class="line">	count, err := m2[<span class="string">"count"</span>].(json.Number).Int64()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"parse to int64 failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"type:%T\n"</span>, <span class="keyword">int</span>(count)) <span class="comment">// int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>json.Number</code>的源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Number represents a JSON number literal.</span></span><br><span class="line"><span class="keyword">type</span> Number <span class="keyword">string</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// String returns the literal text of the number.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n Number)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="keyword">string</span>(n) &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Float64 returns the number as a float64.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n Number)</span> <span class="title">Float64</span><span class="params">()</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.ParseFloat(<span class="keyword">string</span>(n), <span class="number">64</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Int64 returns the number as an int64.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n Number)</span> <span class="title">Int64</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.ParseInt(<span class="keyword">string</span>(n), <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在处理number类型的json字段时需要先得到<code>json.Number</code>类型，然后根据该字段的实际类型调用<code>Float64()</code>或<code>Int64()</code>。</p>
<h4 id="自定义解析时间字段"><a href="#自定义解析时间字段" class="headerlink" title="自定义解析时间字段"></a>自定义解析时间字段</h4><p>Go语言内置的 json 包使用 <code>RFC3339</code> 标准中定义的时间格式，对我们序列化时间字段的时候有很多限制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	CreateTime time.Time <span class="string">`json:"create_time"`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeFieldDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Post&#123;CreateTime: time.Now()&#125;</span><br><span class="line">	b, err := json.Marshal(p1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Marshal p1 failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%s\n"</span>, b)</span><br><span class="line">    </span><br><span class="line">	jsonStr := <span class="string">`&#123;"create_time":"2020-04-05 12:25:42"&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> p2 Post</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;p2); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Unmarshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"p2:%#v\n"</span>, p2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str:&#123;<span class="string">"create_time"</span>:<span class="string">"2020-04-05T12:28:06.799214+08:00"</span>&#125;</span><br><span class="line">json.Unmarshal failed, err:parsing time <span class="string">""</span><span class="number">2020</span><span class="number">-04</span><span class="number">-05</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">42</span><span class="string">""</span> as <span class="string">""</span><span class="number">2006</span><span class="number">-01</span><span class="number">-02</span>T15:<span class="number">04</span>:<span class="number">05</span>Z07:<span class="number">00</span><span class="string">""</span>: cannot parse <span class="string">" 12:25:42"</span><span class="string">" as "</span>T<span class="string">"</span></span><br></pre></td></tr></table></figure>

<p>也就是内置的json包不识别我们常用的字符串时间格式，如<code>2020-04-05 12:25:42</code>。</p>
<p>不过我们通过实现 <code>json.Marshaler</code>/<code>json.Unmarshaler</code> 接口实现自定义的事件格式解析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomTime <span class="keyword">struct</span> &#123;</span><br><span class="line">	time.Time</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> ctLayout = <span class="string">"2006-01-02 15:04:05"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> nilTime = (time.Time&#123;&#125;).UnixNano()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ct *CustomTime)</span> <span class="title">UnmarshalJSON</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	s := strings.Trim(<span class="keyword">string</span>(b), <span class="string">"\""</span>)</span><br><span class="line">	<span class="keyword">if</span> s == <span class="string">"null"</span> &#123;</span><br><span class="line">		ct.Time = time.Time&#123;&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ct.Time, err = time.Parse(ctLayout, s)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ct *CustomTime)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ct.Time.UnixNano() == nilTime &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">byte</span>(<span class="string">"null"</span>), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">"\"%s\""</span>, ct.Time.Format(ctLayout))), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ct *CustomTime)</span> <span class="title">IsSet</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ct.UnixNano() != nilTime</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	CreateTime CustomTime <span class="string">`json:"create_time"`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeFieldDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Post&#123;CreateTime: CustomTime&#123;time.Now()&#125;&#125;</span><br><span class="line">	b, err := json.Marshal(p1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Marshal p1 failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%s\n"</span>, b)</span><br><span class="line">    </span><br><span class="line">	jsonStr := <span class="string">`&#123;"create_time":"2020-04-05 12:25:42"&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> p2 Post</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;p2); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Unmarshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"p2:%#v\n"</span>, p2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义MarshalJSON和UnmarshalJSON方法"><a href="#自定义MarshalJSON和UnmarshalJSON方法" class="headerlink" title="自定义MarshalJSON和UnmarshalJSON方法"></a>自定义MarshalJSON和UnmarshalJSON方法</h4><p>上面那种自定义类型的方法稍显啰嗦了一点，下面来看一种相对便捷的方法。</p>
<p>首先你需要知道的是，如果你能够为某个类型实现了<code>MarshalJSON()([]byte, error)</code>和<code>UnmarshalJSON(b []byte) error</code>方法，那么这个类型在序列化（MarshalJSON）/反序列化（UnmarshalJSON）时就会使用你定制的相应方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID          <span class="keyword">int</span>       <span class="string">`json:"id"`</span></span><br><span class="line">	Title       <span class="keyword">string</span>    <span class="string">`json:"title"`</span></span><br><span class="line">	CreatedTime time.Time <span class="string">`json:"created_time"`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> layout = <span class="string">"2006-01-02 15:04:05"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// MarshalJSON 为Order类型实现自定义的MarshalJSON方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> TempOrder Order <span class="comment">// 定义与Order字段一致的新类型</span></span><br><span class="line">	<span class="keyword">return</span> json.Marshal(<span class="keyword">struct</span> &#123;</span><br><span class="line">		CreatedTime <span class="keyword">string</span> <span class="string">`json:"created_time"`</span></span><br><span class="line">		*TempOrder         <span class="comment">// 避免直接嵌套Order进入死循环</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		CreatedTime: o.CreatedTime.Format(layout),</span><br><span class="line">		TempOrder:   (*TempOrder)(o),</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// UnmarshalJSON 为Order类型实现自定义的UnmarshalJSON方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Order)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> TempOrder Order <span class="comment">// 定义与Order字段一致的新类型</span></span><br><span class="line">	ot := <span class="keyword">struct</span> &#123;</span><br><span class="line">		CreatedTime <span class="keyword">string</span> <span class="string">`json:"created_time"`</span></span><br><span class="line">		*TempOrder         <span class="comment">// 避免直接嵌套Order进入死循环</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		TempOrder: (*TempOrder)(o),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal(data, &amp;ot); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	o.CreatedTime, err = time.Parse(layout, ot.CreatedTime)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 自定义序列化方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">customMethodDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	o1 := Order&#123;</span><br><span class="line">		ID:          <span class="number">123456</span>,</span><br><span class="line">		Title:       <span class="string">"《七米的Go学习笔记》"</span>,</span><br><span class="line">		CreatedTime: time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 通过自定义的MarshalJSON方法实现struct -&gt; json string</span></span><br><span class="line">	b, err := json.Marshal(&amp;o1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Marshal o1 failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%s\n"</span>, b)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 通过自定义的UnmarshalJSON方法实现json string -&gt; struct</span></span><br><span class="line">	jsonStr := <span class="string">`&#123;"created_time":"2020-04-05 10:18:20","id":123456,"title":"《七米的Go学习笔记》"&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> o2 Order</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;o2); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Unmarshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"o2:%#v\n"</span>, o2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str:&#123;<span class="string">"created_time"</span>:<span class="string">"2020-04-05 10:32:20"</span>,<span class="string">"id"</span>:<span class="number">123456</span>,<span class="string">"title"</span>:<span class="string">"《七米的Go学习笔记》"</span>&#125;</span><br><span class="line"></span><br><span class="line">o2:main.Order&#123;ID:<span class="number">123456</span>, Title:<span class="string">"《七米的Go学习笔记》"</span>, CreatedTime:time.Time&#123;wall:<span class="number">0x0</span>, ext:<span class="number">63721678700</span>, loc:(*time.Location)(<span class="literal">nil</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用匿名结构体添加字段"><a href="#使用匿名结构体添加字段" class="headerlink" title="使用匿名结构体添加字段"></a>使用匿名结构体添加字段</h4><p>使用内嵌结构体能够扩展结构体的字段，但有时候我们没有必要单独定义新的结构体，可以使用匿名结构体简化操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID   <span class="keyword">int</span>    <span class="string">`json:"id"`</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anonymousStructDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u1 := UserInfo&#123;</span><br><span class="line">		ID:   <span class="number">123456</span>,</span><br><span class="line">		Name: <span class="string">"七米"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用匿名结构体内嵌User并添加额外字段Token</span></span><br><span class="line">	b, err := json.Marshal(<span class="keyword">struct</span> &#123;</span><br><span class="line">		*UserInfo</span><br><span class="line">		Token <span class="keyword">string</span> <span class="string">`json:"token"`</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&amp;u1,</span><br><span class="line">		<span class="string">"91je3a4s72d1da96h"</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Marsha failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%s\n"</span>, b)</span><br><span class="line">	<span class="comment">// str:&#123;"id":123456,"name":"七米","token":"91je3a4s72d1da96h"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用匿名结构体组合多个结构体"><a href="#使用匿名结构体组合多个结构体" class="headerlink" title="使用匿名结构体组合多个结构体"></a>使用匿名结构体组合多个结构体</h4><p>同理，也可以使用匿名结构体来组合多个结构体来序列化与反序列化数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Comment <span class="keyword">struct</span> &#123;</span><br><span class="line">	Content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Image <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title <span class="keyword">string</span> <span class="string">`json:"title"`</span></span><br><span class="line">	URL   <span class="keyword">string</span> <span class="string">`json:"url"`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anonymousStructDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := Comment&#123;</span><br><span class="line">		Content: <span class="string">"永远不要高估自己"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	i1 := Image&#123;</span><br><span class="line">		Title: <span class="string">"赞赏码"</span>,</span><br><span class="line">		URL:   <span class="string">"https://www.liwenzhou.com/images/zanshang_qr.jpg"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// struct -&gt; json string</span></span><br><span class="line">	b, err := json.Marshal(<span class="keyword">struct</span> &#123;</span><br><span class="line">		*Comment</span><br><span class="line">		*Image</span><br><span class="line">	&#125;&#123;&amp;c1, &amp;i1&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Marshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"str:%s\n"</span>, b)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// json string -&gt; struct</span></span><br><span class="line">	jsonStr := <span class="string">`&#123;"Content":"永远不要高估自己","title":"赞赏码","url":"https://www.liwenzhou.com/images/zanshang_qr.jpg"&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		c2 Comment</span><br><span class="line">		i2 Image</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">		*Comment</span><br><span class="line">		*Image</span><br><span class="line">	&#125;&#123;&amp;c2, &amp;i2&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Unmarshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"c2:%#v i2:%#v\n"</span>, c2, i2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str:&#123;<span class="string">"Content"</span>:<span class="string">"永远不要高估自己"</span>,<span class="string">"title"</span>:<span class="string">"赞赏码"</span>,<span class="string">"url"</span>:<span class="string">"https://www.liwenzhou.com/images/zanshang_qr.jpg"</span>&#125;</span><br><span class="line"></span><br><span class="line">c2:main.Comment&#123;Content:<span class="string">"永远不要高估自己"</span>&#125; i2:main.Image&#123;Title:<span class="string">"赞赏码"</span>, URL:<span class="string">"https://www.liwenzhou.com/images/zanshang_qr.jpg"</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理不确定层级的json"><a href="#处理不确定层级的json" class="headerlink" title="处理不确定层级的json"></a>处理不确定层级的json</h4><p>如果json串没有固定的格式导致不好定义与其相对应的结构体时，我们可以使用<code>json.RawMessage</code>原始字节数据保存下来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sendMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">	User <span class="keyword">string</span> <span class="string">`json:"user"`</span></span><br><span class="line">	Msg  <span class="keyword">string</span> <span class="string">`json:"msg"`</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawMessageDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	jsonStr := <span class="string">`&#123;"sendMsg":&#123;"user":"q1mi","msg":"永远不要高估自己"&#125;,"say":"Hello"&#125;`</span></span><br><span class="line">	<span class="comment">// 定义一个map，value类型为json.RawMessage，方便后续更灵活地处理</span></span><br><span class="line">	<span class="keyword">var</span> data <span class="keyword">map</span>[<span class="keyword">string</span>]json.RawMessage</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Unmarshal jsonStr failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> msg sendMsg</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal(data[<span class="string">"sendMsg"</span>], &amp;msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"json.Unmarshal failed, err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"msg:%#v\n"</span>, msg)</span><br><span class="line">	<span class="comment">// msg:main.sendMsg&#123;User:"q1mi", Msg:"永远不要高估自己"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a href="https://stackoverflow.com/questions/25087960/json-unmarshal-time-that-isnt-in-rfc-3339-format" target="_blank" rel="noopener">https://stackoverflow.com/questions/25087960/json-unmarshal-time-that-isnt-in-rfc-3339-format</a></p>
<p><a href="https://colobu.com/2017/06/21/json-tricks-in-Go/" target="_blank" rel="noopener">https://colobu.com/2017/06/21/json-tricks-in-Go/</a></p>
<p><a href="https://stackoverflow.com/questions/11066946/partly-json-unmarshal-into-a-map-in-go" target="_blank" rel="noopener">https://stackoverflow.com/questions/11066946/partly-json-unmarshal-into-a-map-in-go</a></p>
<p><a href="http://choly.ca/post/go-json-marshalling/" target="_blank" rel="noopener">http://choly.ca/post/go-json-marshalling/</a></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Redis统计在线用户人数</title>
    <url>/2020/02/26/%E4%BD%BF%E7%94%A8Redis%E7%BB%9F%E8%AE%A1%E5%9C%A8%E7%BA%BF%E7%94%A8%E6%88%B7%E4%BA%BA%E6%95%B0/</url>
    <content><![CDATA[<p>​    在构建应用的时候， 我们经常需要对用户的一举一动进行记录， 而其中一个比较重要的操作， 就是对在线的用户进行记录。</p>
<p>​    本文将介绍四种使用 Redis 对在线用户进行记录的方案， 这些方案虽然都可以对在线用户的数量进行统计， 但每个方案都有一些自己特有的操作， 并且各个方案的性能特征以及资源消耗也各有不同。</p>
<a id="more"></a>

<h3 id="方案-1-：使用有序集合"><a href="#方案-1-：使用有序集合" class="headerlink" title="方案 1 ：使用有序集合"></a>方案 1 ：使用有序集合</h3><p>每当一个用户上线时， 我们就执行 <a href="http://redisdoc.com/sorted_set/zadd.html" target="_blank" rel="noopener">ZADD</a> 命令， 将这个用户以及它的在线时间添加到指定的有序集合中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZADD &quot;online_users&quot; &lt;user_id&gt; &lt;current_timestamp&gt;</span><br></pre></td></tr></table></figure>

<p>通过使用 <a href="http://redisdoc.com/sorted_set/zscore.html" target="_blank" rel="noopener">ZSCORE</a> 命令检查指定时间的用户在有序集合中是否有相关联的分值， 我们可以知道该用户是否在线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZSCORE &quot;online_users&quot; &lt;current_timestamp&gt;</span><br></pre></td></tr></table></figure>

<p>而通过执行 <a href="http://redisdoc.com/sorted_set/zcard.html" target="_blank" rel="noopener">ZCARD</a> 命令， 我们可以知道总共有多用户在线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZCARD &quot;online_users&quot;</span><br></pre></td></tr></table></figure>

<p>使用有序集合储存在线用户的强大之处在于， 它是本文介绍的所有方案当中， 能够执行最多聚合操作的一个方案， 原因在于， 这一方案既可以通过有序集合的成员（也即是用户的 ID）进行聚合操作， 也可以根据有序集合的分值（也即是用户的登录时间）进行聚合操作。</p>
<p>首先， 通过 <a href="http://redisdoc.com/sorted_set/zinterstore.html" target="_blank" rel="noopener">ZINTERSTORE</a> 和 <a href="http://redisdoc.com/sorted_set/zunionstore.html" target="_blank" rel="noopener">ZUNIONSTORE</a> 命令， 我们可以对多个记录了在线用户的有序集合进行聚合计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 计算出 7 天之内都有上线的用户，并将它储存到 7_days_both_online_users 有序集合当中</span><br><span class="line">ZINTERSTORE 7_days_both_online_users 7 &quot;day_1_online_users&quot; &quot;day_2_online_users&quot; ... &quot;day_7_online_users&quot;</span><br><span class="line"></span><br><span class="line"># 计算出 7 天之内总共有多少人上线了</span><br><span class="line">ZUNIONSTORE 7_days_total_online_users 7 &quot;day_1_online_users&quot; ... &quot;day_7_online_users&quot;</span><br></pre></td></tr></table></figure>

<p>此外， 通过 <a href="http://redisdoc.com/sorted_set/zcount.html" target="_blank" rel="noopener">ZCOUNT</a> 命令， 我们可以统计出在指定的时间段之内有多少用户在线， 而 <a href="http://redisdoc.com/sorted_set/zrangebyscore.html" target="_blank" rel="noopener">ZRANGEBYSCORE</a> 命令则可以让我们获取到这些用户的名单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 统计指定时间段内上线的用户数量</span><br><span class="line">ZCOUNT &quot;online_users&quot; &lt;start_timestamp&gt; &lt;end_timestamp&gt;</span><br><span class="line"></span><br><span class="line"># 获取指定时间段内上线的用户名单</span><br><span class="line">ZRANGEBYSCORE &quot;online_users&quot; &lt;start_timestamp&gt; &lt;end_timestamp&gt; WITHSCORES</span><br></pre></td></tr></table></figure>

<p>通过这一方法， 我们可以知道网站在不同时间段的上线人数以及上线用户名单， 比如说， 我们可以用这个方法来分别获知网站在早晨、上午、中午、下午和夜晚的上线人数。</p>
<h3 id="方案-2-：使用集合"><a href="#方案-2-：使用集合" class="headerlink" title="方案 2 ：使用集合"></a>方案 2 ：使用集合</h3><p>正如上一节所说， 使用有序集合能够同时储存在线用户的名单以及各个用户的上线时间， 但如果我们只想要记录在线用户的名单， 而不想要储存用户的上线时间， 那么也可以使用集合来代替有序集合， 对在线的用户进行记录。</p>
<p>在这种情况下， 每当一个用户上线时， 我们就执行以下 <a href="http://redisdoc.com/set/sadd.html" target="_blank" rel="noopener">SADD</a> 命令， 将它添加到在线用户名单当中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SADD &quot;online_users&quot; &lt;user_id&gt;</span><br></pre></td></tr></table></figure>

<p>通过使用 <a href="http://redisdoc.com/set/sismember.html" target="_blank" rel="noopener">SISMEMBER</a> 命令， 我们可以检查一个指定的用户当前是否在线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SISMEMBER &quot;online_users&quot; &lt;user_id&gt;</span><br></pre></td></tr></table></figure>

<p>而统计在线人数的工作则可以通过执行 <a href="http://redisdoc.com/set/scard.html" target="_blank" rel="noopener">SCARD</a> 命令来完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCARD &quot;online_users&quot;</span><br></pre></td></tr></table></figure>

<p>通过集合运算操作， 我们可以像有序集合方案一样， 对不同时间段或者日期的在线用户名单进行聚合计算。 比如说， 通过 <a href="http://redisdoc.com/set/sinter.html" target="_blank" rel="noopener">SINTER</a> 或者 <a href="http://redisdoc.com/set/sinterstore.html" target="_blank" rel="noopener">SINTERSTORE</a> 命令， 我们可以计算出一周都有在线的用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SINTER &quot;day_1_online_users&quot; &quot;day_2_online_users&quot; ... &quot;day_7_online_users&quot;</span><br></pre></td></tr></table></figure>

<p>此外， 通过 <a href="http://redisdoc.com/set/sunion.html" target="_blank" rel="noopener">SUNION</a> 命令或者 <a href="http://redisdoc.com/set/sunionstore.html" target="_blank" rel="noopener">SUNIONSTORE</a> 命令， 我们可以计算出一周内在线用户的总数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SUNION &quot;day_1_online_users&quot; &quot;day_2_online_users&quot; ... &quot;day_7_online_users&quot;</span><br></pre></td></tr></table></figure>

<p>而通过执行 <a href="http://redisdoc.com/set/sdiff.html" target="_blank" rel="noopener">SDIFF</a> 命令或者 <a href="http://redisdoc.com/set/sdiffstore.html" target="_blank" rel="noopener">SDIFFSTORE</a> 命令， 我们可以知道哪些用户今天上线了， 但是昨天没有上线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SDIFF &quot;today_online_users&quot; &quot;yesterday_online_users&quot;</span><br></pre></td></tr></table></figure>

<p>又或者工作日上线了， 但是假日没有上线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 计算工作日上线名单</span><br><span class="line">SINTERSTORE &quot;weekday_online_users&quot; &quot;monday_online_users&quot; &quot;tuesday_online_users&quot; ... &quot;friday_online_users&quot;</span><br><span class="line"># 计算假日上线名单</span><br><span class="line">SINTERSTORE &quot;holiday_online_users&quot; &quot;saturday_online_users&quot; &quot;sunday_online_users&quot;</span><br><span class="line"># 计算工作日上线但是假日未上线的名单</span><br><span class="line">SDIFF &quot;weekday_online_users&quot; &quot;holiday_online_users&quot;</span><br></pre></td></tr></table></figure>

<p>诸如此类。</p>
<h3 id="方案-3-：使用-HyperLogLog"><a href="#方案-3-：使用-HyperLogLog" class="headerlink" title="方案 3 ：使用 HyperLogLog"></a>方案 3 ：使用 HyperLogLog</h3><p>虽然使用有序集合和集合能够很好地完成记录在线人数的工作， 但以上这两个方案都有一个明显的缺点， 那就是， 这两个方案耗费的内存会随着被统计用户数量的增多而增多： 如果你的网站用户数量比较多， 又或者你需要记录多天/多个时段的在线用户名单并进行聚合计算， 那么这两个方案可能会消耗你大量内存。</p>
<p>另一方面， 在有些情况下， 我们只想要知道在线用户的人数， 而不需要知道具体的在线用户名单， 这时有序集合和集合储存的信息就会显得多余了。</p>
<p>在需要尽可能地节约内存并且只需要知道在线用户数量的情况下， 我们可以使用 HyperLogLog 来对在线用户进行统计： HyperLogLog 是一个概率算法， 它可以对元素的基数进行估算， 并且每个 HyperLogLog 只需要耗费 12 KB 内存， 对于用户数量非常多但是内存却非常紧张的系统， 这一方案无疑是最佳之选。</p>
<p>在这一方案下， 我们使用 <a href="http://redisdoc.com/hyperloglog/pfadd.html" target="_blank" rel="noopener">PFADD</a> 命令去记录在线的用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PFADD &quot;online_users&quot; &lt;user_id&gt;</span><br></pre></td></tr></table></figure>

<p>使用 <a href="http://redisdoc.com/hyperloglog/pfcount.html" target="_blank" rel="noopener">PFCOUNT</a> 命令获取在线人数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PFCOUNT &quot;online_users&quot;</span><br></pre></td></tr></table></figure>

<p>因为 HyperLogLog 也提供了计算交集的 <a href="http://redisdoc.com/hyperloglog/pfmerge.html" target="_blank" rel="noopener">PFMERGE</a> 命令， 所以我们也可以用这个命令计算出多个给定时间段或日期之内， 上线的总人数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 统计 7 天之内总共有多少人上线了</span><br><span class="line">PFMERGE &quot;7_days_both_online_users&quot; &quot;day_1_online_users&quot; &quot;day_2_online_users&quot; ... &quot;day_7_online_users&quot;</span><br><span class="line">PFCOUNT &quot;7_days_both_online_users&quot;</span><br></pre></td></tr></table></figure>

<h3 id="方案-4-：使用位图（bitmap）"><a href="#方案-4-：使用位图（bitmap）" class="headerlink" title="方案 4 ：使用位图（bitmap）"></a>方案 4 ：使用位图（bitmap）</h3><p>回顾上面介绍的三个方案， 我们可以得出以上结论：</p>
<ul>
<li>使用有序集合或者集合能够储存具体的在线用户名单， 但是却需要消耗大量的内存；</li>
<li>而使用 HyperLogLog 虽然能够有效地减少统计在线用户所需的内存， 但是它却没办法准确地记录具体的在线用户名单。</li>
</ul>
<p>那么是否存在一种既能够获得在线用户名单， 又可以尽量减少内存消耗的方法存在呢？ 这种方法的确存在 —— 使用 Redis 的位图就可以办到。</p>
<p>Redis 的位图就是一个由二进制位组成的数组， 通过将数组中的每个二进制位与用户 ID 进行一一对应， 我们可以使用位图去记录每个用户是否在线。</p>
<p>当一个用户上线时， 我们就使用 <a href="http://redisdoc.com/string/setbit.html" target="_blank" rel="noopener">SETBIT</a> 命令， 将这个用户对应的二进制位设置为 1 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 此处的 user_id 必须为数字，因为它会被用作索引</span><br><span class="line">SETBIT &quot;online_users&quot; &lt;user_id&gt; 1</span><br></pre></td></tr></table></figure>

<p>通过使用 <a href="http://redisdoc.com/string/getbit.html" target="_blank" rel="noopener">GETBIT</a> 命令去检查一个二进制位的值是否为 1 ， 我们可以知道指定的用户是否在线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GETBIT &quot;online_users&quot; &lt;user_id&gt;</span><br></pre></td></tr></table></figure>

<p>而通过 <a href="http://redisdoc.com/string/bitcount.html" target="_blank" rel="noopener">BITCOUNT</a> 命令， 我们可以统计出位图中有多少个二进制位被设置成了 1 ， 也即是有多少个用户在线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BITCOUNT &quot;online_users&quot;</span><br></pre></td></tr></table></figure>

<p>跟集合一样， 用户也能够对多个位图进行聚合计算 —— 通过 <a href="http://redisdoc.com/string/bitop.html" target="_blank" rel="noopener">BITOP</a> 命令， 用户可以对一个或多个位图执行逻辑并、逻辑或、逻辑异或或者逻辑非操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 计算出 7 天都在线的用户</span><br><span class="line">BITOP &quot;AND&quot; &quot;7_days_both_online_users&quot; &quot;day_1_online_users&quot; &quot;day_2_online_users&quot; ... &quot;day_7_online_users&quot;</span><br><span class="line"></span><br><span class="line"># 计算出 7 在的在线用户总人数</span><br><span class="line">BITOP &quot;OR&quot; &quot;7_days_total_online_users&quot; &quot;day_1_online_users&quot; &quot;day_2_online_users&quot; ... &quot;day_7_online_users&quot;</span><br><span class="line"></span><br><span class="line"># 计算出两天当中只有其中一天在线的用户</span><br><span class="line">BITOP &quot;XOR&quot; &quot;only_one_day_online&quot; &quot;day_1_online_users&quot; &quot;day_2_online_users&quot;</span><br></pre></td></tr></table></figure>

<p>HyperLogLog 方案记录一个用户是否在线需要花费 1 个二进制位， 对于用户数为 100 万的网站来说， 使用这一方案只需要耗费 125 KB 内存， 而对于用户数为 1000 万的网站来说， 使用这一方案也只需要花费 1.25 MB 内存。</p>
<p>虽然位图节约内存的效果不及 HyperLogLog 那么显著， 但是使用位图可以准确地判断一个用户是否上线， 并且能够像集合和有序集合一样， 对在线用户名单进行聚合计算。 因此对于想要尽量节约内存， 但又需要准确地知道用户是否在线， 又或者需要对用户的在线名单进行聚合计算的应用来说， 使用位图可以说是最佳之选。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以下表格总结了以上四个方案的特点：</p>
<table>
<thead>
<tr>
<th align="left">方案</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">有序集合</td>
<td align="left">能够同时储存在线用户的名单以及用户的上线时间，能够执行非常多的聚合计算操作，但是耗费的内存也非常多。</td>
</tr>
<tr>
<td align="left">集合</td>
<td align="left">能够储存在线用户的名单，也能够执行聚合计算，消耗的内存比有序集合少，但是跟有序集合一样，这个方案消耗的内存也会随着用户数量的增多而增多。</td>
</tr>
<tr>
<td align="left">HyperLogLog</td>
<td align="left">无论需要统计的用户有多少，只需要耗费 12 KB 内存，但由于概率算法的特性，只能给出在线人数的估算值，并且也无法获取准确的在线用户名单。</td>
</tr>
<tr>
<td align="left">位图</td>
<td align="left">在尽可能节约内存的情况下，记录在线用户的名单，并且能够对这些名单执行聚合操作。</td>
</tr>
</tbody></table>
<p>因为 Redis 同时支持多种数据结构， 所以一个问题常常可以在 Redis 里面找多种不同的解法， 并且每种解法都有各自的优点和缺点， 本文介绍的问题就是一个很好的例子。</p>
<p>关于统计在线用户的方法就介绍到这里， 希望这些方案会给大家带来帮助和启发。</p>
<p>本文转发自：<a href="https://blog.csdn.net/zwjyyy1203/article/details/80342874" target="_blank" rel="noopener">https://blog.csdn.net/zwjyyy1203/article/details/80342874</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用cython加密python程序</title>
    <url>/2019/10/28/%E4%BD%BF%E7%94%A8cython%E5%8A%A0%E5%AF%86python%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>Python简单易用，但有时候一些敏感信息不希望用户通过源码查看到，所以需要加密保证安全性。分析了一些加密方式最终决定使用cython加密源码，其实就是把py代码编译成C或者C++代码来执行，在Linux 上会生成.so二进制文件，Windows下为.pyd，所以还有一个作用是加速代码的执行效率。下例在CentOS7.6+Python3.74下测试通过。</p>
</blockquote>
<a id="more"></a>

<h4 id="修改原文件"><a href="#修改原文件" class="headerlink" title="修改原文件"></a>修改原文件</h4><p>首先在需要加密的python文件头部添加以下行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cython : language_level&#x3D;3</span><br></pre></td></tr></table></figure>

<h4 id="安装cython"><a href="#安装cython" class="headerlink" title="安装cython"></a>安装cython</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install cython</span><br><span class="line">or</span><br><span class="line">pip3 install cython</span><br></pre></td></tr></table></figure>
<h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>将cython执行文件目录加入系统环境变量,一般在python安装目录下的bin文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CYTHON_DIR&#x3D;&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin</span><br><span class="line">export PATH&#x3D;$PATH:$CYTHON_DIR</span><br></pre></td></tr></table></figure>
<p>确定python安装库文件目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PYTHON_INCLUDE_DIR&#x3D;&#x2F;usr&#x2F;local&#x2F;python3&#x2F;include&#x2F;python3.7m</span><br></pre></td></tr></table></figure>

<h4 id="程序加密"><a href="#程序加密" class="headerlink" title="程序加密"></a>程序加密</h4><p>将文件转换为.c文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cython app.py</span><br></pre></td></tr></table></figure>
<p>gcc将.c文件编译成o文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c -fPIC -I$PYTHON_INCLUDE_DIR app.c</span><br></pre></td></tr></table></figure>
<p>gcc将.o文件编译成so文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -shared app.o -o app.so</span><br></pre></td></tr></table></figure>
<p>如果不需要原文件了，可以删除（强烈建议备份）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm app.c app.o app.py</span><br></pre></td></tr></table></figure>

<h4 id="加密后程序的使用"><a href="#加密后程序的使用" class="headerlink" title="加密后程序的使用"></a>加密后程序的使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import app</span><br><span class="line">or</span><br><span class="line">from app import class_name</span><br></pre></td></tr></table></figure>

<p><em>如果需要加密的文件比较多，可以写个简单的脚本批量处理。</em></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>基于RHEL8/CentOS8的nmcli常见命令总结</title>
    <url>/2019/10/29/%E5%9F%BA%E4%BA%8ERHEL8-CentOS8%E7%9A%84nmcli%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>开始前建议在使用前先安装命令补全包，<code>tab</code>就可以补全命令了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install bash-completion -y</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>看一下帮助，了解一下命令的简写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@redhat ~]# nmcli -h</span><br><span class="line">用法：nmcli [选项] 对象 </span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -o[verview]                    概览模式（隐藏默认值）</span><br><span class="line">  -t[erse]                       简洁输出</span><br><span class="line">  -p[retty]                      整齐输出</span><br><span class="line">  -m[ode] tabular|multiline      输出模式</span><br><span class="line">  -c[olors] auto|yes|no          是否在输出中使用颜色</span><br><span class="line">  -f[ields] |all|common          指定要输出的字段</span><br><span class="line">  -g[et-values] |all|common      -m tabular -t -f 的快捷方式</span><br><span class="line">  -e[scape] yes|no               在值中转义列分隔符</span><br><span class="line">  -a[sk]                         询问缺少的参数</span><br><span class="line">  -s[how-secrets]                允许显示密码</span><br><span class="line">  -w[ait]                        为完成的操作设置超时等待时间</span><br><span class="line">  -v[ersion]                     显示程序版本</span><br><span class="line">  -h[elp]                        输出此帮助</span><br><span class="line"></span><br><span class="line">对象：</span><br><span class="line">  g[eneral]       网络管理器（NetworkManager）的常规状态和操作</span><br><span class="line">  n[etworking]    整体联网控制</span><br><span class="line">  r[adio]         无线网络管理器开关</span><br><span class="line">  c[onnection]    网络管理器的连接</span><br><span class="line">  d[evice]        由网络管理器管理的设备</span><br><span class="line">  a[gent]         网络管理器的密钥（secret）代理或 polkit 代理</span><br><span class="line">  m[onitor]       监视网络管理器更改</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下提及的ifcfg均指代/etc/sysconfig/network-scripts/ifcfg-ethX及/etc/sysconfig/network-scripts/route-ethX</p>
</blockquote>
<h4 id="查看ip（类似于ifconfig、ip-addr）"><a href="#查看ip（类似于ifconfig、ip-addr）" class="headerlink" title="查看ip（类似于ifconfig、ip addr）"></a>查看ip（类似于ifconfig、ip addr）</h4><p>nmcli</p>
<h4 id="创建connection，配置静态ip（等同于配置ifcfg，其中BOOTPROTO-none，并ifup启动）"><a href="#创建connection，配置静态ip（等同于配置ifcfg，其中BOOTPROTO-none，并ifup启动）" class="headerlink" title="创建connection，配置静态ip（等同于配置ifcfg，其中BOOTPROTO=none，并ifup启动）"></a>创建connection，配置静态ip（等同于配置ifcfg，其中BOOTPROTO=none，并ifup启动）</h4><p>nmcli connection add type ethernet con-name ethX ifname ethX ipv4.addr 192.168.1.100/24 ipv4.gateway 192.168.1.1 ipv4.method manual</p>
<h4 id="创建connection，配置动态ip（等同于配置ifcfg，其中BOOTPROTO-dhcp，并ifup启动）"><a href="#创建connection，配置动态ip（等同于配置ifcfg，其中BOOTPROTO-dhcp，并ifup启动）" class="headerlink" title="创建connection，配置动态ip（等同于配置ifcfg，其中BOOTPROTO=dhcp，并ifup启动）"></a>创建connection，配置动态ip（等同于配置ifcfg，其中BOOTPROTO=dhcp，并ifup启动）</h4><p>nmcli connection add type ethernet con-name ethX ifname ethX ipv4.method auto</p>
<h4 id="修改ip（非交互式）"><a href="#修改ip（非交互式）" class="headerlink" title="修改ip（非交互式）"></a>修改ip（非交互式）</h4><p>nmcli connection modify ethX ipv4.addr ‘192.168.1.200/24’<br>nmcli connection up ethX</p>
<h4 id="修改ip（交互式）"><a href="#修改ip（交互式）" class="headerlink" title="修改ip（交互式）"></a>修改ip（交互式）</h4><p>nmcli connection edit ethX<br>nmcli&gt; goto ipv4.addresses<br>nmcli ipv4.addresses&gt; change<br>Edit ‘addresses’ value: 192.168.1.200/24<br>Do you also want to set ‘ipv4.method’ to ‘manual’? [yes]: yes<br>nmcli ipv4&gt; save<br>nmcli ipv4&gt; activate<br>nmcli ipv4&gt; quit</p>
<h4 id="启用connection（相当于ifup）"><a href="#启用connection（相当于ifup）" class="headerlink" title="启用connection（相当于ifup）"></a>启用connection（相当于ifup）</h4><p>nmcli connection up ethX</p>
<h4 id="停止connection（相当于ifdown）"><a href="#停止connection（相当于ifdown）" class="headerlink" title="停止connection（相当于ifdown）"></a>停止connection（相当于ifdown）</h4><p>nmcli connection down</p>
<h4 id="删除connection（类似于ifdown并删除ifcfg）"><a href="#删除connection（类似于ifdown并删除ifcfg）" class="headerlink" title="删除connection（类似于ifdown并删除ifcfg）"></a>删除connection（类似于ifdown并删除ifcfg）</h4><p>nmcli connection delete ethX</p>
<h4 id="查看connection列表"><a href="#查看connection列表" class="headerlink" title="查看connection列表"></a>查看connection列表</h4><p>nmcli connection show<br>nmcli connection</p>
<h4 id="查看connection详细信息"><a href="#查看connection详细信息" class="headerlink" title="查看connection详细信息"></a>查看connection详细信息</h4><p>nmcli connection show ethX</p>
<h4 id="重载所有ifcfg或route到connection（不会立即生效）"><a href="#重载所有ifcfg或route到connection（不会立即生效）" class="headerlink" title="重载所有ifcfg或route到connection（不会立即生效）"></a>重载所有ifcfg或route到connection（不会立即生效）</h4><p>nmcli connection reload</p>
<h4 id="重载指定ifcfg或route到connection（不会立即生效）"><a href="#重载指定ifcfg或route到connection（不会立即生效）" class="headerlink" title="重载指定ifcfg或route到connection（不会立即生效）"></a>重载指定ifcfg或route到connection（不会立即生效）</h4><p>nmcli connection load /etc/sysconfig/network-scripts/ifcfg-ethX<br>nmcli connection load /etc/sysconfig/network-scripts/route-ethX</p>
<h4 id="立即生效connection，有3种方法"><a href="#立即生效connection，有3种方法" class="headerlink" title="立即生效connection，有3种方法"></a>立即生效connection，有3种方法</h4><p>nmcli connection up ethX<br>nmcli device reapply ethX<br>nmcli device connect ethX</p>
<h4 id="查看device列表"><a href="#查看device列表" class="headerlink" title="查看device列表"></a>查看device列表</h4><p>nmcli device</p>
<h4 id="查看所有device详细信息"><a href="#查看所有device详细信息" class="headerlink" title="查看所有device详细信息"></a>查看所有device详细信息</h4><p>nmcli device show</p>
<h4 id="查看指定device的详细信息"><a href="#查看指定device的详细信息" class="headerlink" title="查看指定device的详细信息"></a>查看指定device的详细信息</h4><p>nmcli device show ethX</p>
<h4 id="激活网卡"><a href="#激活网卡" class="headerlink" title="激活网卡"></a>激活网卡</h4><p>nmcli device connect ethX</p>
<h4 id="关闭无线网络（NM默认启用无线网络）"><a href="#关闭无线网络（NM默认启用无线网络）" class="headerlink" title="关闭无线网络（NM默认启用无线网络）"></a>关闭无线网络（NM默认启用无线网络）</h4><p>nmcli radio all off</p>
<h4 id="查看NM纳管状态"><a href="#查看NM纳管状态" class="headerlink" title="查看NM纳管状态"></a>查看NM纳管状态</h4><p>nmcli networking</p>
<h4 id="开启NM纳管"><a href="#开启NM纳管" class="headerlink" title="开启NM纳管"></a>开启NM纳管</h4><p>nmcli networking on</p>
<h4 id="关闭NM纳管（谨慎执行）"><a href="#关闭NM纳管（谨慎执行）" class="headerlink" title="关闭NM纳管（谨慎执行）"></a>关闭NM纳管（谨慎执行）</h4><p>nmcli networking off</p>
<h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p>nmcli monitor</p>
<h4 id="查看NM本身状态"><a href="#查看NM本身状态" class="headerlink" title="查看NM本身状态"></a>查看NM本身状态</h4><p>nmcli</p>
<h4 id="检测NM是否在线可用"><a href="#检测NM是否在线可用" class="headerlink" title="检测NM是否在线可用"></a>检测NM是否在线可用</h4><p>nm-online</p>
<p>转载修改自：<a href="https://blog.51cto.com/cyent/2332161" target="_blank" rel="noopener">https://blog.51cto.com/cyent/2332161</a></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>很多人不知道的Python 炫技操作：海象运算符的三种用法</title>
    <url>/2020/04/22/%E5%BE%88%E5%A4%9A%E4%BA%BA%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Python-%E7%82%AB%E6%8A%80%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%B5%B7%E8%B1%A1%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>Python 版本发展非常快，如今最新的版本已经是 Pyhton 3.9，即便如此，有很多人甚至还停留在 3.6 或者 3.7，连 3.8 还没用上。</p>
<p>很多 Python 3.8 的特性还没来得及了解，就已经成为旧知识了，比如今天要说的海象运算符。</p>
<p>海象运算符是在 PEP 572 被提出的，直到 3.8 版本合入发布。</p>
<p>它的英文原名叫 <code>Assignment Expressions</code>，翻译过来也就是 <code>赋值表达式</code>，不过现在大家更普遍地称之为海象运算符，就是因为它长得真的太像海象了。</p>
<a id="more"></a>

<h3 id="1-第一个用法：if-else"><a href="#1-第一个用法：if-else" class="headerlink" title="1. 第一个用法：if/else"></a>1. 第一个用法：if/else</h3><p>可能有朋友是第一次接触这个新特性，所以还是简单的介绍一下这个海象运算符有什么用？</p>
<p>在 Golang 中的条件语句可以直接在 if 中运算变量的获取后直接对这个变量进行判断，可以让你少写一行代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    <span class="keyword">if</span> age := <span class="number">20</span>;age &gt; <span class="number">18</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"已经成年了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若在 Python 3.8 之前，Python 必须得这样子写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">"已经成年了"</span>)</span><br></pre></td></tr></table></figure>

<p>但有了海象运算符之后，你可以和 Golang 一样（如果你没学过 Golang，那这里要注意，Golang 中的 <code>:=</code> 叫短变量声明，意思是声明并初始化，它和 Python 中的 <code>:=</code> 不是一个概念）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (age:= <span class="number">20</span>) &gt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">"已经成年了"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-第二个用法：while"><a href="#2-第二个用法：while" class="headerlink" title="2. 第二个用法：while"></a>2. 第二个用法：while</h3><p>在不使用 海象运算符之前，使用 while 循环来读取文件的时候，你也许会这么写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">"demo.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = file.readline()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(line.strip())</span><br></pre></td></tr></table></figure>

<p>但有了海象运算符之后，你可以这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">"demo.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line"><span class="keyword">while</span> (line := file.readline()):</span><br><span class="line">    print(line.strip())</span><br></pre></td></tr></table></figure>

<p>使用它替换以往的无限 while 循环写法更为惊艳</p>
<p>比如，实现一个需要命令行交互输入密码并检验的代码，你也许会这样子写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">   p = input(<span class="string">"Enter the password: "</span>)</span><br><span class="line">   <span class="keyword">if</span> p == <span class="string">"youpassword"</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>有了海象运算符之后，这样子写更为舒服</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (p := input(<span class="string">"Enter the password: "</span>)) != <span class="string">"youpassword"</span>:</span><br><span class="line">   <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h3 id="3-第三个用法：推导式"><a href="#3-第三个用法：推导式" class="headerlink" title="3. 第三个用法：推导式"></a>3. 第三个用法：推导式</h3><p>这个系列的文章，几乎每篇都能看到推导式的身影，这一篇依旧如此。</p>
<p>在编码过程中，我很喜欢使用推导式，在简单的应用场景下，它简洁且不失高效。</p>
<p>如下这段代码中，我会使用列表推导式得出所有会员中过于肥胖的人的 bmi 指数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">members = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"小五"</span>, <span class="string">"age"</span>: <span class="number">23</span>, <span class="string">"height"</span>: <span class="number">1.75</span>, <span class="string">"weight"</span>: <span class="number">72</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"小李"</span>, <span class="string">"age"</span>: <span class="number">17</span>, <span class="string">"height"</span>: <span class="number">1.72</span>, <span class="string">"weight"</span>: <span class="number">63</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"小陈"</span>, <span class="string">"age"</span>: <span class="number">20</span>, <span class="string">"height"</span>: <span class="number">1.78</span>, <span class="string">"weight"</span>: <span class="number">82</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bmi</span><span class="params">(info)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"执行了 <span class="subst">&#123;count&#125;</span> 次"</span>)</span><br><span class="line"></span><br><span class="line">    height = info[<span class="string">"height"</span>]</span><br><span class="line">    weight = info[<span class="string">"weight"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> weight / (height**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查出所有会员中过于肥胖的人的 bmi 指数</span></span><br><span class="line">fat_bmis = [get_bmi(m) <span class="keyword">for</span> m <span class="keyword">in</span> members <span class="keyword">if</span> get_bmi(m) &gt; <span class="number">24</span>]</span><br><span class="line"></span><br><span class="line">print(fat_bmis)</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">执行了 <span class="number">1</span> 次</span><br><span class="line">执行了 <span class="number">2</span> 次</span><br><span class="line">执行了 <span class="number">3</span> 次</span><br><span class="line">执行了 <span class="number">4</span> 次</span><br><span class="line">[<span class="number">25.88057063502083</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到，会员数只有 3 个，但是 get_bmi 函数却执行了 4 次，原因是在判断时执行了 3 次，而在构造新的列表时又重复执行了一遍。</p>
<p>如果所有会员都是过于肥胖的，那最终将执行 6 次，这种在大量的数据下是比较浪费性能的，因此对于这种结构，我通常会使用传统的for 循环 + if 判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fat_bmis = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查出所有会员中过于肥胖的人的 bmi 指数</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> members:</span><br><span class="line">    bmi = get_bmi(m)</span><br><span class="line">    <span class="keyword">if</span> bmi &gt; <span class="number">24</span>:</span><br><span class="line">        fat_bmis.append(bmi)</span><br></pre></td></tr></table></figure>

<p>在有了海象运算符之后，你就可以不用在这种场景下做出妥协。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查出所有会员中过于肥胖的人的 bmi 指数</span></span><br><span class="line">fat_bmis = [bmi <span class="keyword">for</span> m <span class="keyword">in</span> members <span class="keyword">if</span> (bmi := get_bmi(m)) &gt; <span class="number">24</span>]</span><br></pre></td></tr></table></figure>

<p>最终从输出结果可以看出，只执行了 3 次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">执行了 <span class="number">1</span> 次</span><br><span class="line">执行了 <span class="number">2</span> 次</span><br><span class="line">执行了 <span class="number">3</span> 次</span><br><span class="line">[<span class="number">25.88057063502083</span>]</span><br></pre></td></tr></table></figure>

<p>这里仅介绍了列表推导式，但在字典推导式和集合推导式中同样适用。不再演示。</p>
<p>海象运算符，是一个新奇的特性，有不少人觉得这样这种特性会破坏代码的可读性。确实在一个新鲜事物刚出来时是会这样，但我相信经过时间的沉淀后，越来越多的人使用它并享受它带来的便利时，这种争议也会慢慢消失在历史的长河中。</p>
<p>作者：王一白<br>链接：<a href="https://juejin.im/post/5e9e78bef265da47d00a6e09" target="_blank" rel="noopener">https://juejin.im/post/5e9e78bef265da47d00a6e09</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>很多人不知道的Python 炫技操作：合并字典的七种方法</title>
    <url>/2020/04/22/%E5%BE%88%E5%A4%9A%E4%BA%BA%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Python-%E7%82%AB%E6%8A%80%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%90%88%E5%B9%B6%E5%AD%97%E5%85%B8%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Python 语言里有许多（而且是越来越多）的高级特性，是 Python 发烧友们非常喜欢的。在这些人的眼里，能够写出那些一般开发者看不懂的高级特性，就是高手，就是大神。</p>
<p>但你要知道，在团队合作里，炫技是大忌。</p>
<p>为什么这么说呢？我说下自己的看法：</p>
<ol>
<li>越简洁的代码，越清晰的逻辑，就越不容易出错；</li>
<li>在团队合作中，你的代码不只有你在维护，降低别人的阅读/理解代码逻辑的成本是一个良好的品德</li>
<li>简单的代码，只会用到最基本的语法糖，复杂的高级特性，会有更多的依赖（如语言的版本）</li>
</ol>
<p>该篇是「<strong>炫技系列</strong>」的第二篇内容，在这个系列里，我将总结盘点一下，我所见过的那些炫技操作。在这里，如果你是 Python 发烧友，你可以学到一些写出超酷的代码书写技巧。同时，看了这些内容，对你在阅读别人的代码时，也许会有些帮助。</p>
<a id="more"></a>

<h3 id="1-最简单的原地更新"><a href="#1-最简单的原地更新" class="headerlink" title="1. 最简单的原地更新"></a>1. 最简单的原地更新</h3><p>字典对象内置了一个 update 方法，用于把另一个字典更新到自己身上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info = &#123;<span class="string">"gender"</span>: <span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line">profile.update(ext_info)</span><br><span class="line">print(profile)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果想使用 update 这种最简单、最地道原生的方法，但又不想更新到自己身上，而是生成一个新的对象，那请使用深拷贝。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info = &#123;<span class="string">"gender"</span>: <span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line">full_profile = deepcopy(profile)</span><br><span class="line">full_profile.update(ext_info)</span><br><span class="line"></span><br><span class="line">print(full_profile)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">print(profile)</span><br><span class="line">&#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-先解包再合并字典"><a href="#2-先解包再合并字典" class="headerlink" title="2. 先解包再合并字典"></a>2. 先解包再合并字典</h3><p>使用 <code>**</code> 可以解包字典，解包完后再使用 dict 或者 <code>{}</code> 就可以合并。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info = &#123;<span class="string">"gender"</span>: <span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line">full_profile01 = &#123;**profile, **ext_info&#125;</span><br><span class="line">print(full_profile01)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"></span><br><span class="line">full_profile02 = dict(**profile, **ext_info)</span><br><span class="line">print(full_profile02)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>若你不知道 <code>dict(**profile, **ext_info)</code> 做了啥，你可以将它等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict(((<span class="string">"name"</span>, <span class="string">"xiaoming"</span>), (<span class="string">"age"</span>, <span class="number">27</span>), (<span class="string">"gender"</span>, <span class="string">"male"</span>)))</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-借助-itertools"><a href="#3-借助-itertools" class="headerlink" title="3. 借助 itertools"></a>3. 借助 itertools</h3><p>在 Python 里有一个非常强大的内置模块，它专门用于操作可迭代对象。</p>
<p>正好我们字典也是可迭代对象，自然就可以想到，可以使用 <code>itertools.chain()</code> 函数先将多个字典（可迭代对象）串联起来，组成一个更大的可迭代对象，然后再使用 dict 转成字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info = &#123;<span class="string">"gender"</span>: <span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line">dict(itertools.chain(profile.items(), ext_info.items()))</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-借助-ChainMap"><a href="#4-借助-ChainMap" class="headerlink" title="4. 借助 ChainMap"></a>4. 借助 ChainMap</h3><p>如果可以引入一个辅助包，那我就再提一个， <code>ChainMap</code> 也可以达到和 <code>itertools</code> 同样的效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"></span><br><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info = &#123;<span class="string">"gender"</span>: <span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line">dict(ChainMap(profile, ext_info))</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ChainMap 有一点需要注意，当字典间有重复的键时，只会取第一个值，排在后面的键值并不会更新掉前面的（使用 itertools 就不会有这个问题）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"></span><br><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info=&#123;<span class="string">"age"</span>: <span class="number">30</span>&#125;</span><br><span class="line">dict(ChainMap(profile, ext_info))</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用dict-items-合并"><a href="#5-使用dict-items-合并" class="headerlink" title="5. 使用dict.items() 合并"></a>5. 使用dict.items() 合并</h3><p>在 Python 3.9 之前，其实就已经有 <code>|</code> 操作符了，只不过它通常用于对集合（set）取并集。</p>
<p>利用这一点，也可以将它用于字典的合并，只不过得绕个弯子，有点不好理解。</p>
<p>你得先利用 <code>items</code> 方法将 dict 转成 dict_items，再对这两个 dict_items 取并集，最后利用 dict 函数，转成字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info = &#123;<span class="string">"gender"</span>: <span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line">full_profile = dict(profile.items() | ext_info.items())</span><br><span class="line">full_profile</span><br><span class="line">&#123;<span class="string">'gender'</span>: <span class="string">'male'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'name'</span>: <span class="string">'xiaoming'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，你如果嫌这样太麻烦，也可以简单点，直接使用 list 函数再合并（示例为 Python 3.x ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info = &#123;<span class="string">"gender"</span>: <span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line">dict(list(profile.items()) + list(ext_info.items()))</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>若你在 Python 2.x 下，可以直接省去 list 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info = &#123;<span class="string">"gender"</span>: <span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line">dict(profile.items() + ext_info.items())</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-最酷炫的字典解析式"><a href="#6-最酷炫的字典解析式" class="headerlink" title="6. 最酷炫的字典解析式"></a>6. 最酷炫的字典解析式</h3><p>Python 里对于生成列表、集合、字典，有一套非常 Pythonnic 的写法。</p>
<p>那就是列表解析式，集合解析式和字典解析式，通常是 Python 发烧友的最爱，那么今天的主题：字典合并，字典解析式还能否胜任呢？</p>
<p>当然可以，具体示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info = &#123;<span class="string">"gender"</span>: <span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;k:v <span class="keyword">for</span> d <span class="keyword">in</span> [profile, ext_info] <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items()&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-Python-3-9-新特性"><a href="#7-Python-3-9-新特性" class="headerlink" title="7. Python 3.9 新特性"></a>7. Python 3.9 新特性</h3><p>在 2 月份发布的 Python 3.9.04a 版本中，新增了一个抓眼球的新操作符操作符： <code>|</code>， PEP584 将它称之为合并操作符（Union Operator），用它可以很直观地合并多个字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">profile = &#123;<span class="string">"name"</span>: <span class="string">"xiaoming"</span>, <span class="string">"age"</span>: <span class="number">27</span>&#125;</span><br><span class="line">ext_info = &#123;<span class="string">"gender"</span>: <span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line">profile | ext_info</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"></span><br><span class="line">ext_info | profile</span><br><span class="line">&#123;<span class="string">'gender'</span>: <span class="string">'male'</span>, <span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>&#125;</span><br></pre></td></tr></table></figure>

<p>除了 <code>|</code> 操作符之外，还有另外一个操作符 <code>|=</code>，类似于原地更新。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ext_info |= profile</span><br><span class="line">ext_info</span><br><span class="line">&#123;<span class="string">'gender'</span>: <span class="string">'male'</span>, <span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>&#125;</span><br><span class="line"></span><br><span class="line">profile |= ext_info</span><br><span class="line">profile</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'xiaoming'</span>, <span class="string">'age'</span>: <span class="number">27</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，有没有涨姿势了，学了这么久的 Python ，没想到合并字典还有这么多的方法。本篇文章的主旨，并不在于让你全部掌握这 7 种合并字典的方法，实际在工作中，你只要选用一种最顺手的方式即可，但是在协同工作中，或者在阅读他人代码时，你不可避免地会碰到各式各样的写法，这时候你能下意识的知道这是在做合并字典的操作，那这篇文章就是有意义的。</p>
<p>作者：王一白<br>链接：<a href="https://juejin.im/post/5e8f23b16fb9a03c917fd40d" target="_blank" rel="noopener">https://juejin.im/post/5e8f23b16fb9a03c917fd40d</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>很多人不知道的Python炫技操作：条件语句的七种写法</title>
    <url>/2020/04/22/%E5%BE%88%E5%A4%9A%E4%BA%BA%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Python%E7%82%AB%E6%8A%80%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%83%E7%A7%8D%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<p>有的人说 Python 是一门 入门容易，但是精通难的语言，这一点我非常赞同。</p>
<p>Python 语言里有许多（而且是越来越多）的高级特性，是 Python 发烧友们非常喜欢的。在这些人的眼里，能够写出那些一般开发者看不懂的高级特性，就是高手，就是大神。</p>
<p>但你要知道，在团队合作里，炫技是大忌。</p>
<p>为什么这么说呢？我说下自己的看法：</p>
<ol>
<li>越简洁的代码，越清晰的逻辑，就越不容易出错；</li>
<li>在团队合作中，你的代码不只有你在维护，降低别人的阅读/理解代码逻辑的成本是一个良好的品德</li>
<li>简单的代码，只会用到最基本的语法糖，复杂的高级特性，会有更多的依赖（如语言的版本）</li>
</ol>
<p>在这个系列里，我将总结列举一下，我所见过的那些炫技操作，今天先来个热身，写一写很简单的条件判断语句里有哪些让人想骂街的炫技操作，在这里，如果你是 Python 发烧友，你可以学到一些写出超酷的代码书写技巧，但学习归学习，希望你区分场景使用。</p>
<a id="more"></a>

<h3 id="原代码"><a href="#原代码" class="headerlink" title="原代码"></a>原代码</h3><p>这是一段非常简单的通过年龄判断一个人是否成年的代码，由于代码行数过多，有些人就不太愿意这样写，因为这体现不出自己多年的 Python 功力。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"已成年"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"未成年"</span></span><br></pre></td></tr></table></figure>

<p>下面我列举了六种这段代码的变异写法，一个比一个还 6 ，单独拿出来比较好理解，放在工程代码里，没用过这些学法的人，一定会看得一脸懵逼，理解了之后，又不经意大呼：<strong>卧槽，还可以这样写？</strong>，而后就要开始骂街了：<strong>这是给人看的代码？</strong>  （除了第一种之外）</p>
<h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;on_true&gt; <span class="keyword">if</span> &lt;condition&gt; <span class="keyword">else</span> &lt;on_false&gt;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age1 = <span class="number">20</span></span><br><span class="line">age2 = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">msg1 = <span class="string">"已成年"</span> <span class="keyword">if</span> age1 &gt; <span class="number">18</span> <span class="keyword">else</span> <span class="string">"未成年"</span></span><br><span class="line">print(msg1)</span><br><span class="line">已成年</span><br><span class="line"></span><br><span class="line">msg2 = <span class="string">"已成年"</span> <span class="keyword">if</span> age2 &gt; <span class="number">18</span> <span class="keyword">else</span> <span class="string">"未成年"</span></span><br><span class="line">print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure>

<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;condition&gt; <span class="keyword">and</span> &lt;on_true&gt; <span class="keyword">or</span> &lt;on_false&gt;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg1 = age1 &gt; <span class="number">18</span> <span class="keyword">and</span> <span class="string">"已成年"</span> <span class="keyword">or</span> <span class="string">"未成年"</span></span><br><span class="line">msg2 = <span class="string">"已成年"</span> <span class="keyword">if</span> age2 &gt; <span class="number">18</span> <span class="keyword">else</span> <span class="string">"未成年"</span></span><br><span class="line"></span><br><span class="line">print(msg1)</span><br><span class="line">已成年</span><br><span class="line"></span><br><span class="line">print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure>

<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(&lt;on_true&gt;, &lt;on_false&gt;)[condition]</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg1 = (<span class="string">"未成年"</span>, <span class="string">"已成年"</span>)[age1 &gt; <span class="number">18</span>]</span><br><span class="line">print(msg1)</span><br><span class="line">已成年</span><br><span class="line"></span><br><span class="line">msg2 = (<span class="string">"未成年"</span>, <span class="string">"已成年"</span>)[age2 &gt; <span class="number">18</span>]</span><br><span class="line">print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure>

<h3 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h3><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">lambda</span>: &lt;on_false&gt;, <span class="keyword">lambda</span>:&lt;on_true&gt;)[&lt;condition&gt;]()</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg1 = (<span class="keyword">lambda</span>:<span class="string">"未成年"</span>, <span class="keyword">lambda</span>:<span class="string">"已成年"</span>)[age1 &gt; <span class="number">18</span>]()</span><br><span class="line">print(msg1)</span><br><span class="line">已成年</span><br><span class="line"></span><br><span class="line">msg2 = (<span class="keyword">lambda</span>:<span class="string">"未成年"</span>, <span class="keyword">lambda</span>:<span class="string">"已成年"</span>)[age2 &gt; <span class="number">18</span>]()</span><br><span class="line">print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure>

<h3 id="第五种"><a href="#第五种" class="headerlink" title="第五种"></a>第五种</h3><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="literal">True</span>: &lt;on_true&gt;, <span class="literal">False</span>: &lt;on_false&gt;&#125;[&lt;condition&gt;]</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg1 = &#123;<span class="literal">True</span>: <span class="string">"已成年"</span>, <span class="literal">False</span>: <span class="string">"未成年"</span>&#125;[age1 &gt; <span class="number">18</span>]</span><br><span class="line">print(msg1)</span><br><span class="line">已成年</span><br><span class="line"></span><br><span class="line">msg2 = &#123;<span class="literal">True</span>: <span class="string">"已成年"</span>, <span class="literal">False</span>: <span class="string">"未成年"</span>&#125;[age2 &gt; <span class="number">18</span>]</span><br><span class="line">print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure>

<h3 id="第六种"><a href="#第六种" class="headerlink" title="第六种"></a>第六种</h3><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">((&lt;condition&gt;) <span class="keyword">and</span> (&lt;on_true&gt;,) <span class="keyword">or</span> (&lt;on_false&gt;,))[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg1 = ((age1 &gt; <span class="number">18</span>) <span class="keyword">and</span> (<span class="string">"已成年"</span>,) <span class="keyword">or</span> (<span class="string">"未成年"</span>,))[<span class="number">0</span>]</span><br><span class="line">print(msg1)</span><br><span class="line">已成年</span><br><span class="line"></span><br><span class="line">msg2 = ((age2 &gt; <span class="number">18</span>) <span class="keyword">and</span> (<span class="string">"已成年"</span>,) <span class="keyword">or</span> (<span class="string">"未成年"</span>,))[<span class="number">0</span>]</span><br><span class="line">print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure>

<p>以上代码，都比较简单，仔细看都能看懂，我就不做解释了。</p>
<p>作者：王一白<br>链接：<a href="https://juejin.im/post/5e82c9f7f265da47c80119a3" target="_blank" rel="noopener">https://juejin.im/post/5e82c9f7f265da47c80119a3</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title> 查看Linux硬件信息</title>
    <url>/2019/11/19/%E6%9F%A5%E7%9C%8BLinux%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p><img src="https://images.codeflag.cn/%E6%9F%A5%E7%9C%8Blinux%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/8323e18cbc604bac8a09ff75617277bf.jfif" alt="用 Linux 命令显示硬件信息"></p>
<a id="more"></a>

<p>​        你可能会有很多的原因需要查清计算机硬件的详细信息。例如，你需要修复某些问题并在论坛上发出请求，人们可能会立即询问你的计算机具体的信息。或者当你想要升级计算机配置时，你需要知道现有的硬件型号和能够升级的型号。这些都需要查询你的计算机具体规格信息。</p>
<p>最简单的方法是使用标准的 Linux GUI 程序之一:</p>
<ul>
<li>i-nex 收集硬件信息，并且类似于 Windows 下流行的 CPU-Z 的显示。</li>
<li>HardInfo 显示硬件具体信息，甚至包括一组八个的流行的性能基准程序，你可以用它们评估你的系统性能。</li>
<li>KInfoCenter 和 Lshw 也能够显示硬件的详细信息，并且可以从许多软件仓库中获取。</li>
</ul>
<p>或者，你也可以拆开计算机机箱去查看硬盘、内存和其他设备上的标签信息。或者你可以在系统启动时，按下 相应的按键 进入 UEFI 和 BIOS 界面获得信息。这两种方式都会向你显示硬件信息但省略软件信息。</p>
<p>你也可以使用命令行获取硬件信息。等一下… 这听起来有些困难。为什么你会要这样做？</p>
<p>有时候通过使用一条针对性强的命令可以很轻松的找到特定信息。也可能你没有可用的 GUI 程序或者只是不想安装这样的程序。</p>
<p>使用命令行的主要原因可能是编写脚本。无论你是使用 Linux shell 还是其他编程语言来编写脚本通常都需要使用命令行。</p>
<p>很多检测硬件信息的命令行都需要使用 root 权限。所以要么切换到 root 用户，要么使用 sudo 在普通用户状态下发出命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo &lt;the_line_command&gt;</span><br></pre></td></tr></table></figure>

<p>并按提示输入你的密码。</p>
<p>这篇文章介绍了很多用于发现系统信息的有用命令。文章最后的快速查询表对它们作出了总结。</p>
<h2 id="硬件概述"><a href="#硬件概述" class="headerlink" title="硬件概述"></a>硬件概述</h2><p>下面几条命令可以全面概述计算机硬件信息。</p>
<p>inxi 命令能够列出包括 CPU、图形、音频、网络、驱动、分区、传感器等详细信息。当论坛里的人尝试帮助其他人解决问题的时候，他们常常询问此命令的输出。这是解决问题的标准诊断程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inxi -Fxz</span><br></pre></td></tr></table></figure>

<p>-F 参数意味着你将得到完整的输出，x 增加细节信息，z 参数隐藏像 MAC 和 IP 等私人身份信息。</p>
<p>hwinfo 和 lshw 命令以不同的格式显示大量相同的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hwinfo --short</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lshw -short</span><br></pre></td></tr></table></figure>

<p>这两条命令的长格式输出非常详细，但也有点难以阅读：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hwinfo</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lshw</span><br></pre></td></tr></table></figure>

<h2 id="CPU-详细信息"><a href="#CPU-详细信息" class="headerlink" title="CPU 详细信息"></a>CPU 详细信息</h2><p>通过命令你可以了解关于你的 CPU 的任何信息。使用 lscpu 命令或与它相近的 lshw 命令查看 CPU 的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lshw -C cpu</span><br></pre></td></tr></table></figure>

<p>在这两个例子中，输出的最后几行都列出了所有 CPU 的功能。你可以查看你的处理器是否支持特定的功能。</p>
<p>使用这些命令的时候，你可以通过使用 grep 命令过滤复杂的信息，并缩小所需信息范围。例如，只查看 CPU 品牌和型号:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lshw -C cpu | grep -i product</span><br></pre></td></tr></table></figure>

<p>仅查看 CPU 的速度（兆赫兹）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lscpu | grep -i mhz</span><br></pre></td></tr></table></figure>

<p>或其 BogoMips 额定功率:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lscpu | grep -i bogo</span><br></pre></td></tr></table></figure>

<p>grep 命令的 -i 参数代表搜索结果忽略大小写。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>Linux 命令行使你能够收集关于你的计算机内存的所有可能的详细信息。你甚至可以不拆开计算机机箱就能确定是否可以为计算机添加额外的内存条。</p>
<p>使用 dmidecode 命令列出每根内存条和其容量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmidecode -t memory | grep -i size</span><br></pre></td></tr></table></figure>

<p>使用以下命令获取系统内存更多的信息，包括类型、容量、速度和电压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lshw -short -C memory</span><br></pre></td></tr></table></figure>

<p>你肯定想知道的一件事是你的计算机可以安装的最大内存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmidecode -t memory | grep -i max</span><br></pre></td></tr></table></figure>

<p>现在检查一下计算机是否有空闲的插槽可以插入额外的内存条。你可以通过使用命令在不打开计算机机箱的情况下就做到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lshw -short -C memory | grep -i empty</span><br></pre></td></tr></table></figure>

<p>输出为空则意味着所有的插槽都在使用中。</p>
<p>确定你的计算机拥有多少显卡内存需要下面的命令。首先使用 lspci 列出所有设备信息然后过滤出你想要的显卡设备信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci | grep -i vga</span><br></pre></td></tr></table></figure>

<p>视频控制器的设备号输出信息通常如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00:02.0 VGA compatible controller: Intel Corporation 82Q35 Express Integrated Graphics Controller (rev 02)</span><br></pre></td></tr></table></figure>

<p>现在再加上视频设备号重新运行 lspci 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci -v -s 00:02.0</span><br></pre></td></tr></table></figure>

<p>输出信息中 prefetchable 那一行显示了系统中的显卡内存大小:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...Memory at f0100000 (32-bit, non-prefetchable) [size&#x3D;512K]I&#x2F;O ports at 1230 [size&#x3D;8]Memory at e0000000 (32-bit, prefetchable) [size&#x3D;256M]Memory at f0000000 (32-bit, non-prefetchable) [size&#x3D;1M]...</span><br></pre></td></tr></table></figure>

<p>最后使用下面的命令展示当前内存使用量（兆字节）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>

<p>这条命令告诉你多少内存是空闲的，多少命令正在使用中以及交换内存的大小和是否正在使用。例如，输出信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total used free shared buff&#x2F;cache availableMem: 11891 1326 8877 212 1687 10077Swap: 1999 0 1999</span><br></pre></td></tr></table></figure>

<p>top 命令为你提供内存使用更加详细的信息。它显示了当前全部内存和 CPU 使用情况并按照进程 ID、用户 ID 及正在运行的命令细分。同时这条命令也是全屏输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>

<h2 id="磁盘文件系统和设备"><a href="#磁盘文件系统和设备" class="headerlink" title="磁盘文件系统和设备"></a>磁盘文件系统和设备</h2><p>你可以轻松确定有关磁盘、分区、文件系统和其他设备信息。</p>
<p>显示每个磁盘设备的描述信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lshw -short -C disk</span><br></pre></td></tr></table></figure>

<p>通过以下命令获取任何指定的 SATA 磁盘详细信息，例如其型号、序列号以及支持的模式和扇区数量等：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdparm -i /dev/sda</span><br></pre></td></tr></table></figure>

<p>当然，如果需要的话你应该将 sda 替换成 sdb 或者其他设备号。</p>
<p>要列出所有磁盘及其分区和大小，请使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>

<p>使用以下命令获取更多有关扇区数量、大小、文件系统 ID 和 类型以及分区开始和结束扇区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>

<p>要启动 Linux，你需要确定 GRUB 引导程序的可挂载分区。你可以使用 blkid 命令找到此信息。它列出了每个分区的唯一标识符（UUID）及其文件系统类型（例如 ext3 或 ext4）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blkid</span><br></pre></td></tr></table></figure>

<p>使用以下命令列出已挂载的文件系统和它们的挂载点，以及已用的空间和可用的空间（兆字节为单位）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -m</span><br></pre></td></tr></table></figure>

<p>最后，你可以列出所有的 USB 和 PCI 总线以及其他设备的详细信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lspci</span><br></pre></td></tr></table></figure>

<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>Linux 提供大量的网络相关命令，下面只是几个例子。</p>
<p>查看你的网卡硬件详细信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lshw -C network</span><br></pre></td></tr></table></figure>

<p>ifconfig 是显示网络接口的传统命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>

<p>但是现在很多人们使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip link show</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure>

<p>在阅读输出时，了解常见的网络缩写十分有用：</p>
<p><img src="https://images.codeflag.cn/%E6%9F%A5%E7%9C%8Blinux%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/69f9d7df65494686aaf4ed93eb15545d.jfif" alt="用 Linux 命令显示硬件信息"></p>
<p>表中的星号是通配符，代表不同系统的任意字符。</p>
<p>使用以下命令显示默认网关和路由表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route | column -t</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure>

<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>让我们以显示最底层软件详细信息的两条命令来结束。例如，如果你想知道是否安装了最新的固件该怎么办？这条命令显示了 UEFI 或 BIOS 的日期和版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmidecode -t bios</span><br></pre></td></tr></table></figure>

<p>内核版本是多少，以及它是 64 位的吗？网络主机名是什么？使用下面的命令查出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<h2 id="快速查询表"><a href="#快速查询表" class="headerlink" title="快速查询表"></a>快速查询表</h2><p><img src="https://images.codeflag.cn/%E6%9F%A5%E7%9C%8Blinux%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/f6ab9b3f8af2415984dcc45b1519a03c.jfif" alt="用 Linux 命令显示硬件信息"></p>
<p><img src="https://images.codeflag.cn/%E6%9F%A5%E7%9C%8Blinux%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/44ab578616b149a2b8dfbdf502f505cf.jfif" alt="用 Linux 命令显示硬件信息"></p>
<p>原文：<a href="https://opensource.com/article/19/9/linux-commands-hardware-information" target="_blank" rel="noopener">https://opensource.com/article/19/9/linux-commands-hardware-information</a></p>
<p>作者： Howard Fosdick  选题： lujun9972 译者： way-ww 校对： wxy</p>
<p>引用地址：  <a href="https://www.toutiao.com/i6743851128955339276/" target="_blank" rel="noopener">https://www.toutiao.com/i6743851128955339276/</a> </p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>用curl命令计算响应时间(dns解析时间，响应时间，传输时间)</title>
    <url>/2019/11/02/%E7%94%A8curl%E5%91%BD%E4%BB%A4%E8%AE%A1%E7%AE%97%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4-dns%E8%A7%A3%E6%9E%90%E6%97%B6%E9%97%B4%EF%BC%8C%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h4 id="计算响应时间"><a href="#计算响应时间" class="headerlink" title="计算响应时间"></a>计算响应时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o &#x2F;dev&#x2F;null -s -w &quot; http_code:%&#123;http_code&#125;\n time_namelookup:%&#123;time_namelookup&#125;\n \</span><br><span class="line">    time_redirect:%&#123;time_redirect&#125;\n time_pretransfer:%&#123;time_pretransfer&#125;\n \</span><br><span class="line">    time_connect:%&#123;time_connect&#125;\n time_starttransfer:%&#123;time_starttransfer&#125;\n \</span><br><span class="line">    time_total:%&#123;time_total&#125;\n speed_download:%&#123;speed_download&#125;\n &quot; &quot;https:&#x2F;&#x2F;jiebaiyou.com&quot;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>输出结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http_code:000</span><br><span class="line">time_namelookup:0.002986</span><br><span class="line">time_redirect:0.000000</span><br><span class="line">time_pretransfer:0.000000</span><br><span class="line">time_connect:0.137609</span><br><span class="line">time_starttransfer:0.000000</span><br><span class="line">time_total:0.412923</span><br><span class="line">speed_download:0.000</span><br></pre></td></tr></table></figure>

<h4 id="HttpTime-数据说明"><a href="#HttpTime-数据说明" class="headerlink" title="HttpTime 数据说明"></a>HttpTime 数据说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time_total 总时间，按秒计。精确到小数点后三位。</span><br><span class="line">time_namelookup DNS解析时间,从请求开始到DNS解析完毕所用时间。</span><br><span class="line">time_connect 连接时间,从开始到建立TCP连接完成所用时间,包括前边DNS解析时间，如果需要单纯的得到连接时间，用这个time_connect 时间减去前边time_namelookup时间。</span><br><span class="line">time_appconnect 连接建立完成时间，如SSL&#x2F;SSH等建立连接或者完成三次握手时间。</span><br><span class="line">time_pretransfer 从开始到准备传输的时间。</span><br><span class="line">time_redirect 重定向时间，包括到最后一次传输前的几次重定向的DNS解析，连接，预传输，传输时间。</span><br><span class="line">time_starttransfer 开始传输时间。在发出请求之后，Web 服务器返回数据的第一个字节所用的时间</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>细说Golang的JSON解析</title>
    <url>/2021/07/01/%E7%BB%86%E8%AF%B4Golang%E7%9A%84JSON%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="细说Golang的JSON解析"><a href="#细说Golang的JSON解析" class="headerlink" title="细说Golang的JSON解析"></a>细说Golang的JSON解析</h3><p>之前一直写一些动态语言，觉得解析JSON还是很简单的，往往只需要几行代码就能拿到解析好的JSON对象。Go语言自带的json包可以让你在程序中方便的读取和写入 JSON 数据。生成JSON场景相对简单一些，<code>json.Marshal()</code>会根据传入的结构体生成JSON数据。解析JSON会把数据解析到结构体中，由于JSON格式的自由组合的特点，尤其是那些结构复杂的JSON数据对新手来说声明接受JSON数据的结构体类型就会陷入不知从何下手的困扰。 最近工作中由于要解析JS和PHP程序持久化的JSON数据，大概花了两个下午才搞清楚针对常见的JSON数据应该如何声明结构体类型，下面分别说明一下。</p>
<a id="more"></a>

<h4 id="解析简单JSON"><a href="#解析简单JSON" class="headerlink" title="解析简单JSON"></a>解析简单JSON</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> FruitBasket <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name    <span class="keyword">string</span> </span><br><span class="line">        Fruit   []<span class="keyword">string</span></span><br><span class="line">        Id      <span class="keyword">int64</span> <span class="string">`json:"ref"`</span><span class="comment">// 声明对应的json key</span></span><br><span class="line">        Created time.Time</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jsonData := []<span class="keyword">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "Name": "Standard",</span></span><br><span class="line"><span class="string">        "Fruit": [</span></span><br><span class="line"><span class="string">             "Apple",</span></span><br><span class="line"><span class="string">            "Banana",</span></span><br><span class="line"><span class="string">            "Orange"</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">        "ref": 999,</span></span><br><span class="line"><span class="string">        "Created": "2018-04-09T23:00:00Z"</span></span><br><span class="line"><span class="string">    &#125;`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> basket FruitBasket</span><br><span class="line">    err := json.Unmarshal(jsonData, &amp;basket)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(basket.Name, basket.Fruit, basket.Id)</span><br><span class="line">    fmt.Println(basket.Created)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： 由于<code>json.UnMarshal()</code>方法接收的是字节切片，所以首先需要把JSON字符串转换成字节切片<code>c := []byte(s)</code> Playground url: <a href="https://play.golang.org/p/mcB6Kb6zCHE" target="_blank" rel="noopener">play.golang.org/p/mcB6Kb6zC…</a></p>
<h4 id="解析内嵌对象的JSON"><a href="#解析内嵌对象的JSON" class="headerlink" title="解析内嵌对象的JSON"></a>解析内嵌对象的JSON</h4><p>把上面的Fruit值如果改成字典 <code>&quot;Fruit&quot; : {&quot;Name&quot;, &quot;Apple&quot;, &quot;PriceTag&quot;: &quot;$1&quot;}</code>, 变成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">jsonData := []<span class="keyword">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "Name": "Standard",</span></span><br><span class="line"><span class="string">    "Fruit" : &#123;"Name": "Apple", "PriceTag": "$1"&#125;,</span></span><br><span class="line"><span class="string">    "ref": 999,</span></span><br><span class="line"><span class="string">    "Created": "2018-04-09T23:00:00Z"</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br></pre></td></tr></table></figure>

<p>那么结构体类型应该这么声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json":Name"`</span></span><br><span class="line">    PriceTag <span class="keyword">string</span> <span class="string">`json:"PriceTag"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FruitBasket <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span> </span><br><span class="line">    Fruit   Fruit</span><br><span class="line">    Id      <span class="keyword">int64</span> <span class="string">`json:"ref"`</span><span class="comment">// 声明对应的json key</span></span><br><span class="line">    Created time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Playground url: <a href="https://play.golang.org/p/dqw6tLb4JWm" target="_blank" rel="noopener">play.golang.org/p/dqw6tLb4J…</a></p>
<h4 id="解析内嵌对象数组的JSON-Embed-Array-of-Object"><a href="#解析内嵌对象数组的JSON-Embed-Array-of-Object" class="headerlink" title="解析内嵌对象数组的JSON(Embed Array of Object)"></a>解析内嵌对象数组的JSON(Embed Array of Object)</h4><p>如果上面JSON对象里的Fruit值现在变成了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">"Fruit"</span> : [</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="string">"Name"</span>: <span class="string">"Apple"</span>,</span><br><span class="line">            <span class="string">"PriceTag"</span>: <span class="string">"$1"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="string">"Name"</span>: <span class="string">"Pear"</span>,</span><br><span class="line">	    <span class="string">"PriceTag"</span>: <span class="string">"$1.5"</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这种情况也简单把解析JSON的结构体做如下更改，把Fruit字段类型换为 <code>[]Fruit</code>即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"Name"`</span></span><br><span class="line">	PriceTag <span class="keyword">string</span> <span class="string">`json:"PriceTag"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FruitBasket <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span> </span><br><span class="line">    Fruit   []Fruit</span><br><span class="line">    Id      <span class="keyword">int64</span> <span class="string">`json:"ref"`</span><span class="comment">// 声明对应的json key</span></span><br><span class="line">    Created time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析具有动态Key的对象（Parse-a-JSON-object-with-dynamic-key"><a href="#解析具有动态Key的对象（Parse-a-JSON-object-with-dynamic-key" class="headerlink" title="解析具有动态Key的对象（Parse a JSON object with dynamic key)"></a>解析具有动态Key的对象（Parse a JSON object with dynamic key)</h4><p>下面再做一下复杂的变通，如果把上面的对象数组变为Key为水果ID的对象（object of object）比如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">"Fruit"</span> : &#123;</span><br><span class="line">	<span class="string">"1"</span>: &#123;</span><br><span class="line">		<span class="string">"Name"</span>: <span class="string">"Apple"</span>,</span><br><span class="line">		<span class="string">"PriceTag"</span>: <span class="string">"$1"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"2"</span>: &#123;</span><br><span class="line">		<span class="string">"Name"</span>: <span class="string">"Pear"</span>,</span><br><span class="line">		<span class="string">"PriceTag"</span>: <span class="string">"$1.5"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个Key的名字在声明结构体的时候是不知道值的，这样该怎么声明呢，答案是把Fruit字段的类型声明为一个key为string类型值为Fruit类型的map</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fruit <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"Name"`</span></span><br><span class="line">    PriceTag <span class="keyword">string</span> <span class="string">`json:"PriceTag"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FruitBasket <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span> </span><br><span class="line">    Fruit   <span class="keyword">map</span>[<span class="keyword">string</span>]Fruit</span><br><span class="line">    Id      <span class="keyword">int64</span> <span class="string">`json:"ref"`</span><span class="comment">// 声明对应的json key</span></span><br><span class="line">    Created time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> Fruit <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="keyword">string</span> <span class="string">`json:"Name"`</span></span><br><span class="line">        PriceTag <span class="keyword">string</span> <span class="string">`json:"PriceTag"`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> FruitBasket <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name    <span class="keyword">string</span> </span><br><span class="line">        Fruit   <span class="keyword">map</span>[<span class="keyword">string</span>]Fruit</span><br><span class="line">        Id      <span class="keyword">int64</span> <span class="string">`json:"ref"`</span><span class="comment">// 声明对应的json key</span></span><br><span class="line">        Created time.Time</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">    jsonData := []<span class="keyword">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "Name": "Standard",</span></span><br><span class="line"><span class="string">        "Fruit" : &#123;</span></span><br><span class="line"><span class="string">	    "1": &#123;</span></span><br><span class="line"><span class="string">		"Name": "Apple",</span></span><br><span class="line"><span class="string">		"PriceTag": "$1"</span></span><br><span class="line"><span class="string">	    &#125;,</span></span><br><span class="line"><span class="string">	    "2": &#123;</span></span><br><span class="line"><span class="string">		"Name": "Pear",</span></span><br><span class="line"><span class="string">		"PriceTag": "$1.5"</span></span><br><span class="line"><span class="string">	    &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        "ref": 999,</span></span><br><span class="line"><span class="string">        "Created": "2018-04-09T23:00:00Z"</span></span><br><span class="line"><span class="string">    &#125;`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> basket FruitBasket</span><br><span class="line">    err := json.Unmarshal(jsonData, &amp;basket)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> basket.Fruit &#123;</span><br><span class="line">	fmt.Println(item.Name, item.PriceTag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Playground url: <a href="https://play.golang.org/p/fh8JKa6pKJS" target="_blank" rel="noopener">play.golang.org/p/fh8JKa6pK…</a></p>
<h4 id="解析包含任意层级的数组和对象的JSON数据-arbitrary-arrays-and-objects"><a href="#解析包含任意层级的数组和对象的JSON数据-arbitrary-arrays-and-objects" class="headerlink" title="解析包含任意层级的数组和对象的JSON数据(arbitrary arrays and objects)"></a>解析包含任意层级的数组和对象的JSON数据(arbitrary arrays and objects)</h4><p>针对包含任意层级的JSON数据，声明结构体类型比较困难，<code>encode/json</code>包还提供另外一种方法来解析JSON数据。 <code>encoding/json</code>包使用：</p>
<ul>
<li>map[string]interface{} 存储JSON对象</li>
<li>[]interface 存储JSON数组</li>
</ul>
<p><code>json.Unmarshl</code> 将会把任何合法的JSON数据存储到一个interface{}类型的值，通过使用空接口类型我们可以存储任意值，但是使用这种类型作为值时需要先做一次类型断言。</p>
<p>示例代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">jsonData := []<span class="keyword">byte</span>(<span class="string">`&#123;"Name":"Eve","Age":6,"Parents":["Alice","Bob"]&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.Unmarshal(jsonData, &amp;v)</span><br><span class="line">data := v.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Println(k, v, <span class="string">"(string)"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">        fmt.Println(k, v, <span class="string">"(float64)"</span>)</span><br><span class="line">    <span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">        fmt.Println(k, <span class="string">"(array):"</span>)</span><br><span class="line">        <span class="keyword">for</span> i, u := <span class="keyword">range</span> v &#123;</span><br><span class="line">            fmt.Println(<span class="string">"    "</span>, i, u)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(k, v, <span class="string">"(unknown)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然将JSON数据存储到空接口类型的值中可以用来解析任意结构的JSON数据，但是在实际应用中发现还是有不可控的地方，比如将数字字符串的值转换成了float类型的值，所以经常会在运行时报类型断言的错误，所以在JSON结构确定的情况下还是优先使用结构体类型声明，将JSON数据到结构体中的方式来解析JSON。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>解决vim粘贴格式混乱(自动缩进问题)</title>
    <url>/2019/10/31/%E8%A7%A3%E5%86%B3vim%E7%B2%98%E8%B4%B4%E6%A0%BC%E5%BC%8F%E6%B7%B7%E4%B9%B1-%E8%87%AA%E5%8A%A8%E7%BC%A9%E8%BF%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p> 问题如下，复制后因为自动缩进，产生了每行行首的自动缩进累积：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#原内容  </span><br><span class="line">  'WeChat' =&gt;</span><br><span class="line">    array (</span><br><span class="line">      'Token' =&gt; '',</span><br><span class="line">      'EncodingAESKey' =&gt; '',</span><br><span class="line">      'AppID' =&gt; '',</span><br><span class="line">    ),</span><br><span class="line">#粘贴后内容             </span><br><span class="line">  'WeChat' =&gt;</span><br><span class="line">    array (</span><br><span class="line">        'Token' =&gt; '',</span><br><span class="line">            'EncodingAESKey' =&gt; '',</span><br><span class="line">                'AppID' =&gt; '',</span><br><span class="line">                    ),</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>在粘贴前，取消缩进</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:set paste</span><br></pre></td></tr></table></figure>

<p>粘贴完后，恢复缩进</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:set nopaste</span><br></pre></td></tr></table></figure>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>推荐的方式，使用<code>+p</code> 或 <code>*p</code> 粘贴缓冲区内容， <code>+p</code>比 <code>ctrl+v</code>命令更好，它可以更快更可靠地处理大块文本的粘贴，也能够避免粘贴大量文本时，发生每行行首的自动缩进累积，因为<code>ctrl+v</code>是通过系统缓存的stream处理，一行一行地处理粘贴的文本。 </p>
<h4 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h4><p>使用键盘映射，这样在每一次复制前按F11取消缩进，复制后再按一次恢复缩进</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;vimrc </span><br><span class="line">set pastetoggle&#x3D;&lt;F11&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:map &lt;F10&gt; :set paste&lt;CR&gt;</span><br><span class="line">:map &lt;F11&gt; :set nopaste&lt;CR&gt;</span><br></pre></td></tr></table></figure>

<h4 id="方法四："><a href="#方法四：" class="headerlink" title="方法四："></a>方法四：</h4><p>在配置文件中增加如下一行，使用鼠标复制内容到选择缓冲区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;vimrc </span><br><span class="line">set mouse&#x3D;v</span><br></pre></td></tr></table></figure>
<p>需要带行号时，使用鼠标选择内容区域。<br>不需要行号，使用<code>yny</code>复制n行或可视模式下选择。<br>将选择缓冲区中内容粘贴到vim文件：普通模式下按<code>+p</code> 或 <code>*p</code>粘贴缓冲区内容</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>高频使用的 Git 命令集合，看完自信 git push！</title>
    <url>/2020/01/14/%E9%AB%98%E9%A2%91%E4%BD%BF%E7%94%A8%E7%9A%84-Git-%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88%EF%BC%8C%E7%9C%8B%E5%AE%8C%E8%87%AA%E4%BF%A1-git-push%EF%BC%81/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>汇总下我在项目中高频使用的git命令及姿势。<br>不是入门文档，官方文档肯定比我全面，这里是结合实际业务场景输出。<br>使用的 Git版本：git version 2.24.0</p>
<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>查看日志，常规操作，必备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出概要日志,这条命令等同于</span></span><br><span class="line"><span class="comment"># git log --pretty=oneline --abbrev-commit</span></span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定最近几个提交可以带上 - + 数字</span></span><br><span class="line">git <span class="built_in">log</span> --oneline -5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供类似 GUI 工具的 log 展示</span></span><br><span class="line">git <span class="built_in">log</span> --graph --date=relative --pretty=tformat:<span class="string">'%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%an %ad)%Creset'</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>查看工作区状态的东东，不如GUI直观，但是命令行也有一些用的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 等同 git status --long,查看当前工作区暂存区变动</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 概要信息 (--short)</span></span><br><span class="line">git status -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询工作区中是否有stash存在（暂存的东西）,有则提醒该工作区有几个 stash</span></span><br><span class="line">git status  --show-stash</span><br></pre></td></tr></table></figure>

<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>用来切换到对应记录的,可以基于分支,提交,标签。<br>切提交和标签一般用来热修复或者老版本需要加新特性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分支切换</span></span><br><span class="line">git checkout dev <span class="comment"># local branch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换远程分支</span></span><br><span class="line">git checkout origin/<span class="built_in">test</span> <span class="comment"># remote branch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于远程分支创建本地分支，并跟踪对应来自 'origin' 的远程分支</span></span><br><span class="line">git checkout --track origin/feature-test <span class="comment"># new local branch wih remote branch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于本地分支开出新分支</span></span><br><span class="line">git checkout -b testbranch <span class="comment"># new local branch with current branch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 彻底丢弃某个文件的改动</span></span><br><span class="line">git checkout -- file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃本地所有改动</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换上一个分支</span></span><br><span class="line">git checkout -</span><br></pre></td></tr></table></figure>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>天天打交道的命令，这里说一些很常见的姿势</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新修改的内容,添加到上次提交中,减少提交的日志</span></span><br><span class="line"><span class="comment"># --no-edit:是跳过进入编辑器，直接提交</span></span><br><span class="line"><span class="comment"># git commit --amend这条命令等同于</span></span><br><span class="line"><span class="comment"># $ git reset --soft HEAD^</span></span><br><span class="line"><span class="comment"># $ ... do something  tree ...</span></span><br><span class="line"><span class="comment"># $ git commit -c ORIG_HEAD</span></span><br><span class="line">git commit --amend --no-edit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过校验直接提交,包括任何 githooks</span></span><br><span class="line">git commit --no-verify -m <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 带提交概要信息</span></span><br><span class="line">git commit -m <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定目录格式提交</span></span><br><span class="line"><span class="comment"># -t &lt;file&gt;, --template=&lt;file&gt;</span></span><br><span class="line"><span class="comment"># 也可以从全局或者项目级别指定提交的模板文件</span></span><br><span class="line"><span class="comment"># git config [--global] commit.template xxx</span></span><br><span class="line"><span class="comment"># 现在一般都是 用社区的npm规范包，commitizen 和 commitlint 来规范提交</span></span><br><span class="line">git commit -t templateFile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交信息从文件读取,可以结合上面的一起用</span></span><br><span class="line">git commit -F</span><br></pre></td></tr></table></figure>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>不得不说，代码回滚中这个命令也是用的很多，而且是 <code>--hard</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 硬性回滚,简单粗暴，直接抛弃回滚之后改动(log 还是有保留，内容不要而已)</span></span><br><span class="line">git reset --hard commit_sha1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 软性回滚, 跟 rebase 常规用法差不多的效果，可以把提交的东西丢回暂存区和工作区，</span></span><br><span class="line"><span class="comment"># HEAD 的指向改变会对应的 commit,之后再考虑怎么 commit</span></span><br><span class="line">git reset --soft commit_sha1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 软回滚一个版本,可以理解为撤销最近一次的 commit</span></span><br><span class="line">git reset --soft HEAD~1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除暂存区但保留工作区变动。</span></span><br><span class="line">git reset --mixed commit_sha1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留工作区和暂存区之间的差异。</span></span><br><span class="line">git reset --merge commit_sha1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留工作区和HEAD之间的差异</span></span><br><span class="line">git reset --keep commit_sha1</span><br></pre></td></tr></table></figure>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>一般用于master 的代码回滚，因为多人在上面协作，<br><code>revert</code> 可以平稳的回滚代码,但却保留提交记录,不会让协作的人各种冲突！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回滚到某个 commit</span></span><br><span class="line">git revert commit-sha1</span><br></pre></td></tr></table></figure>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>变基在项目中算是很频繁的，为什么这么说。<br>比如你开发一个新的 feature, 遵循最小化代码提交的理念。<br>在整个功能开发完毕的时侯，会有非常多的 commit，用 <code>rebase</code> 可以让我们的commit记录很干净</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 带 -i 可以进入交互模式，效果如下</span></span><br><span class="line">git rebase -i git-sha1|branch(HEAD)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若是中间毫无冲突，变基则一步到位，否则需要逐步调整。</span></span><br><span class="line">git rebase --<span class="built_in">continue</span> <span class="comment"># 提交变更后继续变基下一步</span></span><br><span class="line">git rebase --skip <span class="comment"># 引起冲突的commits会被丢弃，continue提示没有需要改动的也可以用这个跳过</span></span><br><span class="line">git rebase --abort <span class="comment"># 若是变基改残废了，但是走到一半，可以彻底回滚变基之前的状态</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pick: 是保留该 commit(采用)</li>
<li>edit: 一般你提交的东西多了,可以用这个把东东拿回工作区拆分更细的 commit</li>
<li>reword: 这个可以重新修改你的 commit msg</li>
<li>squash: 内容保留，把提交信息往上一个 commit 合并进去</li>
<li>fixup: 保留变动内容，但是抛弃 commit msg</li>
<li>drop: 用的比较少，无用的改动你会提交么！！！</li>
</ul>
<p>突然发现截图还有几个新的行为，估计是新版本带来的，从字面上就可以看出来大体的意思, 就是把回滚和打标签这些放到变基中简化操作。</p>
<h4 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h4><ul>
<li>本地提交之前，最好把基准点变为需要合并的分支，这样提交 PR/MR 的时侯就不会冲突(本地来解决冲突)</li>
<li>不要在公共分支上变基！！！一变其他协作者基本都一堆冲突！除非你们有很清晰的分支管理机制</li>
</ul>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --ff 是指fast-forward命令,当使用ff模式进行合并时，将不会创造一个新的commit节点。</span></span><br><span class="line"><span class="comment"># --no-ff,保留合并分支的提交记录,一般主干用的比较多.</span></span><br><span class="line"><span class="comment"># --ff-only 除非当前HEAD节点为最新节点或者能够用ff模式进行合并，否则拒绝合并并返回一个失败状态。</span></span><br><span class="line"><span class="comment"># --squash 则类似 rebase squash,可以把合并多个 commit 变成一个</span></span><br><span class="line">git merge --no-ff branchName</span><br></pre></td></tr></table></figure>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>git pull中用的最多是带<code>--rebase(-r)</code>的方式(变基形式拉取合并代码),保持分支一条线。<br>默认的pull会走ff模式,多数情况会产生新的commit,部分参数与 merge提供一致。</p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>当本地分支存在，远程分支不存在的时侯，可以这样推送关联的远程分支</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这样会直接新建一个同名的远程分支</span></span><br><span class="line">git push origin localbranch </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支(--delete)</span></span><br><span class="line">git push -d origin branchName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有标签</span></span><br><span class="line">git push --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送 commit 关联的 tags</span></span><br><span class="line">git push --follow-tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制推送(--force)</span></span><br><span class="line">git push -f origin branchName <span class="comment"># 一般合理的项目，主干都做了分支保护,不会允许强推行为</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时候真的需要强推的时侯,但可不可以柔和一点呢？</span></span><br><span class="line"><span class="comment"># 就是当前远程分支和你本地一致,没有别人提交的情况下可以强推</span></span><br><span class="line"><span class="comment"># --force-with-lease: 若是远程有人提交，此次强推失败，反之成功</span></span><br><span class="line">git push --force-<span class="keyword">with</span>-lease</span><br></pre></td></tr></table></figure>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>这个东西用在你需要考虑维护多个地方仓库的时侯会考虑，或者修改仓库源的时侯</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常规关联本地 git init 到远程仓库的姿势</span></span><br><span class="line">git remote add origin url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增其他上游仓</span></span><br><span class="line">git remote add github url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改推送源</span></span><br><span class="line">git remote <span class="built_in">set</span>-url  origin(或者其他上游域) url</span><br></pre></td></tr></table></figure>
<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>该命令用的最多的就是删除本地分支，重命名分支，删除远程分支了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分支删除，拷贝，重命名，参数若是大写就等同多了--force，强制执行</span></span><br><span class="line"><span class="comment"># -c, --copy : 复制分支，</span></span><br><span class="line"><span class="comment"># -C：等同于 --copy --force</span></span><br><span class="line"><span class="comment"># -d, --delete: 删除分支</span></span><br><span class="line"><span class="comment"># -m, --move：移动或者重命名分支</span></span><br><span class="line">git branch -d branchName</span><br><span class="line">git branch -M oldBranch newNameBranch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动指定它的当前分支的上游分支,两个写法一致的</span></span><br><span class="line"><span class="comment"># 有关联一般也有取消关联，--unset-upstream</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream-to=origin/xxx </span><br><span class="line">git branch --<span class="built_in">set</span>-upstream-to origin xxx</span><br></pre></td></tr></table></figure>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>暂存用的最多时侯就是你撸代码撸到一半，突然说有个紧急 BUG 要修正。<br>或者别人在你这里需要帮忙排查代码，你这时候也会用到。<br>强烈建议给每个 stash 添加描述信息！！！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缓存当前工作区的内容到stashName, save 这个现在不怎么推荐用，图方便也能用</span></span><br><span class="line"><span class="comment"># -a|--all: 除了未跟踪的文件，其他变动的文件都会保存</span></span><br><span class="line"><span class="comment"># -u|--include-untracked：包括没有添加到暂存区的文件</span></span><br><span class="line">git stash save stashName</span><br><span class="line">git stash -u save stashName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在基本推荐用 push,因为有 pop，语义上和维护上更清晰</span></span><br><span class="line"><span class="comment"># 上面有的参数，它也有，还有-m 来备注这个 stash 的大概情况</span></span><br><span class="line">git stash push -m <span class="string">"更改了 xx"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 有保存那肯定也有取用的</span></span><br><span class="line"><span class="comment"># pop: 取会删除对应的保存记录</span></span><br><span class="line"><span class="comment"># apply: 取但保留记录</span></span><br><span class="line"><span class="comment"># 0就是--index,这个东西哪里来的呢？</span></span><br><span class="line">git stash apply stash@&#123;0&#125;</span><br><span class="line">git stash pop stash@&#123;0&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看stash 保存记录</span></span><br><span class="line"><span class="comment"># eg: stash@&#123;0&#125;: On dev: 测试</span></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只想删除暂存记录怎么办：</span></span><br><span class="line"><span class="comment"># clear : 清空所有 stash</span></span><br><span class="line"><span class="comment"># drop: 清除指定的 stash</span></span><br><span class="line">git stash clear <span class="comment"># 慎用！</span></span><br><span class="line">git stash drop stash@&#123;0&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想看 stash 做了什么改动，类似简化版的git diff</span></span><br><span class="line">git stash show stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>这个命令的强大之处，是记录了所有行为，包括你 <code>rebase</code>,<code>merge</code>, <code>reset</code> 这些<br>当我们不小心硬回滚的时侯,或变基错了都可以在这里找到行为之前的commit，然后回滚。<br>当然这个时间回溯也只在本地有用，你推送到远程分支的破坏性改动,该凉还是得凉。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最近五次行为,不带-n 则默认所有</span></span><br><span class="line">git reflog -5</span><br></pre></td></tr></table></figure>
<h4 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h4><p>这个东西你可以理解为你去买橘子，你会专门挑一些符合心意的橘子放到购物篮中。你可以从多个分支同时挑取部分需要的 commit 合并到同一个地方去，是不是贼骚。这货和变基有点类似，但是仅仅类似，挑过来的 commit 若是没有冲突则追加。有冲突会中断，解决后 <code>--continue</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前分支挑其他分支的 commit，把那部分的变动那过来</span></span><br><span class="line">git cherry-pick commit-sha1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持一次性拿多个</span></span><br><span class="line">git cherry-pick master~4 master~2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持区间, 区间中间是 .. </span></span><br><span class="line">git cherry-pick startGitSha1..endGitSha1</span><br><span class="line"></span><br><span class="line"><span class="comment"># --continue：继续 pick,一般有冲突解决后才需要这样</span></span><br><span class="line"><span class="comment"># --skip：跳过这次进入队列下一次行为 </span></span><br><span class="line"><span class="comment"># --abort : 完全放弃 pick，恢复 pick 之前的状态</span></span><br><span class="line"><span class="comment"># --quit: 未冲突的自动变更，冲突的不要，退出这次 pick</span></span><br><span class="line"><span class="comment"># 这几个状态跟变基差不多,解决冲突继续，跳过处理，放弃这次pick,不输出错误</span></span><br></pre></td></tr></table></figure>
<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>这个命令在旧的版本用的比较最多的姿势是为了重新索引.gitignore 的范围</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除某个文件的索引</span></span><br><span class="line"><span class="comment"># --cache 不会删除硬盘中的文件，只是 git 索引(缓存)的关系！！！</span></span><br><span class="line">git rm --cache -- file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归清除全部所有索引(也可以理解为缓存吧),这个姿势适合重新让.gitignore 新范围生效</span></span><br><span class="line">git rm -r --cached .  </span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure>
<h3 id="git-rev-parse"><a href="#git-rev-parse" class="headerlink" title="git rev-parse"></a>git rev-parse</h3><p>这个估计一般人用的不是很多，可以通过这个快速获取部分git 仓库的信息<br>我在弄脚本的时侯就会从这里拿东西</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取最新有效的commit</span></span><br><span class="line"><span class="comment"># --short：显示七位的 sha1,不带就是全部</span></span><br><span class="line"><span class="comment"># --verify: 校验是否有效commit</span></span><br><span class="line"><span class="comment"># HEAD: 当前分支的head 指向</span></span><br><span class="line">git rev-parse --short HEAD --verify</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示仓库的绝对路径</span></span><br><span class="line">git rev-parse --show-toplevel <span class="comment">#eg: /Users/linqunhe/Code/aozhe/thinking-ui</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示版本库.git 目录所在的位置</span></span><br><span class="line">git rev-parse --git-dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有关联引用的 git sha1</span></span><br><span class="line">git rev-parse --all</span><br></pre></td></tr></table></figure>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>对于这个命令，在终端比对用的不是很频繁，除了少量改动的时侯可能会用这个看看。<br>其他情况下我更倾向于用 GUI 工具来看，因为比对更加直观。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>git 的常用命令其实很好掌握，很多命令都有 Linux 的影子。<br>列出来的命令都是高频使用的，或许有一些更骚的姿势没有摸索到</p>
<p>文章引用自：<a href="https://www.jianshu.com/p/0993bf65c8c4" target="_blank" rel="noopener">https://www.jianshu.com/p/0993bf65c8c4</a></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
